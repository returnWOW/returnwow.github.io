{"meta":{"title":"LKJ Hexo Blog","subtitle":"wow Blog","description":"Blog","author":"LKJ","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"学习bs4模块","slug":"python/bs4/learn_bs4","date":"2017-11-29T12:14:07.490Z","updated":"2017-11-29T12:12:16.620Z","comments":true,"path":"2017/11/29/python/bs4/learn_bs4/","link":"","permalink":"http://yoursite.com/2017/11/29/python/bs4/learn_bs4/","excerpt":"","text":"学习bs4模块 直接在官方网站上面学习 介绍 bs4是一个格式化读取xml，html文档的库可以使xml、html按照标签的形式操作，具体是将HTML文档转换成一个复杂的树形结构。官方推荐lxml来解析HTML所有节点对象可以归纳为4种: Tag , NavigableString , BeautifulSoup , Comment . 简单使用操作1234from bs4 import BeautifulSouphtml_doc = &apos;&apos;soup = BeautifulSoup(html_doc, &apos;html.parser&apos;)print(soup.prettify()) #美化输出，格式化缩进。 一般属性 soup.title：获取页面的标题，包含标签 soup.title.name：获取页面标题标签的内容 soup.title.string：获取页面标题的内容 soup.title.parent.name：父标签名字 soup.p：p是标签名字 soup.p[&#39;class&#39;]：第一个匹配p的标签，成员class soup.a：同上 一般方法 soup.find_all(&#39;a&#39;)：找到所以的a标签 查找所有的a标签12345for link in soup.find_all(&apos;a&apos;): print(link.get(&apos;href&apos;)) # http://example.com/elsie # http://example.com/lacie # http://example.com/tillie soup.get_text()：拿到文档中所有的文字内容，实际测试新浪的首页存在问题，使用html5lib也一致。 对象的种类Tag Tag对象和XML或HTML原生文档中的tag相同 Tag重要的属性 name每个Tag都有自己的名字，通过name属性来获取，比如xxx，Tag名称就是title如果改变了某个tag的名称，那么将影响当前生成的hml对象文档tag.name = &#39;xxx&#39; Attributes一个Tag可能存在属性，属性的操作和字典相同可以直接使用attrs获取全部属性tag的属性可以添加删除或者修改。操作和字典一致。 多值属性 一个属性可能有多个值，这里返回其列表。&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;：将会返回body和strikeout的列表如果存在多个值，但是HTML定义中并没有定义为多值属性，那么还是返回字符串并且可以传入列表以修改多值属性，传入列表为多值。xml中不包含多值 可以遍历的字符串 字符串常被包含在tag内.Beautiful Soup用 NavigableString 类来包装tag中的字符串节点下的字符串不可以编辑，但是可以替换，使用replace_with(‘xxx’)字符串不支持：contents，string属性或find()方法需要在此之外使用字符串，使用unicode将其转换为普通的Unicode字符串，减少内存占用。 子节点 soup.body.b：body节点下的b节点 tag.contents：可以将节点下的子节点以列表方式输出。 tag.children：子节点生成器， descendants：后裔，多所有的子孙节点递归循环，这样会将string也单独提取出来 节点下的string：如果节点下面存在子节点，并且子节点不是内容节点，那么返回None strings and stripped_strings：解决了上面的问题，使用这个将打印节点下的所以字符串，其中stripped_strings去除空格 BeautifulSoup对象 表示文档的全部内容大部分时候可以将它当做Tag对象。 搜索文档树 很多搜索方法，这里解释：find()和find_all()其它操作方法类似 过滤器 字符串使用字符串来过滤查找，比如soup.find_all(&#39;a&#39;)来找到a标签 正则表达式支持正则表达式，比如：soup.find_all(re.compile(&quot;^b&quot;)) 列表参数传入列表参数：[&#39;a&#39;, &#39;b&#39;] 找出a b的标签 True传入True值，那么会找到所有节点，但是没有字符串。 方法如果没有合适的过滤器，那么可以传入方法，方法接收一个参数1234567891011def has_class_but_no_id(tag): return tag.has_attr(&apos;class&apos;) and not tag.has_attr(&apos;id&apos;)def not_lacie(href): return href and not re.compile(&quot;lacie&quot;).search(href)soup.find_all(href=not_lacie)from bs4 import NavigableStringdef surrounded_by_strings(tag): return (isinstance(tag.next_element, NavigableString) and isinstance(tag.previous_element, NavigableString)) 具体参数 find_all( name , attrs , recursive , string , **kwargs ) name 用来查找所以tag attrs 传入字典 recursive 传入False只便利直接的子节点 string 查找内容，页面上的文本内容，可以传入文字，列表，正则表达式，True **kwargs 传入关键字参数 比如：id=’xxx’ 同时可以过滤多个这样的属性 limit 限制查找的数量有些tag属性在搜索不能使用,比如HTML5中的 data-* 属性:data_soup = BeautifulSoup(‘foo!‘)data_soup.find_all(data-foo=”value”)SyntaxError: keyword can’t be an expression但是可以通过 find_all() 方法的 attrs 参数定义一个字典参数来搜索包含特殊属性的tag:data_soup.find_all(attrs={“data-foo”: “value”})[foo!]但标识CSS类名的关键字 class 在Python中是保留字,使用 class 做参数会导致语法错误.从Beautiful Soup的4.1.1版本开始,可以通过 class_ 参数搜索有指定CSS类名的tag: 子节点 一个节点可能包含一个或者多个子节点 contents and children：返回子节点的列表，后者返回迭代器。 descendants：后裔，会将字符串也打印出来。 srting：得到节点下的NavigableString对象 strings and stripped_strings：得到节点下的所以NString对象，后者会去除空格和空行。 父节点 每个节点或者字符串都有父节点 parent：得到直接父节点 parents：得到所有的父节点 兄弟节点 next_sipling and previous_sibling：类似遍历兄弟节点 next_siplings and previous_siblings：当前节点之前或者之后的所有兄弟节点迭代输出 回退和前进 next_element and previous_element：返回当前节点上一个或者下一个被解析对象 next_elements and previous_elements：对应的就是前后所有被解析的对象，就像HTML对象正在被解析一样 像调用 find_all() 一样调用tag12soup.find_all(&quot;a&quot;)soup(&quot;a&quot;) 这两行是等价的","categories":[],"tags":[{"name":"学习 python bs4","slug":"学习-python-bs4","permalink":"http://yoursite.com/tags/学习-python-bs4/"}]},{"title":"Numpy基础","slug":"python/numpy/02_quickstart_tutorial","date":"2017-11-20T13:51:00.933Z","updated":"2017-11-28T14:31:44.030Z","comments":true,"path":"2017/11/20/python/numpy/02_quickstart_tutorial/","link":"","permalink":"http://yoursite.com/2017/11/20/python/numpy/02_quickstart_tutorial/","excerpt":"","text":"NumPy基础 NumPy的主要对象是同类型的多维数组，是一张表，所有元素（通常是数字）的类型都相同。维度称为axes，axes的数目为rank。如下rank为2（2维的），第一维度axes长度为2，第二维度axes长度为3.[[ 1., 0., 0.],[ 0., 1., 2.]]NumPy的数组的类称为ndarray。Python的数组提供较少的功能，而ndarray一下重要的属性。 属性 ndarray.ndim：数组的axes（维度）的个数，维度的数量称为rank。 ndarray.shape：数组的维度。这是一个整数元组，(n, m)表示一个n行，m列的矩阵。 ndarray.size：为shape元素的乘积，其实就是矩阵元素个数。 ndarray.dtype：描述矩阵中元素的类型的对象。可以使用Python标准的类型，也提供其他类型，例如：numpy.int32、numpy.int16和numpy.float64。 ndarray.itemsize：数组中每个元素的字节大小。例如float64字节数为8。 ndarray.data：该缓冲区包含数组的实际元素。通常不适用这个，我们一般使用索引进行访问（前面矢量化又说不要遍历，后续看看是怎么回事）。 打开中文API查看示例：属性示例 数组创建 有几种方法来创建数组 可以使用array函数从常规的Python列表或元组中创建数组，得到的数组类型从序列中元素的类型推到而出。&gt;&gt;&gt; numpy.array([3, 4, 5]) array函数传入列表的列表产生2维阵列，同理3维。&gt;&gt;&gt; numpy.array([1, 2, 3], [4, 5, 6])array([[1, 2, 3][4, 5, 6]]) 数组的类型可以在创建的时候指定&gt;&gt;&gt; numpy.array([1, 2, 3], dtype=complex) #元素为复数形式 1. + 0.j 通常数组的元素是位置的，所有NumPy提供创建具体初始占位符的数组，减少数组增长的必要。 函数zeros创建一个由0组成的数组； 函数ones创建一个由1数组的数组； 函数empty内容是随机的并且取决于存储器的状态，元素默认类型是float64。 为了创建数组序列，NumPy提供了类似于range的函数，返回数组而不是列表。 &gt;&gt;&gt; numpy.arange(1, 10, 2) #使用如上的reshape函数可以改变形状。起始为1步长为2。 当arange与浮点参数一起使用时，由于浮点数的精度是有限的，通常不可能预测获得的元素数量。出于这个原因，通常最好使用函数linspace，它接收我们想要的元素数量而不是步长作为参数：&gt;&gt;&gt; numpy.linspace(1, 2, 9) # 1到二之间的9个数，感觉是平均分配的样子。步长0.125‘&gt;&gt;&gt; numpy.sin(numpy.linspace(0, 2*pi, 100))’ #求sin。其他函数：array, zeros, zeros_like, ones, ones_like, empty, empty_like, arange,linspace, numpy.random.rand, numpy.random.randn, fromfunction, fromfile 打印数组 当打印数组时，NumPy以类似于嵌套列表的方式显示它，但是使用以下布局： 最后一个axes从左到右打印， 第二个到最后一个从上到下打印， 其余的也从上到下打印，每个切片与下一个用空行分开 如果数组太大，会跳过中间的部分，只打印边角部分。 如果需要强制打印整个数组，可以使用set_printoptions来更改打印选项numpy.set_printoptions(threshold=&#39;nan&#39;) #官方api说传入的是int值，nan目前不知道什么意思：后面查看可以传入numpy.nan，而非str类型 reshape改变数组形状 a.ravel() #平坦化序列，比如3 * 4的矩阵，变成一维矩阵。 a.reshape(x, y) #转变形状到x*y 元素需要支持转换该形状才行，如果y=-1则会自动计算维度。 a.T #转置 transposed numpy.resize方法直接改变数组本身 基本操作数组上的算术运算符使用元素基本，将创建一个新数组并用结果填充，差不多就是对应到每个元素，然后返回计算结果。 &gt;&gt;&gt; a = numpy.array([20, 30, 40, 50])&gt;&gt;&gt; b = numpy.arange(4) &gt;&gt;&gt; c = a - b #对应求其差值 &gt;&gt;&gt; b**2 #b元素都乘2 &gt;&gt;&gt; 10*np.sin(a) #对a每个元素求sin，并乘10倍值。 &gt;&gt;&gt; a &lt; 35 #对a元素做判断，返回boolean矩阵。 dot函数做矩阵的乘法：a.dot(b) np.dot(a, b) a * b 是对a和b对应位置的元素做乘积 += *= 类似的操作会修改当前数组，而不是创建新的数组： ‘&gt;&gt;&gt; a = np.ones((2,3), dtype=int)’ &gt;&gt;&gt; b = np.random.random((2, 3)) &gt;&gt;&gt; a *= 3 &gt;&gt;&gt; b += a &gt;&gt;&gt; a += b #报错， float64 to int32 不同类型的数组操作，结果数组的类型对应更精确的数组，向上转型。 比如int32 和 float64计算 结果类型为float64 许多一元操作，求和sum，可以使用ndarray的方法 sum(), max(), min() 默认的这些操作适用于数组，就像一个数字列表求最大值，不管其形状（shape = (2*3)）通过axis参数，可以指定沿数组的指定轴应用操作 b.sum(axis=0) # 每列求和 b.sum(axis=1) # 每行求和 b.cumsum(axis=1) # 沿着行累积和，相反沿着列累积和 另见 all, any, apply_along_axis, argmax, argmin, argsort, average, bincount, ceil, clip, conj, corrcoef, cov, cross, cumprod, cumsum, diff, dot, floor, inner, inv, lexsort, max, maximum, mean, median, min, minimum, nonzero, outer, prod, re, round, sort, std, sum, trace, transpose, var, vdot, vectorize, where all：是判断所以元素是否都为True，可以定义axis来沿着某个轴判断。 any：和all相反，判断是否有一个为Ture，是返回True，否返回False，可以传入axis 例如：b.any(0)，纵轴是否有为真的。 apply_along_axis(func, axis, arr)：将arr按照axis定义，行或者列取出作用在func上，并返回一个列表。 如果上述返回标量，则返回于源arr相同形状(shape)。比如传输sorted进行排序，返回还是列表。 argmax：查找最大值，返回索引，支持axis轴选择。如果多个大值，就返回第一次遇到的。 argmin：和max相反。 argsort：排序，返回排序完的索引值。可以选择算法。选择键排序。 mean：平均值，可以按轴进行。axis diff：计算差分，out[n] = a[n+1] - a[n]，可以按轴进行。 vdot：计算点积。 还有很多函数，先不看了。 索引、切片和迭代一维数组支持索引，切片和迭代，非常类似于列表和其他序列。 a[1:2]，其中**是次方，**(1/3) 求根号3 多维数组每个轴可以有一个索引。这些索引以逗号分隔的元组给出： 比如b[2,3]表示3行4列的元素，b[0:3, 1]表示行数是0,1,2的第2列，如果1数字缺失，则认为是全部列。如果维度大于3，比如维度（轴，rank）为5的情况，x[1,2,:,:,:]可以等效为x[1,2,…] x[1,2,…]等效于x[1,2,:,:,:] x[…,3]到x[:,:,:,:,3] x[4,…,5,:]到x[4,:,:,5,:]例子：y[1:5:2,::3]指的是1-4行间隔为2行，列数间隔为3进行抽取。避免迭代使用索引提高性能。可以使用一个数组来索引数组，提高的索引必须是索引值，比如a[np.array([1,2,3])] 索引a中的索引为1,2,3的元素。并且索引数组可以是多维的生成的矩阵维度和索引一致，a[np.array([[1,2], [3,4]])]，二维矩阵，1,2,3,4对应为a一维矩阵的索引。 Boolean型索引，比如&gt;&gt;&gt; y = np.arange(35).reshape(5,7)&gt;&gt;&gt; b = y &gt; 22&gt;&gt;&gt; y[b] # 这样就将y里边的大于22的数索引出来了，但是维度只有一维，并且如果索引的布尔数组和y具有相同的形状通常，当布尔数组具有比被索引的数组更少的维度时，这等同于y [b，…]，这意味着y被索引为b，然后是多个：如同填充y。因此，结果的形状是包含布尔数组的True元素的数目的一个维度，后面是被索引的数组的剩余维度。组合索引和切片，感觉就是行和列的索引，三维的话相当于两个数组，就分别对两个进行索引 y[1:3, 2:3] #类似的就是1-2行并且列是2列结构化索引工具&gt;&gt;&gt; y.shape(5, 7)&gt;&gt;&gt; y[:,np.newaxis,:].shape # np.newaxis 对象来新建一个维度&#39;(5, 1, 7)` 可以使用索引来改变相应位置的值y[2:7] = 1 #将2-6位置的数更改为1y[2:7] = np.arange(5) #或者直接使用数组的形式如果高类型分配给低类型的，会转型，损失精度，或者抛出错误下面的一个例子比较特殊：&gt;&gt;&gt; x = np.arange(0, 50, 10)&gt;&gt;&gt; xarray([ 0, 10, 20, 30, 40])&gt;&gt;&gt; x[np.array([1, 1, 3, 1])] += 1&gt;&gt;&gt; xarray([ 0, 11, 20, 31, 40])实际上我们认为1位置的数应该增加3才对，但是最终只增加1，其实是我们每次计算都采用了临时数组的方式，导致最终只增加1. Ellipsis 等同于 ‘…’ 元组不像列表索引那样会自动处理，如下例子：&gt;&gt;&gt; z[[1,1,1,1]] # produces a large arrayarray([[[[27, 28, 29],[30, 31, 32], ...&gt;&gt;&gt; z[(1,1,1,1)] # returns a single value40 多维数组迭代是相对于第一个轴进行的。 可以使用flat，是一个迭代器。如果使用x[0][2]会降低性能。因为2索引需要在前面0索引创建的数组上面继续操作。另见indexing。 形状操作 以下的命令不会修改数组，只会返回新的数组 ravel 返回连续的平坦的数组，降成一维 reshape 修改形状 T 转置修改数组本身 resize：对应的reshape是返回修改的数组将不同的数组堆叠 vstack hstack h v 分别对应水平方向和垂直方向。 column_stack row_stack column 和 row 分别对应，并且这两个方法允许1D的数组堆叠到2D数组中将数组分隔成几个小的数组 np.hsplit(a, 3) #将a划分为3个 h是水平 np.hsplit(a, (3, 4)) #将列为3-4但是不等于4的索引分隔开来 同理vsplit是垂直划分 array_split 可以指定某个轴进行划分 复制和视图 当计算和操作数组时，它们的数据有时被复制到新的数组中，有时不复制。这通常是初学者的混乱的来源。有三种情况： 完全不复制简单赋值不会创建数组对象或其数据的拷贝：如果将b = a 那么b和a指向的是同一个数组，改变b，a也跟着改变。可变对象传递到函数引用，函数不会复制。 视图或浅复制不同的数组对象可以共享相同的数据。view方法创建一个新数组对象，该对象看到相同的数据。c=a.view(), 这样改变c.shape = (2,6)，a的形状不会改变，但是如果c[0,4] = 1234，a的相应位置就会赋值为1234c.base is a = True对数组切片返回的也是视图 深复制d = a.copy()这样d就是一个新的数组 函数和方法概述 这里是一些有用的NumPy函数和方法名称按类别排序的列表。有关完整列表，请参见Routines。 数组创建arange, array, copy, empty, empty_like, eye, fromfile, fromfunction, identity, linspace, logspace, mgrid, ogrid, ones, ones_like, r, zeros, zeros_like 转换ndarray.astype，atleast_1d，atleast_2d，atleast_3d，mat 操纵array_split, column_stack, concatenate, diagonal, dsplit, dstack, hsplit, hstack, ndarray.item, newaxis, ravel, repeat, reshape, resize, squeeze, swapaxes, take, transpose, vsplit, vstack 问题all，any，nonzero，where 顺序argmax, argmin, argsort, max, min, ptp, searchsorted, sort 操作choose, compress, cumprod, cumsum, inner, ndarray.fill, imag, prod, put, putmask, real, sum 基本统计cov，mean，std，var基本线性代数cross，dot，outer，linalg.svd，vdot 其他基础广播规则 Broadcasting允许通用函数以有意义的方式处理具有不完全相同形状的输入。 Broadcasting的第一个规则是，如果所有输入数组不具有相同数量的维度，则“1”将被重复地添加到较小数组的形状，直到所有数组具有相同数量的维度。 Broadcasting的第二个规则确保沿着特定维度具有大小为1的数组表现得好像它们具有沿着该维度具有最大形状的数组的大小。假定数组元素的值沿“Broadcasting”数组的该维度相同。 花式索引技巧 NumPy提供了比常规Python序列更多的索引能力。除了通过整数和切片索引之外，如前所述，数组可以由整数数组和布尔数组索引。 使用索引数组索引a[j] j = np.array([1,1,3]) #得出索引a是1,1,3组成的数组如果索引的数组是多维的，结果与之对应，j = np.array([[1,2,3], [4, 5, 6]])，结果是形状是(2, 3) 可以对每个维度进行单独索引i = np.array([[0,1], [1, 2]])j = np.array([[2,1], [1, 3]])a[i, j]同样的 l=[i,j] a[l]=a[i,j] 函数 np.ix_[a,b,c] ???雨里雾里np.ufunc.reduce ???云里雾里 线性代数 基础 简单的数组操作 a.transpose() # 矩阵转置 np.linalg.inv(a) # 逆矩阵 np.eye(2) # 2*2的矩阵，返回对角线是1其他都是0的矩阵 np.dot(i, j) # 求矩阵乘积 np.trace(a) # 对a矩阵的对角线值求和 np.linalg.solve(a, y) # 解线性方程组 a矩阵对应参数，y对应等于后边的数 np.linalg.eig(j) # 特征向量，线性代数当时没有学好","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Numpy","slug":"Numpy","permalink":"http://yoursite.com/tags/Numpy/"}]},{"title":"What is Numpy","slug":"python/numpy/01_what_is_numpy","date":"2017-11-16T12:00:30.500Z","updated":"2017-11-16T12:15:45.588Z","comments":true,"path":"2017/11/16/python/numpy/01_what_is_numpy/","link":"","permalink":"http://yoursite.com/2017/11/16/python/numpy/01_what_is_numpy/","excerpt":"","text":"What is Numpy Numpy是Python科学计算的基本包，提供对于多维数组（矩阵）等各种计算，比如c = a * b，a、b均为矩阵，可以对其进行直接计算，不用使用循环遍历。本机测试计算速度为for循环遍历计算的500+倍。例子如下：目前找不到源网页，直接粘上例子。 123456789101112131415161718import numpy as np import time#from timeit import timeita = np.random.rand(1000000)b = np.random.rand(1000000)time_s = time.time()c = np.dot(a, b)time_e = time.time()print(c, 1000*(time_e - time_s))c = 0time_s = time.time()for i in range(len(a)): c += a[i] * b[i]time_e = time.time()print(c, 1000*(time_e - time_s)) 下图所示 矢量化(Vectorization) 上面的例子是矢量化的例子（Vectorization），包含以下优点： 代码更简洁 更少的代码通常意味着更少的错误 代码运行更接近标准的数学符号，封装了具体的困难的运算，如上np.dot(a, b)直接计算两个矩阵的积。 矢量化导致更多的“Pythonic”(网络解释为很Python的Python代码)代码。如果没有向量化，我们的代码将会效率很低，难以读取for循环。 广播(Broadcasting) 广播是用于描述操作的隐式逐个元素行为的术语大概意思就是比如做矩阵的运算，a为一维矩阵，b为标量，如果做计算a + b，会自动的将a的元素都加上b（我的简单理解） 源网站 Numpy 中文 API","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Learn Numpy","slug":"Learn-Numpy","permalink":"http://yoursite.com/tags/Learn-Numpy/"}]},{"title":"使用 git rm --cached filename 删除提交的文件","slug":"git/git_rm_use_cached","date":"2017-11-05T12:26:57.178Z","updated":"2017-11-05T12:27:20.847Z","comments":true,"path":"2017/11/05/git/git_rm_use_cached/","link":"","permalink":"http://yoursite.com/2017/11/05/git/git_rm_use_cached/","excerpt":"","text":"目的为了测试Markdown书写 本人在学习 git 的时候，前期将本地的日志文件提交到仓库，然后也就查找了相关的操作方法，最终使用此命令解决的，然后新增.gitignore文件，提交，再次使用git status这些文件就不会再次出现了，其他情况也可以使用这个方法：将数据库账号密码配置文件从远端仓库删除。 git rmgit rm Filename or Foldername： 使用在当我们提交了一个不想提交的文件，可以使用其删除本地工作目录的文件，一般我们可能需要保留源文件，所以可以使用：--cached参数来实现只删除索引（官方：Index，跟踪的文件清单）。 git rm –cached Filename or Foldername： 使用 --cached 将会保留本地文件，只删除暂存区的文件，提交这次修改，该文件就不会纳入版本管理了，远端的仓库也会同步这个修改，达到删除文件目的。 常用参数： -n or --dry-run 加上这个参数是不会做任何删除操作的，只是将符合filename删除的文件预览打印出来，准确的说加上这个参数会打印此操作产生影响（删除）的文件列表。 git rm -n --cached txt/\\\\*.txt #将会列出txt目录下的符合拓展名字为.txt的文件，反斜杠\\为转义字符。 -f 这个参数是强制执行的意思，如果我们已经将文件提交到暂存区，这个时候需要加上这个参数。 -r 类似bash命令就是递归删除了，如果删除目录使用此参数。 官网相关页面： git-rm","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git rm 删除 文件","slug":"git-rm-删除-文件","permalink":"http://yoursite.com/tags/git-rm-删除-文件/"}]}]}