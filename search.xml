<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[threading.Event实现等待输入，打印输入并自动退出程序]]></title>
      <url>/2018/08/27/python/questions/Thread/sleep_and_waiting_input_any/sleep_and_waiting_input/</url>
      <content type="html"><![CDATA[<h1 id="线程等待输入，打印输入并自动退出程序，超时自动退出"><a href="#线程等待输入，打印输入并自动退出程序，超时自动退出" class="headerlink" title="线程等待输入，打印输入并自动退出程序，超时自动退出"></a>线程等待输入，打印输入并自动退出程序，超时自动退出</h1><hr>
<blockquote>
<ul>
<li>问题：实现一个多线程程序，等待输入，计时3秒钟，检查输入就打印输入退出程序，如果超时未输入也退出程序。</li>
</ul>
</blockquote>
<h2 id="最好的实现如下："><a href="#最好的实现如下：" class="headerlink" title="最好的实现如下："></a>最好的实现如下：</h2><hr>
<pre><code>import threading

# @func 输入打印函数
# @params t 超时时间 event 线程事件对象，用于协调线程
def print_input(t, event):
    s = input(&#39;请在%ss内输入您想要输入的字符串：&#39; % t)
    print(&#39;您的输入是：%s&#39; % s)
    event.set() # 设置标志为True api说的是将唤醒所有的线程


# @func 超时函数
# @params t 超时时间 event 线程事件对象，用于协调线程
def my_sleep(t, event):
    event.wait(timeout=t) # 等待超时时间，但是如果调用set之后，该函数立即返回并结束


sleep_time = 3
event = threading.Event()
sleep = threading.Thread(target=my_sleep, args=(sleep_time, event))
input_str = threading.Thread(target=print_input, args=(sleep_time, event))
input_str.daemon = True
input_str.start()
sleep.start()
</code></pre><blockquote>
<ul>
<li>说明：新建两个线程，其中一个为线程事件，完成等待相应的时间，另外的线程是<code>print_input</code>方法，由于<code>input</code>会导致阻塞，然后新建线程设置<code>deamon</code>为<code>True</code>，主线程结束的时候<code>input</code>阻塞线程也结束，从而实现超时结束，其中<code>event</code>的<code>wait</code>为等待，参数是超时时间，当<code>input</code>线程完成运行<code>event.set()</code>，这个方法设置一个<code>flag</code>为<code>True</code>，会唤醒其它线程，并使得<code>wait</code>函数直接返回结束，那么：</li>
<li>1、当有输入的时候，<code>input</code>不阻塞，然后运行<code>event.set()</code>，<code>event.wait()</code>直接返回，结束超时检查，最终结束程序；</li>
<li>2、当没有输入的时候，<code>event.set()</code>由于<code>input</code>阻塞不会运行，程序直到指定等待时间完成之后，<code>sleep</code>线程结束，主线程结束，由于而<code>input</code>由于<code>daemon</code>设置随之结束，不再阻塞。</li>
</ul>
</blockquote>
<pre><code>import time
import sys
import threading
from queue import Queue

q = Queue()
global_s = None


# @func 获取输入的子线程方法
def set_input():
    global global_s
    global_s = input(&#39;3秒钟无任何输入自动退出：&#39;)


# @func 检查输入，并检查超时函数
# @params q Queue消息队列
def get_input(q):
    thread = threading.Thread(target=set_input) # 新建输入线程
    thread.start()
    thread.join()
    while True:
        que_str = q.get()

        if global_s:
            q.put(&#39;Exit&#39;)
            print(&#39;您输入了：%s&#39; % global_s)
            sys.exit(0)

        q.put(&#39;Con&#39;)
        if que_str == &#39;Exit&#39;:
            sys.exit(0) # 正常退出


# @func 睡眠，完成超时判断
# @params t 时间 q Queue队列对象
def my_sleep(t, q): 
    for i in range(1, t + 1):
        q.put(&#39;Sleep&#39;)
        time.sleep(1)

        que_str = q.get()

        if que_str == &#39;Exit&#39;:
            sys.exit(0) # 正常退出

    q.put(&#39;Exit&#39;)


wait_thread = threading.Thread(target=my_sleep, args=(3,q))
input_thread = threading.Thread(target=get_input, args=(q,))
input_thread.daemon = True
input_thread.start()
wait_thread.start()
</code></pre><blockquote>
<ul>
<li>说明：这个属于自己靠着自己了解通过<code>Queue</code>实现的一个不完美的方案，首先了解到<code>input</code>是阻塞的，所以想到了在新建一个线程来获取输入并阻塞在那里<code>set_input</code>，<code>get_input</code>和<code>my_sleep</code>完成<code>Queue</code>交互来实现目标的功能，主要流程：</li>
<li>1 <code>set_input</code>线程里边新建一个线程，完成阻塞的<code>input</code>方法等待输入；</li>
<li>2 随后和<code>my_sleep</code>进行数据交换，首先从队列里边<code>put</code>一个<code>Sleep</code>字符串，<code>get_input</code>判断全局变量<code>global_s</code>是否存在数据，存在数据就直接<code>put</code>一个<code>Exit</code>字符串，以告知<code>my_sleep</code>结束（这点就是导致程序在字符串输入之后也会暂停一秒猜结束的原因，而<code>my_sleep</code>里边的<code>time.sleep(1)</code>也必须在当前位置，否则会导致自己<code>put</code>的’Sleep’字符串被自己的<code>q.get()</code>给获取到，导致无法结束，这点可能可以通过两个<code>Queue</code>对象来解决，本地暂时未实现）</li>
<li>3 如果全局变量<code>global_s</code>为空，然后<code>get_input</code>里边<code>if que_str == &#39;Exit&#39;</code>判断队列读取的不是<code>Exit</code>就继续取得下一个队列的数据。</li>
<li>4 这样直到<code>my_sleep</code>里边的<code>for</code>循环结束，然后就会在队列里边写<code>Exit</code>，然后<code>get_input</code>读取到就退出，相应的<code>join</code>阻塞读取输入的线程也结束。</li>
</ul>
</blockquote>
<hr>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><blockquote>
<ul>
<li>看到该问题，首先想到的就是在其它线程里边有没有结束当前线程的操作，后续问题提出的朋友给出解决方案，发现<code>threading.Event</code>也大致是这样的，并且后者实现更加友好。</li>
</ul>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Python Question </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python Thread Event 线程事件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Pandas如何去除nan值占百分比大于90的列]]></title>
      <url>/2018/04/29/python/questions/Pandas/Pandas_drop_col_nan_percentage/</url>
      <content type="html"><![CDATA[<h1 id="Pandas如何去除nan值占百分比大于90的列"><a href="#Pandas如何去除nan值占百分比大于90的列" class="headerlink" title="Pandas如何去除nan值占百分比大于90的列"></a>Pandas如何去除<code>nan</code>值占百分比大于90的列</h1><hr>
<blockquote>
<ul>
<li>前不久看见有人问如何使用<code>Pandas</code>去除一列中的<code>nan</code>值大于90%的列，然后贴出了未实现的代码，刚刚接触到<code>Pandas</code>，于是比较有兴趣，便复制代码，自己实现了一下。</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ul>
<li>原问题：<br>请教一个问题：我想把DataFrame中按列读取时缺失值在90%以上的列全部删除，运行后程序没有出错，但是找不到输出文件，我把网上找来的代码改了一下，如下：</li>
</ul>
</blockquote>
<pre><code>import pandas as pd
data_file = r&#39;E:\\123.csv&#39;
df = pd.read_csv(data_file)
def drop_col(df, cutoff=0.1): # 如果这一列中有90%以上的缺失值，那么就从df中删除这一列
    n = len(df)
    cnt = df.count()
    if (float(cnt) / n) &lt; cutoff:
        df.drop(axis=1, inplace=1).to_csv(r&#39;E:\\aaa.csv&#39;)
</code></pre><blockquote>
<ul>
<li>如上代码，首先通过<code>csv</code>读取文件，这个方法问题挺多的，首先代码都没有调用drop_col方法，这样运行完全没有问题，但是完全没有用，本地首先想到的是方法未调用的问题，然后就调用呗，我本地修改的代码不是读取<code>csv</code>，所以下面粘贴我本地的代码：</li>
</ul>
</blockquote>
<pre><code>import numpy as np
import pandas as pd

df = pd.DataFrame({1:[1]*8+[np.nan]*2, 2:[2]*10, 3:[np.nan]*9+[3], 4:[4]*10})

def drop_col(df, cutoff=0.1): # 如果这一列中有90%以上的缺失值，那么就从df中删除这一列
    n = len(df)
    cnt = df.count()
    if (float(cnt) / n) &lt; cutoff:
        return df.drop(axis=1, inplace=1)
df = drop_col(df)
print(df)
</code></pre><blockquote>
<ul>
<li>运行，出错。</li>
</ul>
</blockquote>
<pre><code>Traceback (most recent call last):
  File &quot;tt.py&quot;, line 22, in &lt;module&gt;
    df = drop_col(df)
  File &quot;tt.py&quot;, line 20, in drop_col
    if (float(cnt) / n) &lt; cutoff:
  File &quot;C:\Users\liukaijiang\AppData\Roaming\Python\Python36\site-packages\panda
s\core\series.py&quot;, line 112, in wrapper
    &quot;{0}&quot;.format(str(converter)))
TypeError: cannot convert the series to &lt;class &#39;float&#39;&gt;
</code></pre><blockquote>
<ul>
<li>然后经过一番思考，并修改程序并完成功能。（其中第一版本无法得到所有的满足要求的列）</li>
</ul>
</blockquote>
<pre><code>import numpy as np
import pandas as pd

df = pd.DataFrame({1:[1]*9+[np.nan]*2, 2:[2]*11, 3:[np.nan]*11, 4:[4]*11, 5:[np.nan]*10+[5]}) # 一个包含两列nan值占比大于90%的
print(df)

def drop_col(df, cutoff=0.1): # 如果这一列中有90%以上的缺失值，那么就从df中删除这一列
    n = len(df)
    cnt = df.count() # 对列进行非nan值计数
    cnt = cnt / n # 求出非nan值的百分比

    return df.loc[:, cnt[cnt &gt;= cutoff].index] # 根据cnt记录的百分比，过滤出cnt百分百大于等于0.1的（也就是去掉nan值大于0.9的索引），然后对df进行选择，行所有，列为满足要求的cnt的索引。

df = drop_col(df)
print(df)
</code></pre><blockquote>
<ul>
<li>结果显示如下，注意第3（<code>nan</code>值100%）、5（<code>nan</code>值90.9%）列均被选择过滤掉。</li>
</ul>
</blockquote>
<pre><code>&gt;&gt;&gt; df
      1  2   3  4    5
0   1.0  2 NaN  4  NaN
1   1.0  2 NaN  4  NaN
2   1.0  2 NaN  4  NaN
3   1.0  2 NaN  4  NaN
4   1.0  2 NaN  4  NaN
5   1.0  2 NaN  4  NaN
6   1.0  2 NaN  4  NaN
7   1.0  2 NaN  4  NaN
8   1.0  2 NaN  4  NaN
9   NaN  2 NaN  4  NaN
10  NaN  2 NaN  4  5.0
&gt;&gt;&gt; drop_col(df)
      1  2  4
0   1.0  2  4
1   1.0  2  4
2   1.0  2  4
3   1.0  2  4
4   1.0  2  4
5   1.0  2  4
6   1.0  2  4
7   1.0  2  4
8   1.0  2  4
9   NaN  2  4
10  NaN  2  4
</code></pre><h1 id="完"><a href="#完" class="headerlink" title="完"></a>完</h1>]]></content>
      
        <categories>
            
            <category> Python Question </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习 python Pandas filter </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[学习gRPC模块]]></title>
      <url>/2018/03/31/python/gRPC/learn_gRPC/</url>
      <content type="html"><![CDATA[<h1 id="gRPC学习笔记"><a href="#gRPC学习笔记" class="headerlink" title="gRPC学习笔记"></a>gRPC学习笔记</h1><hr>
<blockquote>
<p>学习来源 <a href="http://doc.oschina.net/grpc?t=56831" target="_blank" rel="external">开源中国</a></p>
</blockquote>
<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><blockquote>
<ul>
<li><code>gRPC</code>是一个高性能、开源和通用的RPC框架</li>
<li>面向移动和<code>HTTP/2</code>设计</li>
<li>提供跨平台、跨语言（支持多语言）支持</li>
<li><code>gRPC</code>基于<code>HTTP/2</code>标准设计，带来双向流、流控、头部压缩、单TCP连接上的多复用请求（连接复用吧）等等，使其在移动设备上表现更好，更省电和节省空间占用。</li>
</ul>
</blockquote>
<hr>
<h2 id="2、概述"><a href="#2、概述" class="headerlink" title="2、概述"></a>2、概述</h2><blockquote>
<ul>
<li><code>gRPC</code>是语言中立、平台中立、开源的远程过程调用（<code>RPC</code>）系统（比如可以用<code>Java</code>创建服务器，而用<code>Python</code>创建客户端）。<h3 id="2-1、gRPC是什么"><a href="#2-1、gRPC是什么" class="headerlink" title="2.1、gRPC是什么"></a>2.1、gRPC是什么</h3></li>
<li>与许多 <code>RPC</code> 系统类似，<code>gRPC</code> 也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 <code>gRPC</code> 服务器来处理客户端调用。在客户端拥有一个存根能够像服务端一样的方法。</li>
<li>使得我们可以更容易的创建分布式应用和服务<h3 id="2-2、使用protocol-buffers"><a href="#2-2、使用protocol-buffers" class="headerlink" title="2.2、使用protocol buffers"></a>2.2、使用protocol buffers</h3></li>
<li>是一个Google开源的成熟的结构数据序列化机制（如同<code>JSON</code>、<code>XML</code>）。</li>
<li><a href="http://blog.csdn.net/shensky711/article/details/69696392" target="_blank" rel="external">protocol buffers手册</a></li>
</ul>
</blockquote>
<hr>
<h2 id="3、Hello-gRPC！"><a href="#3、Hello-gRPC！" class="headerlink" title="3、Hello gRPC！"></a>3、Hello gRPC！</h2><blockquote>
<ul>
<li>创建一个官方支持，并是自己熟悉的语言的<code>RPC</code>服务（Hello World），在官方的Github上都存在相应的例子。</li>
<li>准备工作：本机有<code>Git</code>，然后clone需要的版本的源码。</li>
</ul>
</blockquote>
<h3 id="3-1、定义服务"><a href="#3-1、定义服务" class="headerlink" title="3.1、定义服务"></a>3.1、定义服务</h3><blockquote>
<ul>
<li>创建一个例子的第一步是定义一个服务（感觉就是<code>protocol buffers</code>的配置文件）：一个RPC服务通过参数和返回类型来指定可以远程调用的方法。</li>
<li><code>gRPC</code>通过<code>protocol buffers</code>来实现这个功能。</li>
<li>下面将使用<code>protocol buffers</code>接口定义语言来定义服务，使用该协议来定义参数和返回类型。客户端和服务器均使用服务定义生成的接口代码。</li>
</ul>
</blockquote>
<pre><code>syntax = &quot;proto3&quot;;

option java_package = &quot;io.grpc.examples&quot;;

package helloworld;

// The greeter service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user&#39;s name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}
</code></pre><h3 id="3-2、生成gRPC代码"><a href="#3-2、生成gRPC代码" class="headerlink" title="3.2、生成gRPC代码"></a>3.2、生成gRPC代码</h3><blockquote>
<ul>
<li>定义好服务之后，就可以使用<code>protocol buffers</code>编译器<code>protoc</code>来创建应用所需的特定客户端和服务器的代码。生成代码的同时包括客户端的存根和服务端要实现的抽象接口，均包含<code>Greeter</code>所定义的方法。</li>
<li><p>可以使用如下命令生成客户端和服务器端：<br><code>./run_codegen.sh # shell只能在支持shell的平台</code></p>
</li>
<li><p>Python编译语法如下，需要安装<code>grpcio-tools</code>，使用<code>pip install grpcio-tools</code>安装，这里边包含编译的工具。</p>
</li>
</ul>
</blockquote>
<p><code>python -m grpc_tools.protoc -I../protos --python_out=. --grpc_python_out=. ../protos/helloworld.proto</code></p>
<blockquote>
<ul>
<li>其中 <code>-I</code>：为自定的proto文件目录，是一个目录，那么如果我们在这个文件的目录，就选择上级目录，然后定位到protos目录</li>
<li><code>--python_out</code> &amp; <code>--grpc_python_out</code>：明显是根据<code>proto</code>文件生成的<code>python</code>文件，包含两个文件，暂时不知道具体用处，只知道是有一个是将<code>proto</code>文件定义的<code>rpc</code>绑定到相应的东西上，另外一个相当于做了一个抽象类，里边有<code>proto</code>定义的两个调用的抽象方法，服务器需要实现的方法。</li>
<li>最后的是指定需要编译的<code>proto</code>文件，和前面的<code>-I</code>为组合，试了一下去掉<code>-I</code>参数反之在proto文件上加上相对路径，结果无法编译。</li>
<li>编译好之后，按照官方的服务器和客户端代码，在服务器上实现更新的方法，做相应处理，然后返回，在客户端调用即可。</li>
<li>备注：服务器和客户端必须携带生成的两个代码，这样有点类似分布式实现的Queue了。</li>
</ul>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习 python gRPC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[学习10分钟入门Pandas模块]]></title>
      <url>/2018/03/31/python/10_minutes_to_pandas_note/10_minutes_to_pandas_note/</url>
      <content type="html"><![CDATA[<h1 id="10分钟入门Pandas笔记"><a href="#10分钟入门Pandas笔记" class="headerlink" title="10分钟入门Pandas笔记"></a>10分钟入门Pandas笔记</h1><blockquote>
<ul>
<li>引用原文：<a href="https://www.cnblogs.com/chaosimple/p/4153083.html" target="_blank" rel="external">10分钟入门Pandas</a></li>
</ul>
</blockquote>
<hr>
<h2 id="主要引用的包"><a href="#主要引用的包" class="headerlink" title="主要引用的包"></a>主要引用的包</h2><pre><code>import pandas as pd # pandas库
import numpy as np # numpy库 科学计算，矩阵。
import matplotlib.pyplot as plt # 可视化 画图
</code></pre><h2 id="一、创建对象"><a href="#一、创建对象" class="headerlink" title="一、创建对象"></a>一、创建对象</h2><blockquote>
<ul>
<li>可以通过<a href="http://pandas.pydata.org/pandas-docs/stable/dsintro.html#dsintro" target="_blank" rel="external">Data Structure Introduction Setion</a>了解有关本节内容的详细信息。</li>
</ul>
<h3 id="1、可以通过传递一个list对象来创建一个Series，Pandas会默认创建整型索引："><a href="#1、可以通过传递一个list对象来创建一个Series，Pandas会默认创建整型索引：" class="headerlink" title="1、可以通过传递一个list对象来创建一个Series，Pandas会默认创建整型索引："></a>1、可以通过传递一个list对象来创建一个Series，Pandas会默认创建整型索引：</h3><pre><code>&gt;&gt; s = pd.Series([1,3,5,np.nan,6,8])
&gt;&gt; s
0    1.0
1    3.0
2    5.0
3    NaN
4    6.0
5    8.0
dtype: float64
</code></pre><h3 id="2、通过传递一个numpy-array，时间索引以及列标签来创建一个DataFrame："><a href="#2、通过传递一个numpy-array，时间索引以及列标签来创建一个DataFrame：" class="headerlink" title="2、通过传递一个numpy array，时间索引以及列标签来创建一个DataFrame："></a>2、通过传递一个numpy array，时间索引以及列标签来创建一个DataFrame：</h3><pre><code>&gt;&gt; dates = pd.date_range(&#39;20180329&#39;, periods=6)
&gt;&gt; dates
DatetimeIndex([&#39;2018-03-29&#39;, &#39;2018-03-30&#39;, &#39;2018-03-31&#39;, &#39;2018-04-01&#39;,
               &#39;2018-04-02&#39;, &#39;2018-04-03&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)
&gt;&gt; df = pd.DataFrame(np.random.randn(6,4), index=dates, columns=list(&#39;ABCD&#39;))
&gt;&gt; df
                   A         B         C         D
2018-03-29  0.916819  0.146020  0.072409 -0.596416
2018-03-30  2.401470 -1.407265 -0.579490  1.653233
2018-03-31  0.415780  0.065466 -1.239546 -0.828074
2018-04-01 -1.917880 -0.470291 -1.102185  0.233711
2018-04-02  0.504557 -2.568238 -0.411014 -0.524040
2018-04-03  0.797517 -1.459728  1.254905 -0.083599
</code></pre><h3 id="3、通过传递一个能够被转换成类似序列结果的字典对象来创建一个DataFrame："><a href="#3、通过传递一个能够被转换成类似序列结果的字典对象来创建一个DataFrame：" class="headerlink" title="3、通过传递一个能够被转换成类似序列结果的字典对象来创建一个DataFrame："></a>3、通过传递一个能够被转换成类似序列结果的字典对象来创建一个DataFrame：</h3><pre><code>&gt;&gt; df = pd.DataFrame(
{&#39;A&#39;:1, 
 &#39;B&#39;:pd.Timestamp(&#39;20180329&#39;),
 &#39;C&#39;:pd.Series(1, index=list(range(4))),
 &#39;D&#39;:np.array([3]*4, dtype=&#39;int32&#39;),
 &#39;E&#39;:pd.Categorical([&#39;test&#39;, &#39;train&#39;, &#39;test&#39;, &#39;train&#39;]),
 &#39;F&#39;:&#39;foo&#39;})
&gt;&gt; df
   A          B  C  D      E    F
0  1 2018-03-29  1  3   test  foo
1  1 2018-03-29  1  3  train  foo
2  1 2018-03-29  1  3   test  foo
3  1 2018-03-29  1  3  train  foo
</code></pre><h3 id="4、查看不同列的数据类型"><a href="#4、查看不同列的数据类型" class="headerlink" title="4、查看不同列的数据类型"></a>4、查看不同列的数据类型</h3><ul>
<li><code>df.dtypes</code><pre><code>&gt;&gt; df.dtypes
A             int64
B    datetime64[ns]
C             int64
D             int64
E          category
F            object
dtype: object
</code></pre></li>
</ul>
<h3 id="5、如果使用的是IPython，使用Tab自动补全功能会自动识别所有的数学以及自定义的列。"><a href="#5、如果使用的是IPython，使用Tab自动补全功能会自动识别所有的数学以及自定义的列。" class="headerlink" title="5、如果使用的是IPython，使用Tab自动补全功能会自动识别所有的数学以及自定义的列。"></a>5、如果使用的是<code>IPython</code>，使用<code>Tab</code>自动补全功能会自动识别所有的数学以及自定义的列。</h3></blockquote>
<hr>
<blockquote>
<h2 id="二、查看数据"><a href="#二、查看数据" class="headerlink" title="二、查看数据"></a>二、查看数据</h2><ul>
<li>详情请参阅：<a href="http://pandas.pydata.org/pandas-docs/stable/basics.html#basics" target="_blank" rel="external">Basics Section</a><h3 id="1、查看frame中头部和尾部的行"><a href="#1、查看frame中头部和尾部的行" class="headerlink" title="1、查看frame中头部和尾部的行"></a>1、查看frame中头部和尾部的行</h3><pre><code>&gt;&gt; df
 A          B  C  D      E    F
0  1 2018-03-29  1  3   test  foo
1  1 2018-03-29  1  3  train  foo
2  1 2018-03-29  1  3   test  foo
3  1 2018-03-29  1  3  train  foo
&gt;&gt; df.head(2)
 A          B  C  D      E    F
0  1 2018-03-29  1  3   test  foo
1  1 2018-03-29  1  3  train  foo
&gt;&gt; df.tail(2)
 A          B  C  D      E    F
2  1 2018-03-29  1  3   test  foo
3  1 2018-03-29  1  3  train  foo
</code></pre><h3 id="2、查看索引、列和底层的numpy数据："><a href="#2、查看索引、列和底层的numpy数据：" class="headerlink" title="2、查看索引、列和底层的numpy数据："></a>2、查看索引、列和底层的numpy数据：</h3><pre><code>&gt;&gt; df
 A          B  C  D      E    F
0  1 2018-03-29  1  3   test  foo
1  1 2018-03-29  1  3  train  foo
2  1 2018-03-29  1  3   test  foo
3  1 2018-03-29  1  3  train  foo
&gt;&gt; df.index
Int64Index([0, 1, 2, 3], dtype=&#39;int64&#39;)
&gt;&gt; df.columns
Index([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;], dtype=&#39;object&#39;)
&gt;&gt; df.values
array([[1, Timestamp(&#39;2018-03-29 00:00:00&#39;), 1, 3, &#39;test&#39;, &#39;foo&#39;],
     [1, Timestamp(&#39;2018-03-29 00:00:00&#39;), 1, 3, &#39;train&#39;, &#39;foo&#39;],
     [1, Timestamp(&#39;2018-03-29 00:00:00&#39;), 1, 3, &#39;test&#39;, &#39;foo&#39;],
     [1, Timestamp(&#39;2018-03-29 00:00:00&#39;), 1, 3, &#39;train&#39;, &#39;foo&#39;]], dtype=objec
t)
</code></pre></li>
</ul>
<h3 id="3、使用describe-对数据进行快速统计汇总："><a href="#3、使用describe-对数据进行快速统计汇总：" class="headerlink" title="3、使用describe()对数据进行快速统计汇总："></a>3、使用<code>describe()</code>对数据进行快速统计汇总：</h3><pre><code>&gt;&gt; df.describe()
         A    C    D
count  4.0  4.0  4.0
mean   1.0  1.0  3.0
std    0.0  0.0  0.0
min    1.0  1.0  3.0
25%    1.0  1.0  3.0
50%    1.0  1.0  3.0
75%    1.0  1.0  3.0
max    1.0  1.0  3.0
&gt;&gt; df
   A          B  C  D      E    F
0  1 2018-03-29  1  3   test  foo
1  1 2018-03-29  1  3  train  foo
2  1 2018-03-29  1  3   test  foo
3  1 2018-03-29  1  3  train  foo
&gt;&gt;
</code></pre><h3 id="4、对数据进行转置操作"><a href="#4、对数据进行转置操作" class="headerlink" title="4、对数据进行转置操作"></a>4、对数据进行转置操作</h3><p>```</p>
<blockquote>
<blockquote>
<p>df.T<br>                     0                    1                    2  \<br>A                    1                    1                    1<br>B  2018-03-29 00:00:00  2018-03-29 00:00:00  2018-03-29 00:00:00<br>C                    1                    1                    1<br>D                    3                    3                    3<br>E                 test                train                 test<br>F                  foo                  foo                  foo</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code>                 3
</code></pre><p>A                    1<br>B  2018-03-29 00:00:00<br>C                    1<br>D                    3<br>E                train<br>F                  foo</p>
<pre><code>
&gt; ### 5、按轴进行排序：横轴纵轴是什么？？
</code></pre><blockquote>
<blockquote>
<blockquote>
<p>df.sort_index(axis=1, ascending=False) # axis = 0 就是列了<br>                   D         C         B         A<br>2018-03-29  0.621323  0.232728 -0.245439  1.887637<br>2018-03-30 -0.687133  0.794514  0.462420 -2.270712<br>2018-03-31 -1.453160 -0.512256  0.554050 -1.068204<br>2018-04-01 -1.947354  1.232493  0.656760  0.430766<br>2018-04-02  0.745403  0.529783  0.390616 -0.349892<br>2018-04-03 -0.332525  0.146019 -0.361226 -0.666926<br>```</p>
</blockquote>
</blockquote>
<h3 id="6、按值进行排序："><a href="#6、按值进行排序：" class="headerlink" title="6、按值进行排序："></a>6、按值进行排序：</h3><pre><code>&gt;&gt; df.sort_values(&#39;B&#39;)
                   A         B         C         D
2018-04-03 -0.666926 -0.361226  0.146019 -0.332525
2018-03-29  1.887637 -0.245439  0.232728  0.621323
2018-04-02 -0.349892  0.390616  0.529783  0.745403
2018-03-30 -2.270712  0.462420  0.794514 -0.687133
2018-03-31 -1.068204  0.554050 -0.512256 -1.453160
2018-04-01  0.430766  0.656760  1.232493 -1.947354
&gt;&gt; df
                   A         B         C         D
2018-03-29  1.887637 -0.245439  0.232728  0.621323
2018-03-30 -2.270712  0.462420  0.794514 -0.687133
2018-03-31 -1.068204  0.554050 -0.512256 -1.453160
2018-04-01  0.430766  0.656760  1.232493 -1.947354
2018-04-02 -0.349892  0.390616  0.529783  0.745403
2018-04-03 -0.666926 -0.361226  0.146019 -0.332525
</code></pre></blockquote>
<hr>
<blockquote>
<h2 id="三、选择"><a href="#三、选择" class="headerlink" title="三、选择"></a>三、选择</h2><ul>
<li>虽然标准的Python/Numpy的选择和设置表达式都能够直接派上用场，但是作为工程使用的代码，我们推荐使用经过优化的pandas数据访问方式： .at, .iat, .loc, .iloc 和 .ix详情请参阅<a href="http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing" target="_blank" rel="external">Indexing and Selecing Data</a> 和 <a href="http://pandas.pydata.org/pandas-docs/stable/advanced.html#advanced" target="_blank" rel="external">MultiIndex / Advanced Indexing</a>。</li>
</ul>
<h3 id="1、获取："><a href="#1、获取：" class="headerlink" title="1、获取："></a>1、获取：</h3><ul>
<li><code>df[&#39;A&#39;]</code>选择一个单独的列，这将会返回一个<code>Series</code>，等同于<code>df.A</code><pre><code>&gt;&gt; df[&#39;A&#39;]
2018-03-29    1.887637
2018-03-30   -2.270712
2018-03-31   -1.068204
2018-04-01    0.430766
2018-04-02   -0.349892
2018-04-03   -0.666926
Freq: D, Name: A, dtype: float64
</code></pre></li>
<li>通过[]进行选择，这将会对行进行切片：<pre><code>&gt;&gt; df[&#39;20180329&#39;:&#39;20180331&#39;]
                 A         B         C         D
2018-03-29  1.887637 -0.245439  0.232728  0.621323
2018-03-30 -2.270712  0.462420  0.794514 -0.687133
2018-03-31 -1.068204  0.554050 -0.512256 -1.453160
&gt;&gt; df[0:3]
                 A         B         C         D
2018-03-29  1.887637 -0.245439  0.232728  0.621323
2018-03-30 -2.270712  0.462420  0.794514 -0.687133
2018-03-31 -1.068204  0.554050 -0.512256 -1.453160
</code></pre></li>
</ul>
<h3 id="2、通过标签选择"><a href="#2、通过标签选择" class="headerlink" title="2、通过标签选择"></a>2、通过标签选择</h3><ul>
<li>使用标签来获取一个交叉的区域：<pre><code>&gt;&gt; df.loc[dates[0]]
A    1.887637
B   -0.245439
C    0.232728
D    0.621323
Name: 2018-03-29 00:00:00, dtype: float64
&gt;&gt; df.loc[&#39;20180329&#39;]
A    1.887637
B   -0.245439
C    0.232728
D    0.621323
Name: 2018-03-29 00:00:00, dtype: float64
</code></pre></li>
<li>通过标签来在多个轴上进行选择：<pre><code>&gt;&gt; df.loc[:, [&#39;A&#39;,&#39;C&#39;]]
                 A         C
2018-03-29  1.887637  0.232728
2018-03-30 -2.270712  0.794514
2018-03-31 -1.068204 -0.512256
2018-04-01  0.430766  1.232493
2018-04-02 -0.349892  0.529783
2018-04-03 -0.666926  0.146019
</code></pre></li>
<li>标签切片</li>
</ul>
</blockquote>
<pre><code>&gt;&gt;&gt; df.loc[&#39;20180412&#39;:&#39;20180413&#39;, [&#39;A&#39;, &#39;C&#39;]]
            A  C
2018-04-12  1  1
2018-04-13  1  1
</code></pre><blockquote>
<ul>
<li><p>对返回的对象进行维度缩减，类似在二维数组中保存一维数组，最终取出一维数组。</p>
<pre><code>&gt;&gt; df.loc[&#39;20180411&#39;, [&#39;A&#39;,&#39;D&#39;]]
A    1
D    3
Name: 2018-04-11 00:00:00, dtype: object
</code></pre></li>
<li><p>获取标量，进一步维度缩减吧。</p>
<pre><code>&gt;&gt; df.loc[&#39;20180411&#39;, &#39;E&#39;]
&#39;test&#39;
</code></pre></li>
<li><p>快速访问一个标量，和上方法相同</p>
<pre><code>&gt;&gt; df.at[&#39;20180411&#39;, &#39;E&#39;]
&#39;test&#39;
</code></pre></li>
</ul>
<h3 id="3、通过位置选择"><a href="#3、通过位置选择" class="headerlink" title="3、通过位置选择"></a>3、通过位置选择</h3><ul>
<li><p>通过传递数值进行位置选择（选择的是行）, <code>i</code>代表的是index？？？</p>
<pre><code>&gt;&gt; df.iloc[3] # 选择第四行
A                      1
B    2018-03-29 00:00:00
C                      1
D                      3
E                  train
F                    foo
Name: 2018-04-14 00:00:00, dtype: object
</code></pre></li>
<li><p>通过数值进行切片，与<code>numpy</code>/<code>python</code>中的情况类似</p>
<pre><code>&gt;&gt; df.iloc[1:3, 2:4] # 选择1-2行，2-3列
          C  D
2018-04-12  1  3
2018-04-13  1  3
</code></pre></li>
<li><p>对行进行切片</p>
<pre><code>&gt;&gt; df.iloc[1:3, :] # 1-2行，所有列
          A          B  C  D      E    F
2018-04-12  1 2018-03-29  1  3  train  foo
2018-04-13  1 2018-03-29  1  3   test  foo
</code></pre></li>
<li><p>对列进行切片</p>
<pre><code>&gt;&gt; df.iloc[:, 2:4] # 全部行，2-3列
          C  D
2018-04-11  1  3
2018-04-12  1  3
2018-04-13  1  3
2018-04-14  1  3
</code></pre></li>
<li><p>获取特定的值</p>
<pre><code>&gt;&gt; df.iloc[1,4] # 选择1行的第5个元素
&#39;train&#39;
&gt;&gt; df.iat[1,4] # 和上述的loc at iloc对应，带i的是对类似数组的方式访问
&#39;train&#39;
</code></pre></li>
</ul>
<h3 id="4、布尔索引"><a href="#4、布尔索引" class="headerlink" title="4、布尔索引"></a>4、布尔索引</h3><ul>
<li><p>使用一个单独列的值来选择数据，感觉是和numpy一样的操作。</p>
<pre><code>&gt;&gt; df
                 A         B         C         D
2018-04-11 -0.859904  0.359774 -0.496582 -0.402911
2018-04-12 -0.025578  0.448901  1.536109 -0.846593
2018-04-13 -0.353849  1.803274 -1.299532  1.344752
2018-04-14  0.396720 -0.248795  0.376469  0.630602
2018-04-15 -0.051567 -0.751154 -0.842248  0.418928
2018-04-16  0.174124 -0.234736 -1.777619  1.005237
&gt;&gt; df[df.A &gt; 0]
                 A         B         C         D
2018-04-14  0.396720 -0.248795  0.376469  0.630602
2018-04-16  0.174124 -0.234736 -1.777619  1.005237
&gt;&gt; df.A &gt; 0
2018-04-11    False
2018-04-12    False
2018-04-13    False
2018-04-14     True
2018-04-15    False
2018-04-16     True
Freq: D, Name: A, dtype: bool
</code></pre></li>
<li><p>使用where操作选择数据:</p>
<pre><code>&gt;&gt; df[df &gt; 0] # 取出所有大于零的数据
                 A         B         C         D
2018-04-11       NaN  0.359774       NaN       NaN
2018-04-12       NaN  0.448901  1.536109       NaN
2018-04-13       NaN  1.803274       NaN  1.344752
2018-04-14  0.396720       NaN  0.376469  0.630602
2018-04-15       NaN       NaN       NaN  0.418928
2018-04-16  0.174124       NaN       NaN  1.005237
&gt;&gt; df &gt; 0
              A      B      C      D
2018-04-11  False   True  False  False
2018-04-12  False   True   True  False
2018-04-13  False   True  False   True
2018-04-14   True  False   True   True
2018-04-15  False  False  False   True
2018-04-16   True  False  False   True
</code></pre></li>
</ul>
<p>使用isin()方法来过滤</p>
<pre><code>&gt;&gt; df2 = df.copy()
&gt;&gt; df2[&#39;E&#39;] = [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;, &#39;three&#39;]
&gt;&gt; df2
                   A         B         C         D      E
2018-04-11 -0.859904  0.359774 -0.496582 -0.402911    one
2018-04-12 -0.025578  0.448901  1.536109 -0.846593    one
2018-04-13 -0.353849  1.803274 -1.299532  1.344752    two
2018-04-14  0.396720 -0.248795  0.376469  0.630602  three
2018-04-15 -0.051567 -0.751154 -0.842248  0.418928   four
2018-04-16  0.174124 -0.234736 -1.777619  1.005237  three
&gt;&gt; df2[&#39;E&#39;].isin([&#39;three&#39;, &#39;two&#39;])
2018-04-11    False
2018-04-12    False
2018-04-13     True
2018-04-14     True
2018-04-15    False
2018-04-16     True
Freq: D, Name: E, dtype: bool
&gt;&gt; df2[df2[&#39;E&#39;].isin([&#39;three&#39;, &#39;two&#39;])]
                   A         B         C         D      E
2018-04-13 -0.353849  1.803274 -1.299532  1.344752    two
2018-04-14  0.396720 -0.248795  0.376469  0.630602  three
2018-04-16  0.174124 -0.234736 -1.777619  1.005237  three
</code></pre><h2 id="三、设置"><a href="#三、设置" class="headerlink" title="三、设置"></a>三、设置</h2><ul>
<li><p>设置一个新的列：</p>
<pre><code>&gt;&gt; s1 = pd.Series(range(1,7), index=pd.date_range(&#39;20180411&#39;, periods=6))
&gt;&gt; s1
2018-04-11    1
2018-04-12    2
2018-04-13    3
2018-04-14    4
2018-04-15    5
2018-04-16    6
Freq: D, dtype: int64
&gt;&gt; df[&#39;F&#39;] = s1
&gt;&gt; df
                 A         B         C         D  F
2018-04-11 -0.859904  0.359774 -0.496582 -0.402911  1
2018-04-12 -0.025578  0.448901  1.536109 -0.846593  2
2018-04-13 -0.353849  1.803274 -1.299532  1.344752  3
2018-04-14  0.396720 -0.248795  0.376469  0.630602  4
2018-04-15 -0.051567 -0.751154 -0.842248  0.418928  5
2018-04-16  0.174124 -0.234736 -1.777619  1.005237  6
</code></pre></li>
<li><p>通过标签设置新的值：</p>
<pre><code>&gt;&gt; df.at[dates[0], &#39;A&#39;]
-0.85990391422115631
&gt;&gt; df.at[dates[0], &#39;A&#39;] = 0
&gt;&gt; df
                 A         B         C         D  F
2018-04-11  0.000000  0.359774 -0.496582 -0.402911  1
2018-04-12 -0.025578  0.448901  1.536109 -0.846593  2
2018-04-13 -0.353849  1.803274 -1.299532  1.344752  3
2018-04-14  0.396720 -0.248795  0.376469  0.630602  4
2018-04-15 -0.051567 -0.751154 -0.842248  0.418928  5
2018-04-16  0.174124 -0.234736 -1.777619  1.005237  6
</code></pre></li>
<li><p>通过位置设置新的值：</p>
<pre><code>&gt;&gt; df.iat[0,0]
0.0
&gt;&gt; df.iat[0,0] = 1
&gt;&gt; df
                 A         B         C         D  F
2018-04-11  1.000000  0.359774 -0.496582 -0.402911  1
2018-04-12 -0.025578  0.448901  1.536109 -0.846593  2
2018-04-13 -0.353849  1.803274 -1.299532  1.344752  3
2018-04-14  0.396720 -0.248795  0.376469  0.630602  4
2018-04-15 -0.051567 -0.751154 -0.842248  0.418928  5
2018-04-16  0.174124 -0.234736 -1.777619  1.005237  6
</code></pre></li>
<li><p>通过一个numpy数组设置一组新值，就是将一系列位置的值更改。</p>
<pre><code>&gt;&gt; df.loc[:, &#39;D&#39;] = np.array([5] * len(df))
&gt;&gt; df
                 A         B         C  D  F
2018-04-11  1.000000  0.359774 -0.496582  5  1
2018-04-12 -0.025578  0.448901  1.536109  5  2
2018-04-13 -0.353849  1.803274 -1.299532  5  3
2018-04-14  0.396720 -0.248795  0.376469  5  4
2018-04-15 -0.051567 -0.751154 -0.842248  5  5
2018-04-16  0.174124 -0.234736 -1.777619  5  6
</code></pre></li>
<li><p>通过where操作来设置新的值</p>
<pre><code>&gt;&gt; df2[df2 &gt; 1]
           A         B         C  D    F
2018-04-11 NaN       NaN       NaN  5  NaN
2018-04-12 NaN       NaN  1.536109  5  2.0
2018-04-13 NaN  1.803274       NaN  5  3.0
2018-04-14 NaN       NaN       NaN  5  4.0
2018-04-15 NaN       NaN       NaN  5  5.0
2018-04-16 NaN       NaN       NaN  5  6.0
&gt;&gt; df2[df2 &gt; 1] = -df2
&gt;&gt; df2
                 A         B         C  D  F
2018-04-11  1.000000  0.359774 -0.496582 -5  1
2018-04-12 -0.025578  0.448901 -1.536109 -5 -2
2018-04-13 -0.353849 -1.803274 -1.299532 -5 -3
2018-04-14  0.396720 -0.248795  0.376469 -5 -4
2018-04-15 -0.051567 -0.751154 -0.842248 -5 -5
2018-04-16  0.174124 -0.234736 -1.777619 -5 -6
</code></pre></li>
</ul>
</blockquote>
<hr>
<blockquote>
<h2 id="四、缺失值处理"><a href="#四、缺失值处理" class="headerlink" title="四、缺失值处理"></a>四、缺失值处理</h2><ul>
<li><p>在pandas中，使用np.nan来代替缺失值，这些值将默认不会包含在计算中，详情请参阅：<a href="http://pandas.pydata.org/pandas-docs/stable/missing_data.html#missing-data" target="_blank" rel="external">Missing Data Section</a></p>
</li>
<li><p>1、<code>reindex()</code>方法可以针对指定轴上的索引进行改变、增加、删除操作，这将返回原始数据的一个拷贝：</p>
<pre><code>&gt;&gt; df1 = df.reindex(index=dates[0:4], columns=list(df.columns) + [&#39;E&#39;])
&gt;&gt; df1
                 A         B         C  D  F   E
2018-04-11  1.000000  0.359774 -0.496582  5  1 NaN
2018-04-12 -0.025578  0.448901  1.536109  5  2 NaN
2018-04-13 -0.353849  1.803274 -1.299532  5  3 NaN
2018-04-14  0.396720 -0.248795  0.376469  5  4 NaN
&gt;&gt; df1.loc[dates[0]:dates[1], &#39;E&#39;] = 1
&gt;&gt; df1
                 A         B         C  D  F    E
2018-04-11  1.000000  0.359774 -0.496582  5  1  1.0
2018-04-12 -0.025578  0.448901  1.536109  5  2  1.0
2018-04-13 -0.353849  1.803274 -1.299532  5  3  NaN
2018-04-14  0.396720 -0.248795  0.376469  5  4  NaN
</code></pre></li>
<li><p>去掉包含缺失值的行(NaN)：</p>
<pre><code>&gt;&gt; df1.dropna(how=&#39;any&#39;)
                 A         B         C  D  F    E
2018-04-11  1.000000  0.359774 -0.496582  5  1  1.0
2018-04-12 -0.025578  0.448901  1.536109  5  2  1.0
</code></pre></li>
<li><p>对缺失值进行填充(NaN)：</p>
<pre><code>&gt;&gt; df1.fillna(value=10)
                 A         B         C  D  F     E
2018-04-11  1.000000  0.359774 -0.496582  5  1   1.0
2018-04-12 -0.025578  0.448901  1.536109  5  2   1.0
2018-04-13 -0.353849  1.803274 -1.299532  5  3  10.0
2018-04-14  0.396720 -0.248795  0.376469  5  4  10.0
</code></pre></li>
<li><p>对数据进行布尔填充，如位置是<code>NaN</code>，那么就是<code>True</code>：</p>
<pre><code>&gt;&gt; pd.isnull(df1)
              A      B      C      D      F      E
2018-04-11  False  False  False  False  False  False
2018-04-12  False  False  False  False  False  False
2018-04-13  False  False  False  False  False   True
2018-04-14  False  False  False  False  False   True
</code></pre></li>
</ul>
</blockquote>
<hr>
<blockquote>
<h2 id="五、相关操作"><a href="#五、相关操作" class="headerlink" title="五、相关操作"></a>五、相关操作</h2><ul>
<li>详情请参阅：<a href="http://pandas.pydata.org/pandas-docs/stable/basics.html#basics-binop" target="_blank" rel="external">Basic Section On Binary Ops</a><h3 id="统计（相关操作通常情况下不包括NaN值）"><a href="#统计（相关操作通常情况下不包括NaN值）" class="headerlink" title="统计（相关操作通常情况下不包括NaN值）"></a>统计（相关操作通常情况下不包括<code>NaN</code>值）</h3></li>
<li><p>1、执行描述性统计：</p>
<pre><code>&gt;&gt; df.mean() # 各列求均值
A    0.189975
B    0.229544
C   -0.417234
D    5.000000
F    3.500000
dtype: float64
</code></pre></li>
<li><p>2、在其他轴上进行相同的操作：（行）</p>
<pre><code>&gt;&gt; df.mean(1) # 1代表对行进行求均值，0代表对列求均值
2018-04-11    1.372638
2018-04-12    1.791886
2018-04-13    1.629979
2018-04-14    1.904879
2018-04-15    1.671006
2018-04-16    1.832354
Freq: D, dtype: float64
</code></pre></li>
<li><p>3、对于拥有不同维度，需要对齐的对象进行操作。<code>Pandas</code>会自动的沿着指定的维度进行广播：</p>
<pre><code>&gt;&gt; s = pd.Series([1,3,5,np.nan,6,8], index=dates).shift(2) # shift感觉类似转移数据，移动前面或者后面采用补`NaN`，支持负数。
&gt;&gt; s
2018-04-11    NaN
2018-04-12    NaN
2018-04-13    1.0
2018-04-14    3.0
2018-04-15    5.0
2018-04-16    NaN
Freq: D, dtype: float64
&gt;&gt; s
2018-04-11    NaN
2018-04-12    NaN
2018-04-13    1.0
2018-04-14    3.0
2018-04-15    5.0
2018-04-16    NaN
Freq: D, dtype: float64
&gt;&gt; df.sub(s, axis=&#39;index&#39;) # sub 做减法
                 A         B         C    D    F
2018-04-11       NaN       NaN       NaN  NaN  NaN
2018-04-12       NaN       NaN       NaN  NaN  NaN
2018-04-13 -1.353849  0.803274 -2.299532  4.0  2.0
2018-04-14 -2.603280 -3.248795 -2.623531  2.0  1.0
2018-04-15 -5.051567 -5.751154 -5.842248  0.0  0.0
2018-04-16       NaN       NaN       NaN  NaN  NaN
</code></pre></li>
</ul>
<h3 id="Apply"><a href="#Apply" class="headerlink" title="Apply"></a>Apply</h3><ul>
<li>1、对数据应用函数：<pre><code>&gt;&gt; df.apply(np.cumsum) # 应用函数，逐行累加
                 A         B         C   D   F
2018-04-11  1.000000  0.359774 -0.496582   5   1
2018-04-12  0.974422  0.808675  1.039527  10   3
2018-04-13  0.620573  2.611949 -0.260005  15   6
2018-04-14  1.017293  2.363153  0.116464  20  10
2018-04-15  0.965726  1.612000 -0.725784  25  15
2018-04-16  1.139850  1.377264 -2.503403  30  21
&gt;&gt; df.apply(lambda x: x.max() - x.min()) # x为接收的一列数据，目的是求极差
A    1.353849
B    2.554428
C    3.313728
D    0.000000
F    5.000000
dtype: float64
</code></pre></li>
</ul>
<h3 id="直方图，为何叫直方图：实际是统计数据中相同项的个数，然后可以直接画图吧。"><a href="#直方图，为何叫直方图：实际是统计数据中相同项的个数，然后可以直接画图吧。" class="headerlink" title="直方图，为何叫直方图：实际是统计数据中相同项的个数，然后可以直接画图吧。"></a>直方图，为何叫直方图：实际是统计数据中相同项的个数，然后可以直接画图吧。</h3><ul>
<li>具体参考：<a href="http://pandas.pydata.org/pandas-docs/stable/basics.html#basics-discretization" target="_blank" rel="external">Histogramming and Discretization</a><pre><code>&gt;&gt; s = pd.Series(np.random.randint(0,7, size=10))
&gt;&gt; s
0    3
1    6
2    2
3    0
4    0
5    3
6    5
7    0
8    4
9    0
dtype: int32
&gt;&gt; s.value_counts()
0    4
3    2
6    1
5    1
4    1
2    1
dtype: int64
</code></pre></li>
</ul>
<h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><p><code>Series</code>对象在其str属性中配备了一组字符串处理方法，可以很容易的应用到数组中的每个元素，如下段代码所示。更多详情请参阅：<a href="http://pandas.pydata.org/pandas-docs/stable/text.html#text-string-methods" target="_blank" rel="external">Vectorized String Methods</a>。</p>
<pre><code>&gt;&gt; s = pd.Series([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;Aaba&#39;, &#39;Baca&#39;, np.nan, &#39;CABA&#39;, &#39;dog&#39;, &#39;cat&#39;])
&gt;&gt; s.str.lower()
0       a
1       b
2       c
3    aaba
4    baca
5     NaN
6    caba
7     dog
8     cat
dtype: object
</code></pre><ul>
<li>有如下方法可以使用，基本都是<code>str</code>的方法吧：<br><code>[&#39;capitalize&#39;,&#39;cat&#39;, &#39;center&#39;, &#39;contains&#39;, &#39;count&#39;, &#39;decode&#39;, &#39;encode&#39;, &#39;endswith&#39;, &#39;extract&#39;,&#39;extractall&#39;, &#39;find&#39;, &#39;findall&#39;, &#39;get&#39;, &#39;get_dummies&#39;, &#39;index&#39;, &#39;isalnum&#39;, &#39;isalpha&#39;, &#39;isdecimal&#39;, &#39;isdigit&#39;, &#39;islower&#39;, &#39;isnumeric&#39;, &#39;isspace&#39;, &#39;istitle&#39;, &#39;isupper&#39;, &#39;join&#39;, &#39;len&#39;, &#39;ljust&#39;, &#39;lower&#39;, &#39;lstrip&#39;, &#39;match&#39;, &#39;normalize&#39;, &#39;pad&#39;,&#39;partition&#39;, &#39;repeat&#39;, &#39;replace&#39;, &#39;rfind&#39;, &#39;rindex&#39;, &#39;rjust&#39;, &#39;rpartition&#39;, &#39;rsplit&#39;, &#39;rstrip&#39;, &#39;slice&#39;, &#39;slice_replace&#39;, &#39;split&#39;, &#39;startswith&#39;, &#39;strip&#39;, &#39;swapcase&#39;, &#39;title&#39;, &#39;translate&#39;, &#39;upper&#39;, &#39;wrap&#39;, &#39;zfill&#39;]</code></li>
</ul>
</blockquote>
<hr>
<blockquote>
<h2 id="六、合并"><a href="#六、合并" class="headerlink" title="六、合并"></a>六、合并</h2><ul>
<li><code>Pandas</code>提供了大量的方法能够轻松的对Series，DataFrame和Panel对象就行各种符合这种逻辑关键的合并，具体详阅：<a href="http://pandas.pydata.org/pandas-docs/stable/merging.html#merging" target="_blank" rel="external">Merging section</a></li>
<li><p>1.1、Concat，做连接行的操作。</p>
<pre><code>&gt;&gt; df = pd.DataFrame(np.random.randn(10,7))
&gt;&gt; df
        0         1         2         3         4         5         6
0  0.553137 -0.461531 -0.178430  0.059118 -0.817795 -0.661965  0.593987
1  1.415022  0.237064 -0.754901  0.654607  1.074064  1.140084 -1.159549
2 -0.605326 -0.410053 -0.020292 -0.727507 -0.294475  0.799932 -0.118478
3  0.954070  0.318788  0.191754 -1.127220  0.294069 -0.245938 -0.402836
4  0.391626 -1.019158  0.759993 -1.401365  0.187595 -0.961535 -2.475896
5 -1.755276 -1.126669 -1.522097 -0.832615 -0.263640 -1.142642 -0.802544
6  0.055710  0.823794 -0.523068 -0.619966 -0.241422  0.894117 -0.011115
7 -0.559937  1.382979  2.352500 -0.500757 -0.601975  2.136011 -1.119064
8  0.631365  0.399121  0.960120  0.667968  1.609791 -0.775155  0.303688
9  1.071855 -0.546073  0.200751  1.845542  0.823959  0.768150  0.935161
&gt;&gt; pieces = [df[:3], df[3:7], df[7:]]
&gt;&gt; pd.concat(pieces)
        0         1         2         3         4         5         6
0  0.553137 -0.461531 -0.178430  0.059118 -0.817795 -0.661965  0.593987
1  1.415022  0.237064 -0.754901  0.654607  1.074064  1.140084 -1.159549
2 -0.605326 -0.410053 -0.020292 -0.727507 -0.294475  0.799932 -0.118478
3  0.954070  0.318788  0.191754 -1.127220  0.294069 -0.245938 -0.402836
4  0.391626 -1.019158  0.759993 -1.401365  0.187595 -0.961535 -2.475896
5 -1.755276 -1.126669 -1.522097 -0.832615 -0.263640 -1.142642 -0.802544
6  0.055710  0.823794 -0.523068 -0.619966 -0.241422  0.894117 -0.011115
7 -0.559937  1.382979  2.352500 -0.500757 -0.601975  2.136011 -1.119064
8  0.631365  0.399121  0.960120  0.667968  1.609791 -0.775155  0.303688
9  1.071855 -0.546073  0.200751  1.845542  0.823959  0.768150  0.935161
</code></pre></li>
<li><p>1.2、join 类似于SQL类型的合并，具体请参阅：<a href="http://pandas.pydata.org/pandas-docs/stable/merging.html#merging-join" target="_blank" rel="external">Database style joining</a></p>
<pre><code>&gt;&gt; left = pd.DataFrame({&#39;key&#39;:[&#39;foo&#39;, &#39;foo&#39;], &#39;lval&#39;:[1,2]})
&gt;&gt; left
 key  lval
0  foo     1
1  foo     2
&gt;&gt; right = pd.DataFrame({&#39;key&#39;:[&#39;foo&#39;, &#39;foo&#39;], &#39;lval&#39;:[4,5]})
&gt;&gt; right
 key  lval
0  foo     4
1  foo     5
&gt;&gt; pd.merge(left, right, on=&#39;key&#39;)
 key  lval_x  lval_y
0  foo       1       4
1  foo       1       5
2  foo       2       4
3  foo       2       5
&gt;&gt;
</code></pre></li>
<li><p>1.3、Append将一行连接到一个DataFrame上，具体请参考 <a href="http://pandas.pydata.org/pandas-docs/stable/merging.html#merging-concatenation" target="_blank" rel="external">Appending</a>:</p>
<pre><code>&gt;&gt; df = pd.DataFrame(np.random.randn(8,4), columns=list(&#39;ABCD&#39;))
&gt;&gt; df
        A         B         C         D
0  0.131836 -1.771433 -0.695097 -0.247473
1  2.501394  0.992452  0.088223 -0.066071
2 -0.041648  0.886106 -1.409708  0.485876
3  2.458939  0.136338  0.727887  0.998972
4 -1.382066 -0.175513 -0.980074  0.586191
5  0.456496  0.061632  2.138576  1.551554
6 -0.134137  1.508475 -0.178692  0.113549
7  0.753561 -0.608606 -0.209655 -0.102295
&gt;&gt; line = df.iloc[3]
&gt;&gt; line
A    2.458939
B    0.136338
C    0.727887
D    0.998972
Name: 3, dtype: float64
&gt;&gt; df.append(line)
        A         B         C         D
0  0.131836 -1.771433 -0.695097 -0.247473
1  2.501394  0.992452  0.088223 -0.066071
2 -0.041648  0.886106 -1.409708  0.485876
3  2.458939  0.136338  0.727887  0.998972
4 -1.382066 -0.175513 -0.980074  0.586191
5  0.456496  0.061632  2.138576  1.551554
6 -0.134137  1.508475 -0.178692  0.113549
7  0.753561 -0.608606 -0.209655 -0.102295
3  2.458939  0.136338  0.727887  0.998972
&gt;&gt; df.append(line, ignore_index=True)
        A         B         C         D
0  0.131836 -1.771433 -0.695097 -0.247473
1  2.501394  0.992452  0.088223 -0.066071
2 -0.041648  0.886106 -1.409708  0.485876
3  2.458939  0.136338  0.727887  0.998972
4 -1.382066 -0.175513 -0.980074  0.586191
5  0.456496  0.061632  2.138576  1.551554
6 -0.134137  1.508475 -0.178692  0.113549
7  0.753561 -0.608606 -0.209655 -0.102295
8  2.458939  0.136338  0.727887  0.998972
</code></pre></li>
</ul>
</blockquote>
<hr>
<blockquote>
<h2 id="七、分组"><a href="#七、分组" class="headerlink" title="七、分组"></a>七、分组</h2><ul>
<li>对于<code>group by</code>操作，我们通常是指以下一个或多个操作步骤：<br>1、(Splitting) 按照一些规则将数据分为不同的组；<br>2、(Applying) 对于每组数据分别执行一个函数；<br>3、(Combining) 将结果组合到一个数据结构中；<br>详情请参阅：<a href="http://pandas.pydata.org/pandas-docs/stable/groupby.html#groupby" target="_blank" rel="external">Grouping section</a><pre><code>&gt;&gt; df = pd.DataFrame({&#39;A&#39; : [&#39;foo&#39;, &#39;bar&#39;, &#39;foo&#39;, &#39;bar&#39;,&#39;foo&#39;, &#39;bar&#39;, &#39;foo&#39;, &#39;foo&#39;], &#39;B&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;], &#39;C&#39; :np.random.randn(8), &#39;D&#39; : np.random.randn(8)})
&gt;&gt; df
   A      B         C         D
0  foo    one -0.118332 -0.833735
1  bar    one  0.359787  1.333599
2  foo    two  0.961724 -1.966801
3  bar  three -3.627354 -0.587706
4  foo    two -1.281741 -0.403980
5  bar    two -1.390664 -1.483122
6  foo    one  1.403112 -0.213065
7  foo  three  0.399807  0.929839
</code></pre></li>
<li>1、分组并对每个分组执行<code>sum</code>函数<pre><code>&gt;&gt; df.groupby(&#39;A&#39;).sum() # 类似分类汇总吧
          C         D
A
bar -4.658232 -0.737229
foo  1.364570 -2.487742
</code></pre></li>
<li>2、对多个列进行分组形成一个层次索引，然后执行函数：<pre><code>&gt;&gt; df.groupby([&#39;A&#39;, &#39;B&#39;]).sum()
                C         D
A   B
bar one    0.359787  1.333599
  three -3.627354 -0.587706
  two   -1.390664 -1.483122
foo one    1.284780 -1.046800
  three  0.399807  0.929839
  two   -0.320017 -2.370781
&gt;&gt;
</code></pre></li>
</ul>
</blockquote>
<hr>
<blockquote>
<h2 id="八、Reshaping"><a href="#八、Reshaping" class="headerlink" title="八、Reshaping"></a>八、Reshaping</h2><ul>
<li>详情请参阅：<a href="http://pandas.pydata.org/pandas-docs/stable/advanced.html#advanced-hierarchical" target="_blank" rel="external">Hierarchical Indexing</a> 和 <a href="http://pandas.pydata.org/pandas-docs/stable/reshaping.html#reshaping-stacking" target="_blank" rel="external">Reshaping</a></li>
<li>1、Stack<pre><code>&gt;&gt; tuples = list(zip(*[[&#39;bar&#39;, &#39;bar&#39;, &#39;baz&#39;, &#39;baz&#39;, &#39;foo&#39;, &#39;foo&#39;, &#39;quz&#39;, &#39;quz&#39;]
,[&#39;one&#39;, &#39;two&#39;, &#39;one&#39;, &#39;two&#39;, &#39;one&#39;, &#39;two&#39;, &#39;one&#39;, &#39;two&#39;]]))
&gt;&gt; tuples
[(&#39;bar&#39;, &#39;one&#39;), (&#39;bar&#39;, &#39;two&#39;), (&#39;baz&#39;, &#39;one&#39;), (&#39;baz&#39;, &#39;two&#39;), (&#39;foo&#39;, &#39;one&#39;),
(&#39;foo&#39;, &#39;two&#39;), (&#39;quz&#39;, &#39;one&#39;), (&#39;quz&#39;, &#39;two&#39;)]
&gt;&gt; index = pd.MultiIndex.from_tuples(tuples, names=[&#39;first&#39;, &#39;second&#39;])
&gt;&gt; index
MultiIndex(levels=[[&#39;bar&#39;, &#39;baz&#39;, &#39;foo&#39;, &#39;quz&#39;], [&#39;one&#39;, &#39;two&#39;]],
         labels=[[0, 0, 1, 1, 2, 2, 3, 3], [0, 1, 0, 1, 0, 1, 0, 1]],
         names=[&#39;first&#39;, &#39;second&#39;])
&gt;&gt; df = pd.DataFrame(np.random.randn(8,2), index=index, columns=[&#39;A&#39;, &#39;B&#39;])
&gt;&gt; df
                   A         B
first second
bar   one     0.192085  1.408195
    two     1.866444  0.635571
baz   one     0.812173 -0.442293
    two    -0.969346  0.697064
foo   one    -1.039750 -0.167861
    two     0.359010  0.795804
quz   one     0.315553  0.591019
    two     0.177442 -1.071087
&gt;&gt; df2 = df[:4]
&gt;&gt; df2
                   A         B
first second
bar   one     0.192085  1.408195
    two     1.866444  0.635571
baz   one     0.812173 -0.442293
    two    -0.969346  0.697064
&gt;&gt; stacked = df2.stack()
&gt;&gt; stacked
first  second
bar    one     A    0.192085
             B    1.408195
     two     A    1.866444
             B    0.635571
baz    one     A    0.812173
             B   -0.442293
     two     A   -0.969346
             B    0.697064
dtype: float64
&gt;&gt; stacked.unstack()
                   A         B
first second
bar   one     0.192085  1.408195
    two     1.866444  0.635571
baz   one     0.812173 -0.442293
    two    -0.969346  0.697064
&gt;&gt; stacked.unstack(1)
second        one       two
first
bar   A  0.192085  1.866444
    B  1.408195  0.635571
baz   A  0.812173 -0.969346
    B -0.442293  0.697064
&gt;&gt; stacked.unstack(0)
first          bar       baz
second
one    A  0.192085  0.812173
     B  1.408195 -0.442293
two    A  1.866444 -0.969346
     B  0.635571  0.697064
</code></pre></li>
<li>2、数据透视表，详情请参阅：<a href="http://pandas.pydata.org/pandas-docs/stable/reshaping.html#reshaping-pivot" target="_blank" rel="external">Pivot Tables</a><pre><code>&gt;&gt; df = pd.DataFrame({&#39;A&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;]*3, &#39;B&#39;:[&#39;A&#39;, &#39;B&#39;, &#39;C
&#39;] * 4, &#39;C&#39;:[&#39;foo&#39;, &#39;foo&#39;, &#39;foo&#39;, &#39;bar&#39;, &#39;bar&#39;, &#39;bar&#39;]*2, &#39;D&#39;:np.random.randn(12
), &#39;E&#39;:np.random.randn(12)})
&gt;&gt; df
      A  B    C         D         E
0     one  A  foo -2.217020 -0.706020
1     one  B  foo -0.680808 -1.987900
2     two  C  foo -1.744418 -0.037439
3   three  A  bar  1.010820 -0.526640
4     one  B  bar -0.820246 -0.601110
5     one  C  bar  1.348459  0.286765
6     two  A  foo  1.497069  1.148904
7   three  B  foo -1.284661  1.134721
8     one  C  foo  0.449730  0.487581
9     one  A  bar -0.601461  0.177472
10    two  B  bar -2.329131 -1.519148
11  three  C  bar  0.058038 -0.217201
&gt;&gt; pd.pivot_table(df, values=&#39;D&#39;, index=[&#39;A&#39;, &#39;B&#39;], columns=&#39;C&#39;)
C             bar       foo
A     B
one   A -0.601461 -2.217020
    B -0.820246 -0.680808
    C  1.348459  0.449730
three A  1.010820       NaN
    B       NaN -1.284661
    C  0.058038       NaN
two   A       NaN  1.497069
    B -2.329131       NaN
    C       NaN -1.744418
&gt;&gt;
</code></pre></li>
</ul>
</blockquote>
<hr>
<blockquote>
<h2 id="九、时间序列"><a href="#九、时间序列" class="headerlink" title="九、时间序列"></a>九、时间序列</h2><ul>
<li><code>Pandas</code>在对频率转换进行重新采样的时候拥有非常简单、强大且高效的功能（如将按秒采样的数据转换为按5分钟为单位进行采样的数据）。这种操作在金融领域很常见。具体参考：<a href="http://pandas.pydata.org/pandas-docs/stable/timeseries.html#timeseries" target="_blank" rel="external">Time Series section</a><pre><code>&gt;&gt; rng = pd.date_range(&#39;4/17/2018&#39;, periods=100, freq=&#39;S&#39;)
&gt;&gt; ts = pd.Series(np.random.randint(0, 500, len(rng)), index=rng)
&gt;&gt; ts.resample(&#39;5Min&#39;, how=&#39;sum&#39;)
__main__:1: FutureWarning: how in .resample() is deprecated # 最新版本已经被遗弃了
the new syntax is .resample(...).sum() # 推荐使用这种方式。
2018-04-17    25671
Freq: 5T, dtype: int32
&gt;&gt; ts.resample(&#39;5Min&#39;).sum()
2018-04-17    25671
Freq: 5T, dtype: int32
</code></pre></li>
<li>1、时区表示<pre><code>&gt;&gt; rng = pd.date_range(&#39;4/17/2018&#39;, periods=5, freq=&#39;D&#39;)
&gt;&gt; rng
DatetimeIndex([&#39;2018-04-17&#39;, &#39;2018-04-18&#39;, &#39;2018-04-19&#39;, &#39;2018-04-20&#39;,
             &#39;2018-04-21&#39;],
            dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)
&gt;&gt; ts = pd.Series(np.random.randn(len(rng)), rng)
&gt;&gt; ts
2018-04-17   -0.994141
2018-04-18    0.713261
2018-04-19    0.956092
2018-04-20   -0.186506
2018-04-21    0.565844
Freq: D, dtype: float64
&gt;&gt; ts_utc = ts.tz_localize(&#39;UTC&#39;)
&gt;&gt; ts_utc
2018-04-17 00:00:00+00:00   -0.994141
2018-04-18 00:00:00+00:00    0.713261
2018-04-19 00:00:00+00:00    0.956092
2018-04-20 00:00:00+00:00   -0.186506
2018-04-21 00:00:00+00:00    0.565844
Freq: D, dtype: float64
</code></pre></li>
<li>2、时区转换<pre><code>&gt;&gt; ts_utc.tz_convert(&#39;US/Eastern&#39;) # 北京时间是什么关键字？
2018-04-16 20:00:00-04:00   -0.994141
2018-04-17 20:00:00-04:00    0.713261
2018-04-18 20:00:00-04:00    0.956092
2018-04-19 20:00:00-04:00   -0.186506
2018-04-20 20:00:00-04:00    0.565844
Freq: D, dtype: float64
&gt;&gt;
</code></pre></li>
<li>时间跨度转换<pre><code>&gt;&gt; rng = pd.date_range(&#39;4/17/2018&#39;, periods=5, freq=&#39;M&#39;)
&gt;&gt; rng
DatetimeIndex([&#39;2018-04-30&#39;, &#39;2018-05-31&#39;, &#39;2018-06-30&#39;, &#39;2018-07-31&#39;,
             &#39;2018-08-31&#39;],
            dtype=&#39;datetime64[ns]&#39;, freq=&#39;M&#39;)
&gt;&gt; ts = pd.Series(np.random.randn(len(rng)), rng)
&gt;&gt; ts
2018-04-30    3.007299
2018-05-31    2.438724
2018-06-30   -0.063751
2018-07-31   -0.825316
2018-08-31    0.127897
Freq: M, dtype: float64
&gt;&gt; ps = ts.to_period()
&gt;&gt; ps
2018-04    3.007299
2018-05    2.438724
2018-06   -0.063751
2018-07   -0.825316
2018-08    0.127897
Freq: M, dtype: float64
&gt;&gt; ps.to_timestamp()
2018-04-01    3.007299
2018-05-01    2.438724
2018-06-01   -0.063751
2018-07-01   -0.825316
2018-08-01    0.127897
Freq: MS, dtype: float64
</code></pre></li>
<li>4、时间和时间戳之间的转换使得可以使用一些方便的算术函数。<pre><code>&gt;&gt; prng = pd.period_range(&#39;2018Q1&#39;, &#39;2028Q4&#39;, freq=&#39;Q-NOV&#39;)
&gt;&gt; prng
PeriodIndex([&#39;2018Q1&#39;, &#39;2018Q2&#39;, &#39;2018Q3&#39;, &#39;2018Q4&#39;, &#39;2019Q1&#39;, &#39;2019Q2&#39;,
           &#39;2019Q3&#39;, &#39;2019Q4&#39;, &#39;2020Q1&#39;, &#39;2020Q2&#39;, &#39;2020Q3&#39;, &#39;2020Q4&#39;,
           &#39;2021Q1&#39;, &#39;2021Q2&#39;, &#39;2021Q3&#39;, &#39;2021Q4&#39;, &#39;2022Q1&#39;, &#39;2022Q2&#39;,
           &#39;2022Q3&#39;, &#39;2022Q4&#39;, &#39;2023Q1&#39;, &#39;2023Q2&#39;, &#39;2023Q3&#39;, &#39;2023Q4&#39;,
           &#39;2024Q1&#39;, &#39;2024Q2&#39;, &#39;2024Q3&#39;, &#39;2024Q4&#39;, &#39;2025Q1&#39;, &#39;2025Q2&#39;,
           &#39;2025Q3&#39;, &#39;2025Q4&#39;, &#39;2026Q1&#39;, &#39;2026Q2&#39;, &#39;2026Q3&#39;, &#39;2026Q4&#39;,
           &#39;2027Q1&#39;, &#39;2027Q2&#39;, &#39;2027Q3&#39;, &#39;2027Q4&#39;, &#39;2028Q1&#39;, &#39;2028Q2&#39;,
           &#39;2028Q3&#39;, &#39;2028Q4&#39;],
          dtype=&#39;period[Q-NOV]&#39;, freq=&#39;Q-NOV&#39;)
&gt;&gt; ts = pd.Series(np.random.randn(len(prng)), prng)
&gt;&gt; ts.index = (prng.asfreq(&#39;M&#39;, &#39;e&#39;) + 1).asfreq(&#39;H&#39;, &#39;s&#39;) + 9
&gt;&gt; ts.head()
2018-03-01 09:00    0.499979
2018-06-01 09:00   -2.246589
2018-09-01 09:00   -0.824984
2018-12-01 09:00   -0.578511
2019-03-01 09:00   -0.310868
Freq: H, dtype: float64
</code></pre></li>
</ul>
</blockquote>
<hr>
<blockquote>
<h2 id="十、Categorical"><a href="#十、Categorical" class="headerlink" title="十、Categorical"></a>十、Categorical</h2><ul>
<li>从<code>0.15</code>版本开始，<code>pandas</code>可以在DataFrame中支持Categorical类型的数据，详细请看：<a href="http://pandas.pydata.org/pandas-docs/stable/categorical.html#categorical" target="_blank" rel="external">categorical introduction</a> 和 <a href="http://pandas.pydata.org/pandas-docs/stable/api.html#api-categorical" target="_blank" rel="external">API documentation</a><br><code>&gt;&gt;&gt; df = pd.DataFrame({&#39;id&#39;: [1,2,3,4,5,6], &#39;raw_grade&#39;:[&#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;, &#39;e&#39;]})</code></li>
<li>将原始的grade转换为Categorical数据类型<pre><code>&gt;&gt; df[&#39;grade&#39;] = df[&#39;raw_grade&#39;].astype(&#39;category&#39;)
&gt;&gt; df[&#39;grade&#39;]
0    a
1    b
2    b
3    a
4    a
5    e
Name: grade, dtype: category
Categories (3, object): [a, b, e]
</code></pre></li>
<li><p>将Categorical类型数据命名为更有意义的名称：</p>
<pre><code>&gt;&gt; df[&#39;grade&#39;].cat.categories = [&#39;very good&#39;, &#39;good&#39;, &#39;very bad&#39;]
&gt;&gt; df
 id raw_grade      grade
0   1         a  very good
1   2         b       good
2   3         b       good
3   4         a  very good
4   5         a  very good
5   6         e   very bad
</code></pre></li>
<li><p>对类别进行重新排序，并增加完整的类别：</p>
<pre><code>&gt;&gt; df[&#39;grade&#39;] = df[&#39;grade&#39;].cat.set_categories([&#39;very bad&#39;, &#39;bad&#39;, &#39;medium&#39;, &#39;good&#39;, &#39;very good&#39;])
&gt;&gt; df[&#39;grade&#39;]
0    very good
1         good
2         good
3    very good
4    very good
5     very bad
Name: grade, dtype: category
Categories (5, object): [very bad, bad, medium, good, very good]
</code></pre></li>
<li><p>排序按照的是<code>Categorical</code>的顺序进行的而不是按照字典顺序进行：</p>
<pre><code>&gt;&gt; df.sort_values(&#39;grade&#39;)
 id raw_grade      grade
5   6         e   very bad
1   2         b       good
2   3         b       good
0   1         a  very good
3   4         a  very good
4   5         a  very good
</code></pre></li>
<li><p>对<code>Categorical</code>列进行排序时存在空的类别，目前最新版本是<code>0</code>，而非<code>NaN</code>。</p>
<pre><code>&gt;&gt; df.groupby(&#39;grade&#39;).size()
grade
very bad     1
bad          0
medium       0
good         2
very good    3
dtype: int64
</code></pre></li>
</ul>
</blockquote>
<hr>
<blockquote>
<h2 id="十一、画图"><a href="#十一、画图" class="headerlink" title="十一、画图"></a>十一、画图</h2><ul>
<li>具体看文档：<a href="http://pandas.pydata.org/pandas-docs/stable/visualization.html#visualization" target="_blank" rel="external">Plotting docs</a><pre><code>&gt;&gt; ts = pd.Series(np.random.randn(1000), index=pd.date_range(&#39;20180417&#39;, periods=1000))
&gt;&gt; ts.plot().get_figure().savefig(&#39;ts.png&#39;)
</code></pre></li>
<li>对于<code>DataFrame</code>来说，<code>plot</code>是一种将所有列及其标签进行绘制的简便方法：<pre><code>&gt;&gt; df = pd.DataFrame(np.random.randn(1000, 4), index = ts.index, columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])
&gt;&gt; df = df.cumsum()
&gt;&gt; df.plot().get_figure().savefig(&#39;df.png&#39;)
</code></pre></li>
</ul>
</blockquote>
<hr>
<blockquote>
<h2 id="十二、导入和保存数据"><a href="#十二、导入和保存数据" class="headerlink" title="十二、导入和保存数据"></a>十二、导入和保存数据</h2><ul>
<li>1、<code>csv</code>，参考：<a href="http://pandas.pydata.org/pandas-docs/stable/io.html#io-store-in-csv" target="_blank" rel="external">Writing to a csv file</a></li>
<li>1.1、写入文件：<br><code>&gt;&gt;&gt; df.to_csv(&#39;foo.csv&#39;)</code></li>
<li>1.2、从<code>csv</code>读取：<br><code>&gt;&gt;&gt; pd.read_csv(&#39;foo.csv&#39;)</code></li>
<li>下面就不用说了，HDF5、Excel基本都是一样，主要考虑的是格式问题，其中读写CSV的时候遇到，单独给某一列数据前面加<code>UFT-8 无BOM</code>格式的前缀，暂时没能找到什么方法解决，<code>\xef\xbb\xbf</code>这个前缀，需要在读取的时候自动匹配去掉。</li>
</ul>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习 python Pandas 10minutes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python进制问题]]></title>
      <url>/2018/01/27/python/common/hex&amp;octal_problem/</url>
      <content type="html"><![CDATA[<h1 id="16进制和8进制的问题"><a href="#16进制和8进制的问题" class="headerlink" title="16进制和8进制的问题"></a>16进制和8进制的问题</h1><blockquote>
<p>今天在网上看到有人在问<code>\x20</code>（16进制）和<code>\20</code>（8进制）的问题</p>
<pre><code>&gt;&gt; &#39;\x20&#39;
&#39; &#39;
&gt;&gt; &#39;\20&#39;
&#39;\x10&#39;
</code></pre><p>如上，因为这个存在特殊性：<code>\x20</code>对应是10进制是<code>32</code>，而<code>32</code>Ascii码对应的控制字符空格<code>Space</code>，这个一眼就看出来了是16进制，而且也知道是16进制。<br>然而<code>\20</code>就不好解释了，平时接触8进制也较少，刚开始以为是自动转换16进制，但是打印的结果显然推翻了结论，后续还想到<code>\</code>是转义字符，那么<code>\2</code>等有特殊意义。<br>于是开始从<code>\1</code>打印到<code>\10</code>，如下所示：</p>
<pre><code>&gt;&gt; &#39;\7&#39;
&#39;\x07&#39;
&gt;&gt; &#39;\8&#39;
&#39;\\8&#39;
&gt;&gt; &#39;\9&#39;
&#39;\\9&#39;
&gt;&gt; &#39;\10&#39;
&#39;\x08&#39;
</code></pre><p>发现<code>\8</code>打印很奇怪，<code>\10</code>打印的16进制是<code>\x08</code>，然后才想到是8进制，因为8进制表示10进制8需要进位，所以8进制的8就是<code>\10</code>。</p>
</blockquote>
<h2 id="ASCII码表"><a href="#ASCII码表" class="headerlink" title="ASCII码表"></a>ASCII码表</h2><blockquote>
<p><a href="https://baike.baidu.com/item/ASCII/309296?fr=aladdin&amp;fromid=19660475&amp;fromtitle=ascii%E7%A0%81%E8%A1%A8" title="百度百科Ascii码" target="_blank" rel="external">来源百度百科</a></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">Bin(二进制)</th>
<th style="text-align:center">Oct(八进制)</th>
<th style="text-align:center">Dec(十进制)</th>
<th style="text-align:center">Hex(十六进制)</th>
<th style="text-align:left">缩写/字符</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0000 0000</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:left">NUL(null)</td>
<td style="text-align:center">空字符</td>
</tr>
<tr>
<td style="text-align:left">0000 0001</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:left">SOH(start of headline)</td>
<td style="text-align:center">标题开始</td>
</tr>
<tr>
<td style="text-align:left">0000 0010</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:left">STX (start of text)</td>
<td style="text-align:center">正文开始</td>
</tr>
<tr>
<td style="text-align:left">0000 0011</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:left">ETX (end of text)</td>
<td style="text-align:center">正文结束</td>
</tr>
<tr>
<td style="text-align:left">0000 0100</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:left">EOT (end of transmission)</td>
<td style="text-align:center">传输结束</td>
</tr>
<tr>
<td style="text-align:left">0000 0101</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:left">ENQ (enquiry)</td>
<td style="text-align:center">请求</td>
</tr>
<tr>
<td style="text-align:left">0000 0110</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:left">ACK (acknowledge)</td>
<td style="text-align:center">收到通知</td>
</tr>
<tr>
<td style="text-align:left">0000 0111</td>
<td style="text-align:center">7</td>
<td style="text-align:center">7</td>
<td style="text-align:center">7</td>
<td style="text-align:left">BEL (bell)</td>
<td style="text-align:center">响铃</td>
</tr>
<tr>
<td style="text-align:left">0000 1000</td>
<td style="text-align:center">10</td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
<td style="text-align:left">BS (backspace)</td>
<td style="text-align:center">退格</td>
</tr>
<tr>
<td style="text-align:left">0000 1001</td>
<td style="text-align:center">11</td>
<td style="text-align:center">9</td>
<td style="text-align:center">9</td>
<td style="text-align:left">HT (horizontal tab)</td>
<td style="text-align:center">水平制表符</td>
</tr>
<tr>
<td style="text-align:left">0000 1010</td>
<td style="text-align:center">12</td>
<td style="text-align:center">10</td>
<td style="text-align:center">0A</td>
<td style="text-align:left">“LF (NL line feed new line)”</td>
<td style="text-align:center">换行键</td>
</tr>
<tr>
<td style="text-align:left">0000 1011</td>
<td style="text-align:center">13</td>
<td style="text-align:center">11</td>
<td style="text-align:center">0B</td>
<td style="text-align:left">VT (vertical tab)</td>
<td style="text-align:center">垂直制表符</td>
</tr>
<tr>
<td style="text-align:left">0000 1100</td>
<td style="text-align:center">14</td>
<td style="text-align:center">12</td>
<td style="text-align:center">0C</td>
<td style="text-align:left">“FF (NP form feed new page)”</td>
<td style="text-align:center">换页键</td>
</tr>
<tr>
<td style="text-align:left">0000 1101</td>
<td style="text-align:center">15</td>
<td style="text-align:center">13</td>
<td style="text-align:center">0D</td>
<td style="text-align:left">CR (carriage return)</td>
<td style="text-align:center">回车键</td>
</tr>
<tr>
<td style="text-align:left">0000 1110</td>
<td style="text-align:center">16</td>
<td style="text-align:center">14</td>
<td style="text-align:center">0E</td>
<td style="text-align:left">SO (shift out)</td>
<td style="text-align:center">不用切换</td>
</tr>
<tr>
<td style="text-align:left">0000 1111</td>
<td style="text-align:center">17</td>
<td style="text-align:center">15</td>
<td style="text-align:center">0F</td>
<td style="text-align:left">SI (shift in)</td>
<td style="text-align:center">启用切换</td>
</tr>
<tr>
<td style="text-align:left">0001 0000</td>
<td style="text-align:center">20</td>
<td style="text-align:center">16</td>
<td style="text-align:center">10</td>
<td style="text-align:left">DLE (data link escape)</td>
<td style="text-align:center">数据链路转义</td>
</tr>
<tr>
<td style="text-align:left">0001 0001</td>
<td style="text-align:center">21</td>
<td style="text-align:center">17</td>
<td style="text-align:center">11</td>
<td style="text-align:left">DC1 (device control 1)</td>
<td style="text-align:center">设备控制1</td>
</tr>
<tr>
<td style="text-align:left">0001 0010</td>
<td style="text-align:center">22</td>
<td style="text-align:center">18</td>
<td style="text-align:center">12</td>
<td style="text-align:left">DC2 (device control 2)</td>
<td style="text-align:center">设备控制2</td>
</tr>
<tr>
<td style="text-align:left">0001 0011</td>
<td style="text-align:center">23</td>
<td style="text-align:center">19</td>
<td style="text-align:center">13</td>
<td style="text-align:left">DC3 (device control 3)</td>
<td style="text-align:center">设备控制3</td>
</tr>
<tr>
<td style="text-align:left">0001 0100</td>
<td style="text-align:center">24</td>
<td style="text-align:center">20</td>
<td style="text-align:center">14</td>
<td style="text-align:left">DC4 (device control 4)</td>
<td style="text-align:center">设备控制4</td>
</tr>
<tr>
<td style="text-align:left">0001 0101</td>
<td style="text-align:center">25</td>
<td style="text-align:center">21</td>
<td style="text-align:center">15</td>
<td style="text-align:left">NAK (negative acknowledge)</td>
<td style="text-align:center">拒绝接收</td>
</tr>
<tr>
<td style="text-align:left">0001 0110</td>
<td style="text-align:center">26</td>
<td style="text-align:center">22</td>
<td style="text-align:center">16</td>
<td style="text-align:left">SYN (synchronous idle)</td>
<td style="text-align:center">同步空闲</td>
</tr>
<tr>
<td style="text-align:left">0001 0111</td>
<td style="text-align:center">27</td>
<td style="text-align:center">23</td>
<td style="text-align:center">17</td>
<td style="text-align:left">ETB (end of trans. block)</td>
<td style="text-align:center">结束传输块</td>
</tr>
<tr>
<td style="text-align:left">0001 1000</td>
<td style="text-align:center">30</td>
<td style="text-align:center">24</td>
<td style="text-align:center">18</td>
<td style="text-align:left">CAN (cancel)</td>
<td style="text-align:center">取消</td>
</tr>
<tr>
<td style="text-align:left">0001 1001</td>
<td style="text-align:center">31</td>
<td style="text-align:center">25</td>
<td style="text-align:center">19</td>
<td style="text-align:left">EM (end of medium)</td>
<td style="text-align:center">媒介结束</td>
</tr>
<tr>
<td style="text-align:left">0001 1010</td>
<td style="text-align:center">32</td>
<td style="text-align:center">26</td>
<td style="text-align:center">1A</td>
<td style="text-align:left">SUB (substitute)</td>
<td style="text-align:center">代替</td>
</tr>
<tr>
<td style="text-align:left">0001 1011</td>
<td style="text-align:center">33</td>
<td style="text-align:center">27</td>
<td style="text-align:center">1B</td>
<td style="text-align:left">ESC (escape)</td>
<td style="text-align:center">换码(溢出)</td>
</tr>
<tr>
<td style="text-align:left">0001 1100</td>
<td style="text-align:center">34</td>
<td style="text-align:center">28</td>
<td style="text-align:center">1C</td>
<td style="text-align:left">FS (file separator)</td>
<td style="text-align:center">文件分隔符</td>
</tr>
<tr>
<td style="text-align:left">0001 1101</td>
<td style="text-align:center">35</td>
<td style="text-align:center">29</td>
<td style="text-align:center">1D</td>
<td style="text-align:left">GS (group separator)</td>
<td style="text-align:center">分组符</td>
</tr>
<tr>
<td style="text-align:left">0001 1110</td>
<td style="text-align:center">36</td>
<td style="text-align:center">30</td>
<td style="text-align:center">1E</td>
<td style="text-align:left">RS (record separator)</td>
<td style="text-align:center">记录分隔符</td>
</tr>
<tr>
<td style="text-align:left">0001 1111</td>
<td style="text-align:center">37</td>
<td style="text-align:center">31</td>
<td style="text-align:center">1F</td>
<td style="text-align:left">US (unit separator)</td>
<td style="text-align:center">单元分隔符</td>
</tr>
<tr>
<td style="text-align:left">0010 0000</td>
<td style="text-align:center">40</td>
<td style="text-align:center">32</td>
<td style="text-align:center">20</td>
<td style="text-align:left">(space)</td>
<td style="text-align:center">空格</td>
</tr>
<tr>
<td style="text-align:left">0010 0001</td>
<td style="text-align:center">41</td>
<td style="text-align:center">33</td>
<td style="text-align:center">21</td>
<td style="text-align:left">!</td>
<td style="text-align:center">叹号</td>
</tr>
<tr>
<td style="text-align:left">0010 0010</td>
<td style="text-align:center">42</td>
<td style="text-align:center">34</td>
<td style="text-align:center">22</td>
<td style="text-align:left">“”””</td>
<td style="text-align:center">双引号</td>
</tr>
<tr>
<td style="text-align:left">0010 0011</td>
<td style="text-align:center">43</td>
<td style="text-align:center">35</td>
<td style="text-align:center">23</td>
<td style="text-align:left">#</td>
<td style="text-align:center">井号</td>
</tr>
<tr>
<td style="text-align:left">0010 0100</td>
<td style="text-align:center">44</td>
<td style="text-align:center">36</td>
<td style="text-align:center">24</td>
<td style="text-align:left">$</td>
<td style="text-align:center">美元符</td>
</tr>
<tr>
<td style="text-align:left">0010 0101</td>
<td style="text-align:center">45</td>
<td style="text-align:center">37</td>
<td style="text-align:center">25</td>
<td style="text-align:left">%</td>
<td style="text-align:center">百分号</td>
</tr>
<tr>
<td style="text-align:left">0010 0110</td>
<td style="text-align:center">46</td>
<td style="text-align:center">38</td>
<td style="text-align:center">26</td>
<td style="text-align:left">&amp;</td>
<td style="text-align:center">和号</td>
</tr>
<tr>
<td style="text-align:left">0010 0111</td>
<td style="text-align:center">47</td>
<td style="text-align:center">39</td>
<td style="text-align:center">27</td>
<td style="text-align:left">‘</td>
<td style="text-align:center">闭单引号</td>
</tr>
<tr>
<td style="text-align:left">0010 1000</td>
<td style="text-align:center">50</td>
<td style="text-align:center">40</td>
<td style="text-align:center">28</td>
<td style="text-align:left">(</td>
<td style="text-align:center">开括号</td>
</tr>
<tr>
<td style="text-align:left">0010 1001</td>
<td style="text-align:center">51</td>
<td style="text-align:center">41</td>
<td style="text-align:center">29</td>
<td style="text-align:left">)</td>
<td style="text-align:center">闭括号</td>
</tr>
<tr>
<td style="text-align:left">0010 1010</td>
<td style="text-align:center">52</td>
<td style="text-align:center">42</td>
<td style="text-align:center">2A</td>
<td style="text-align:left">*</td>
<td style="text-align:center">星号</td>
</tr>
<tr>
<td style="text-align:left">0010 1011</td>
<td style="text-align:center">53</td>
<td style="text-align:center">43</td>
<td style="text-align:center">2B</td>
<td style="text-align:left">+</td>
<td style="text-align:center">加号</td>
</tr>
<tr>
<td style="text-align:left">0010 1100</td>
<td style="text-align:center">54</td>
<td style="text-align:center">44</td>
<td style="text-align:center">2C</td>
<td style="text-align:left">“,”</td>
<td style="text-align:center">逗号</td>
</tr>
<tr>
<td style="text-align:left">0010 1101</td>
<td style="text-align:center">55</td>
<td style="text-align:center">45</td>
<td style="text-align:center">2D</td>
<td style="text-align:left">-</td>
<td style="text-align:center">减号/破折号</td>
</tr>
<tr>
<td style="text-align:left">0010 1110</td>
<td style="text-align:center">56</td>
<td style="text-align:center">46</td>
<td style="text-align:center">2E</td>
<td style="text-align:left">.</td>
<td style="text-align:center">句号</td>
</tr>
<tr>
<td style="text-align:left">101111</td>
<td style="text-align:center">57</td>
<td style="text-align:center">47</td>
<td style="text-align:center">2F</td>
<td style="text-align:left">/</td>
<td style="text-align:center">斜杠</td>
</tr>
<tr>
<td style="text-align:left">110000</td>
<td style="text-align:center">60</td>
<td style="text-align:center">48</td>
<td style="text-align:center">30</td>
<td style="text-align:left">0</td>
<td style="text-align:center">数字0</td>
</tr>
<tr>
<td style="text-align:left">110001</td>
<td style="text-align:center">61</td>
<td style="text-align:center">49</td>
<td style="text-align:center">31</td>
<td style="text-align:left">1</td>
<td style="text-align:center">数字1</td>
</tr>
<tr>
<td style="text-align:left">110010</td>
<td style="text-align:center">62</td>
<td style="text-align:center">50</td>
<td style="text-align:center">32</td>
<td style="text-align:left">2</td>
<td style="text-align:center">数字2</td>
</tr>
<tr>
<td style="text-align:left">110011</td>
<td style="text-align:center">63</td>
<td style="text-align:center">51</td>
<td style="text-align:center">33</td>
<td style="text-align:left">3</td>
<td style="text-align:center">数字3</td>
</tr>
<tr>
<td style="text-align:left">110100</td>
<td style="text-align:center">64</td>
<td style="text-align:center">52</td>
<td style="text-align:center">34</td>
<td style="text-align:left">4</td>
<td style="text-align:center">数字4</td>
</tr>
<tr>
<td style="text-align:left">110101</td>
<td style="text-align:center">65</td>
<td style="text-align:center">53</td>
<td style="text-align:center">35</td>
<td style="text-align:left">5</td>
<td style="text-align:center">数字5</td>
</tr>
<tr>
<td style="text-align:left">110110</td>
<td style="text-align:center">66</td>
<td style="text-align:center">54</td>
<td style="text-align:center">36</td>
<td style="text-align:left">6</td>
<td style="text-align:center">数字6</td>
</tr>
<tr>
<td style="text-align:left">110111</td>
<td style="text-align:center">67</td>
<td style="text-align:center">55</td>
<td style="text-align:center">37</td>
<td style="text-align:left">7</td>
<td style="text-align:center">数字7</td>
</tr>
<tr>
<td style="text-align:left">111000</td>
<td style="text-align:center">70</td>
<td style="text-align:center">56</td>
<td style="text-align:center">38</td>
<td style="text-align:left">8</td>
<td style="text-align:center">数字8</td>
</tr>
<tr>
<td style="text-align:left">111001</td>
<td style="text-align:center">71</td>
<td style="text-align:center">57</td>
<td style="text-align:center">39</td>
<td style="text-align:left">9</td>
<td style="text-align:center">数字9</td>
</tr>
<tr>
<td style="text-align:left">111010</td>
<td style="text-align:center">72</td>
<td style="text-align:center">58</td>
<td style="text-align:center">3A</td>
<td style="text-align:left">:</td>
<td style="text-align:center">冒号</td>
</tr>
<tr>
<td style="text-align:left">111011</td>
<td style="text-align:center">73</td>
<td style="text-align:center">59</td>
<td style="text-align:center">3B</td>
<td style="text-align:left">;</td>
<td style="text-align:center">分号</td>
</tr>
<tr>
<td style="text-align:left">111100</td>
<td style="text-align:center">74</td>
<td style="text-align:center">60</td>
<td style="text-align:center">3C</td>
<td style="text-align:left">&lt;</td>
<td style="text-align:center">小于</td>
</tr>
<tr>
<td style="text-align:left">111101</td>
<td style="text-align:center">75</td>
<td style="text-align:center">61</td>
<td style="text-align:center">3D</td>
<td style="text-align:left">=</td>
<td style="text-align:center">等号</td>
</tr>
<tr>
<td style="text-align:left">111110</td>
<td style="text-align:center">76</td>
<td style="text-align:center">62</td>
<td style="text-align:center">3E</td>
<td style="text-align:left">&gt;</td>
<td style="text-align:center">大于</td>
</tr>
<tr>
<td style="text-align:left">111111</td>
<td style="text-align:center">77</td>
<td style="text-align:center">63</td>
<td style="text-align:center">3F</td>
<td style="text-align:left">?</td>
<td style="text-align:center">问号</td>
</tr>
<tr>
<td style="text-align:left">1000000</td>
<td style="text-align:center">100</td>
<td style="text-align:center">64</td>
<td style="text-align:center">40</td>
<td style="text-align:left">@</td>
<td style="text-align:center">电子邮件符号</td>
</tr>
<tr>
<td style="text-align:left">1000001</td>
<td style="text-align:center">101</td>
<td style="text-align:center">65</td>
<td style="text-align:center">41</td>
<td style="text-align:left">A</td>
<td style="text-align:center">大写字母A</td>
</tr>
<tr>
<td style="text-align:left">1000010</td>
<td style="text-align:center">102</td>
<td style="text-align:center">66</td>
<td style="text-align:center">42</td>
<td style="text-align:left">B</td>
<td style="text-align:center">大写字母B</td>
</tr>
<tr>
<td style="text-align:left">1000011</td>
<td style="text-align:center">103</td>
<td style="text-align:center">67</td>
<td style="text-align:center">43</td>
<td style="text-align:left">C</td>
<td style="text-align:center">大写字母C</td>
</tr>
<tr>
<td style="text-align:left">1000100</td>
<td style="text-align:center">104</td>
<td style="text-align:center">68</td>
<td style="text-align:center">44</td>
<td style="text-align:left">D</td>
<td style="text-align:center">大写字母D</td>
</tr>
<tr>
<td style="text-align:left">1000101</td>
<td style="text-align:center">105</td>
<td style="text-align:center">69</td>
<td style="text-align:center">45</td>
<td style="text-align:left">E</td>
<td style="text-align:center">大写字母E</td>
</tr>
<tr>
<td style="text-align:left">1000110</td>
<td style="text-align:center">106</td>
<td style="text-align:center">70</td>
<td style="text-align:center">46</td>
<td style="text-align:left">F</td>
<td style="text-align:center">大写字母F</td>
</tr>
<tr>
<td style="text-align:left">1000111</td>
<td style="text-align:center">107</td>
<td style="text-align:center">71</td>
<td style="text-align:center">47</td>
<td style="text-align:left">G</td>
<td style="text-align:center">大写字母G</td>
</tr>
<tr>
<td style="text-align:left">1001000</td>
<td style="text-align:center">110</td>
<td style="text-align:center">72</td>
<td style="text-align:center">48</td>
<td style="text-align:left">H</td>
<td style="text-align:center">大写字母H</td>
</tr>
<tr>
<td style="text-align:left">1001001</td>
<td style="text-align:center">111</td>
<td style="text-align:center">73</td>
<td style="text-align:center">49</td>
<td style="text-align:left">I</td>
<td style="text-align:center">大写字母I</td>
</tr>
<tr>
<td style="text-align:left">1001010</td>
<td style="text-align:center">112</td>
<td style="text-align:center">74</td>
<td style="text-align:center">4A</td>
<td style="text-align:left">J</td>
<td style="text-align:center">大写字母J</td>
</tr>
<tr>
<td style="text-align:left">1001011</td>
<td style="text-align:center">113</td>
<td style="text-align:center">75</td>
<td style="text-align:center">4B</td>
<td style="text-align:left">K</td>
<td style="text-align:center">大写字母K</td>
</tr>
<tr>
<td style="text-align:left">1001100</td>
<td style="text-align:center">114</td>
<td style="text-align:center">76</td>
<td style="text-align:center">4C</td>
<td style="text-align:left">L</td>
<td style="text-align:center">大写字母L</td>
</tr>
<tr>
<td style="text-align:left">1001101</td>
<td style="text-align:center">115</td>
<td style="text-align:center">77</td>
<td style="text-align:center">4D</td>
<td style="text-align:left">M</td>
<td style="text-align:center">大写字母M</td>
</tr>
<tr>
<td style="text-align:left">1001110</td>
<td style="text-align:center">116</td>
<td style="text-align:center">78</td>
<td style="text-align:center">4E</td>
<td style="text-align:left">N</td>
<td style="text-align:center">大写字母N</td>
</tr>
<tr>
<td style="text-align:left">1001111</td>
<td style="text-align:center">117</td>
<td style="text-align:center">79</td>
<td style="text-align:center">4F</td>
<td style="text-align:left">O</td>
<td style="text-align:center">大写字母O</td>
</tr>
<tr>
<td style="text-align:left">1010000</td>
<td style="text-align:center">120</td>
<td style="text-align:center">80</td>
<td style="text-align:center">50</td>
<td style="text-align:left">P</td>
<td style="text-align:center">大写字母P</td>
</tr>
<tr>
<td style="text-align:left">1010001</td>
<td style="text-align:center">121</td>
<td style="text-align:center">81</td>
<td style="text-align:center">51</td>
<td style="text-align:left">Q</td>
<td style="text-align:center">大写字母Q</td>
</tr>
<tr>
<td style="text-align:left">1010010</td>
<td style="text-align:center">122</td>
<td style="text-align:center">82</td>
<td style="text-align:center">52</td>
<td style="text-align:left">R</td>
<td style="text-align:center">大写字母R</td>
</tr>
<tr>
<td style="text-align:left">1010011</td>
<td style="text-align:center">123</td>
<td style="text-align:center">83</td>
<td style="text-align:center">53</td>
<td style="text-align:left">S</td>
<td style="text-align:center">大写字母S</td>
</tr>
<tr>
<td style="text-align:left">1010100</td>
<td style="text-align:center">124</td>
<td style="text-align:center">84</td>
<td style="text-align:center">54</td>
<td style="text-align:left">T</td>
<td style="text-align:center">大写字母T</td>
</tr>
<tr>
<td style="text-align:left">1010101</td>
<td style="text-align:center">125</td>
<td style="text-align:center">85</td>
<td style="text-align:center">55</td>
<td style="text-align:left">U</td>
<td style="text-align:center">大写字母U</td>
</tr>
<tr>
<td style="text-align:left">1010110</td>
<td style="text-align:center">126</td>
<td style="text-align:center">86</td>
<td style="text-align:center">56</td>
<td style="text-align:left">V</td>
<td style="text-align:center">大写字母V</td>
</tr>
<tr>
<td style="text-align:left">1010111</td>
<td style="text-align:center">127</td>
<td style="text-align:center">87</td>
<td style="text-align:center">57</td>
<td style="text-align:left">W</td>
<td style="text-align:center">大写字母W</td>
</tr>
<tr>
<td style="text-align:left">1011000</td>
<td style="text-align:center">130</td>
<td style="text-align:center">88</td>
<td style="text-align:center">58</td>
<td style="text-align:left">X</td>
<td style="text-align:center">大写字母X</td>
</tr>
<tr>
<td style="text-align:left">1011001</td>
<td style="text-align:center">131</td>
<td style="text-align:center">89</td>
<td style="text-align:center">59</td>
<td style="text-align:left">Y</td>
<td style="text-align:center">大写字母Y</td>
</tr>
<tr>
<td style="text-align:left">1011010</td>
<td style="text-align:center">132</td>
<td style="text-align:center">90</td>
<td style="text-align:center">5A</td>
<td style="text-align:left">Z</td>
<td style="text-align:center">大写字母Z</td>
</tr>
<tr>
<td style="text-align:left">1011011</td>
<td style="text-align:center">133</td>
<td style="text-align:center">91</td>
<td style="text-align:center">5B</td>
<td style="text-align:left">[</td>
<td style="text-align:center">开方括号</td>
</tr>
<tr>
<td style="text-align:left">1011100</td>
<td style="text-align:center">134</td>
<td style="text-align:center">92</td>
<td style="text-align:center">5C</td>
<td style="text-align:left">\</td>
<td style="text-align:center">反斜杠</td>
</tr>
<tr>
<td style="text-align:left">1011101</td>
<td style="text-align:center">135</td>
<td style="text-align:center">93</td>
<td style="text-align:center">5D</td>
<td style="text-align:left">]</td>
<td style="text-align:center">闭方括号</td>
</tr>
<tr>
<td style="text-align:left">1011110</td>
<td style="text-align:center">136</td>
<td style="text-align:center">94</td>
<td style="text-align:center">5E</td>
<td style="text-align:left">^</td>
<td style="text-align:center">脱字符</td>
</tr>
<tr>
<td style="text-align:left">1011111</td>
<td style="text-align:center">137</td>
<td style="text-align:center">95</td>
<td style="text-align:center">5F</td>
<td style="text-align:left">_</td>
<td style="text-align:center">下划线</td>
</tr>
<tr>
<td style="text-align:left">1100000</td>
<td style="text-align:center">140</td>
<td style="text-align:center">96</td>
<td style="text-align:center">60</td>
<td style="text-align:left">`</td>
<td style="text-align:center">开单引号</td>
</tr>
<tr>
<td style="text-align:left">1100001</td>
<td style="text-align:center">141</td>
<td style="text-align:center">97</td>
<td style="text-align:center">61</td>
<td style="text-align:left">a</td>
<td style="text-align:center">小写字母a</td>
</tr>
<tr>
<td style="text-align:left">1100010</td>
<td style="text-align:center">142</td>
<td style="text-align:center">98</td>
<td style="text-align:center">62</td>
<td style="text-align:left">b</td>
<td style="text-align:center">小写字母b</td>
</tr>
<tr>
<td style="text-align:left">1100011</td>
<td style="text-align:center">143</td>
<td style="text-align:center">99</td>
<td style="text-align:center">63</td>
<td style="text-align:left">c</td>
<td style="text-align:center">小写字母c</td>
</tr>
<tr>
<td style="text-align:left">1100100</td>
<td style="text-align:center">144</td>
<td style="text-align:center">100</td>
<td style="text-align:center">64</td>
<td style="text-align:left">d</td>
<td style="text-align:center">小写字母d</td>
</tr>
<tr>
<td style="text-align:left">1100101</td>
<td style="text-align:center">145</td>
<td style="text-align:center">101</td>
<td style="text-align:center">65</td>
<td style="text-align:left">e</td>
<td style="text-align:center">小写字母e</td>
</tr>
<tr>
<td style="text-align:left">1100110</td>
<td style="text-align:center">146</td>
<td style="text-align:center">102</td>
<td style="text-align:center">66</td>
<td style="text-align:left">f</td>
<td style="text-align:center">小写字母f</td>
</tr>
<tr>
<td style="text-align:left">1100111</td>
<td style="text-align:center">147</td>
<td style="text-align:center">103</td>
<td style="text-align:center">67</td>
<td style="text-align:left">g</td>
<td style="text-align:center">小写字母g</td>
</tr>
<tr>
<td style="text-align:left">1101000</td>
<td style="text-align:center">150</td>
<td style="text-align:center">104</td>
<td style="text-align:center">68</td>
<td style="text-align:left">h</td>
<td style="text-align:center">小写字母h</td>
</tr>
<tr>
<td style="text-align:left">1101001</td>
<td style="text-align:center">151</td>
<td style="text-align:center">105</td>
<td style="text-align:center">69</td>
<td style="text-align:left">i</td>
<td style="text-align:center">小写字母i</td>
</tr>
<tr>
<td style="text-align:left">1101010</td>
<td style="text-align:center">152</td>
<td style="text-align:center">106</td>
<td style="text-align:center">6A</td>
<td style="text-align:left">j</td>
<td style="text-align:center">小写字母j</td>
</tr>
<tr>
<td style="text-align:left">1101011</td>
<td style="text-align:center">153</td>
<td style="text-align:center">107</td>
<td style="text-align:center">6B</td>
<td style="text-align:left">k</td>
<td style="text-align:center">小写字母k</td>
</tr>
<tr>
<td style="text-align:left">1101100</td>
<td style="text-align:center">154</td>
<td style="text-align:center">108</td>
<td style="text-align:center">6C</td>
<td style="text-align:left">l</td>
<td style="text-align:center">小写字母l</td>
</tr>
<tr>
<td style="text-align:left">1101101</td>
<td style="text-align:center">155</td>
<td style="text-align:center">109</td>
<td style="text-align:center">6D</td>
<td style="text-align:left">m</td>
<td style="text-align:center">小写字母m</td>
</tr>
<tr>
<td style="text-align:left">1101110</td>
<td style="text-align:center">156</td>
<td style="text-align:center">110</td>
<td style="text-align:center">6E</td>
<td style="text-align:left">n</td>
<td style="text-align:center">小写字母n</td>
</tr>
<tr>
<td style="text-align:left">1101111</td>
<td style="text-align:center">157</td>
<td style="text-align:center">111</td>
<td style="text-align:center">6F</td>
<td style="text-align:left">o</td>
<td style="text-align:center">小写字母o</td>
</tr>
<tr>
<td style="text-align:left">1110000</td>
<td style="text-align:center">160</td>
<td style="text-align:center">112</td>
<td style="text-align:center">70</td>
<td style="text-align:left">p</td>
<td style="text-align:center">小写字母p</td>
</tr>
<tr>
<td style="text-align:left">1110001</td>
<td style="text-align:center">161</td>
<td style="text-align:center">113</td>
<td style="text-align:center">71</td>
<td style="text-align:left">q</td>
<td style="text-align:center">小写字母q</td>
</tr>
<tr>
<td style="text-align:left">1110010</td>
<td style="text-align:center">162</td>
<td style="text-align:center">114</td>
<td style="text-align:center">72</td>
<td style="text-align:left">r</td>
<td style="text-align:center">小写字母r</td>
</tr>
<tr>
<td style="text-align:left">1110011</td>
<td style="text-align:center">163</td>
<td style="text-align:center">115</td>
<td style="text-align:center">73</td>
<td style="text-align:left">s</td>
<td style="text-align:center">小写字母s</td>
</tr>
<tr>
<td style="text-align:left">1110100</td>
<td style="text-align:center">164</td>
<td style="text-align:center">116</td>
<td style="text-align:center">74</td>
<td style="text-align:left">t</td>
<td style="text-align:center">小写字母t</td>
</tr>
<tr>
<td style="text-align:left">1110101</td>
<td style="text-align:center">165</td>
<td style="text-align:center">117</td>
<td style="text-align:center">75</td>
<td style="text-align:left">u</td>
<td style="text-align:center">小写字母u</td>
</tr>
<tr>
<td style="text-align:left">1110110</td>
<td style="text-align:center">166</td>
<td style="text-align:center">118</td>
<td style="text-align:center">76</td>
<td style="text-align:left">v</td>
<td style="text-align:center">小写字母v</td>
</tr>
<tr>
<td style="text-align:left">1110111</td>
<td style="text-align:center">167</td>
<td style="text-align:center">119</td>
<td style="text-align:center">77</td>
<td style="text-align:left">w</td>
<td style="text-align:center">小写字母w</td>
</tr>
<tr>
<td style="text-align:left">1111000</td>
<td style="text-align:center">170</td>
<td style="text-align:center">120</td>
<td style="text-align:center">78</td>
<td style="text-align:left">x</td>
<td style="text-align:center">小写字母x</td>
</tr>
<tr>
<td style="text-align:left">1111001</td>
<td style="text-align:center">171</td>
<td style="text-align:center">121</td>
<td style="text-align:center">79</td>
<td style="text-align:left">y</td>
<td style="text-align:center">小写字母y</td>
</tr>
<tr>
<td style="text-align:left">1111010</td>
<td style="text-align:center">172</td>
<td style="text-align:center">122</td>
<td style="text-align:center">7A</td>
<td style="text-align:left">z</td>
<td style="text-align:center">小写字母z</td>
</tr>
<tr>
<td style="text-align:left">1111011</td>
<td style="text-align:center">173</td>
<td style="text-align:center">123</td>
<td style="text-align:center">7B</td>
<td style="text-align:left">{</td>
<td style="text-align:center">开花括号</td>
</tr>
<tr>
<td style="text-align:left">1111100</td>
<td style="text-align:center">174</td>
<td style="text-align:center">124</td>
<td style="text-align:center">7C</td>
<td style="text-align:left">&#124;</td>
<td style="text-align:center">垂线</td>
</tr>
<tr>
<td style="text-align:left">1111101</td>
<td style="text-align:center">175</td>
<td style="text-align:center">125</td>
<td style="text-align:center">7D</td>
<td style="text-align:left">}</td>
<td style="text-align:center">闭花括号</td>
</tr>
<tr>
<td style="text-align:left">1111110</td>
<td style="text-align:center">176</td>
<td style="text-align:center">126</td>
<td style="text-align:center">7E</td>
<td style="text-align:left">~</td>
<td style="text-align:center">波浪号</td>
</tr>
<tr>
<td style="text-align:left">1111111</td>
<td style="text-align:center">177</td>
<td style="text-align:center">127</td>
<td style="text-align:center">7F</td>
<td style="text-align:left">DEL (delete)</td>
<td style="text-align:center">删除</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习 Python Hex Octal </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[学习bs4模块]]></title>
      <url>/2017/11/29/python/bs4/learn_bs4/</url>
      <content type="html"><![CDATA[<h1 id="学习bs4模块"><a href="#学习bs4模块" class="headerlink" title="学习bs4模块"></a>学习bs4模块</h1><blockquote>
<p>直接在官方网站上面学习</p>
</blockquote>
<hr>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>bs4是一个格式化读取xml，html文档的库<br>可以使xml、html按照标签的形式操作，具体是将HTML文档转换成一个复杂的树形结构。<br>官方推荐lxml来解析HTML<br>所有节点对象可以归纳为4种: Tag , NavigableString , BeautifulSoup , Comment .</p>
<p>简单使用操作</p>
<pre><code>from bs4 import BeautifulSoup
html_doc = &#39;&#39;
soup = BeautifulSoup(html_doc, &#39;html.parser&#39;)
print(soup.prettify())  #美化输出，格式化缩进。
</code></pre><h2 id="一般属性"><a href="#一般属性" class="headerlink" title="一般属性"></a>一般属性</h2><ul>
<li><code>soup.title</code>：获取页面的标题，包含标签</li>
<li><code>soup.title.name</code>：获取页面标题标签的内容</li>
<li><code>soup.title.string</code>：获取页面标题的内容</li>
<li><code>soup.title.parent.name</code>：父标签名字</li>
<li><code>soup.p</code>：<code>p</code>是标签名字</li>
<li><code>soup.p[&#39;class&#39;]</code>：第一个匹配p的标签，成员class</li>
<li><code>soup.a</code>：同上</li>
</ul>
</blockquote>
<h2 id="一般方法"><a href="#一般方法" class="headerlink" title="一般方法"></a>一般方法</h2><blockquote>
<ul>
<li><code>soup.find_all(&#39;a&#39;)</code>：找到所以的<code>a</code>标签</li>
</ul>
</blockquote>
<h3 id="查找所有的a标签"><a href="#查找所有的a标签" class="headerlink" title="查找所有的a标签"></a>查找所有的a标签</h3><pre><code>for link in soup.find_all(&#39;a&#39;):
    print(link.get(&#39;href&#39;))
    # http://example.com/elsie
    # http://example.com/lacie
    # http://example.com/tillie
</code></pre><blockquote>
<ul>
<li><code>soup.get_text()</code>：拿到文档中所有的文字内容，实际测试新浪的首页存在问题，使用html5lib也一致。</li>
</ul>
</blockquote>
<h2 id="对象的种类"><a href="#对象的种类" class="headerlink" title="对象的种类"></a>对象的种类</h2><h3 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h3><blockquote>
<p><code>Tag</code>对象和XML或HTML原生文档中的tag相同</p>
</blockquote>
<h4 id="Tag重要的属性"><a href="#Tag重要的属性" class="headerlink" title="Tag重要的属性"></a>Tag重要的属性</h4><blockquote>
<ul>
<li><p><code>name</code><br>每个Tag都有自己的名字，通过name属性来获取，比如<title>xxx</title>，Tag名称就是title<br>如果改变了某个tag的名称，那么将影响当前生成的hml对象文档<br><code>tag.name = &#39;xxx&#39;</code></p>
</li>
<li><p><code>Attributes</code><br>一个<code>Tag</code>可能存在属性，属性的操作和字典相同<br>可以直接使用<code>attrs</code>获取全部属性<br>tag的属性可以添加删除或者修改。操作和字典一致。</p>
</li>
</ul>
</blockquote>
<h4 id="多值属性"><a href="#多值属性" class="headerlink" title="多值属性"></a>多值属性</h4><blockquote>
<p>一个属性可能有多个值，这里返回其列表。<br><code>&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;</code>：将会返回body和strikeout的列表<br>如果存在多个值，但是HTML定义中并没有定义为多值属性，那么还是返回字符串<br>并且可以传入列表以修改多值属性，传入列表为多值。<br>xml中不包含多值</p>
</blockquote>
<h4 id="可以遍历的字符串"><a href="#可以遍历的字符串" class="headerlink" title="可以遍历的字符串"></a>可以遍历的字符串</h4><blockquote>
<p>字符串常被包含在tag内.Beautiful Soup用 <code>NavigableString</code> 类来包装tag中的字符串<br>节点下的字符串不可以编辑，但是可以替换，使用replace_with(‘xxx’)<br>字符串不支持：contents，string属性或find()方法<br>需要在此之外使用字符串，使用unicode将其转换为普通的Unicode字符串，减少内存占用。</p>
</blockquote>
<h5 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h5><blockquote>
<p><code>soup.body.b</code>：body节点下的b节点</p>
<ul>
<li><code>tag.contents</code>：可以将节点下的子节点以列表方式输出。</li>
<li><code>tag.children</code>：子节点生成器，</li>
<li><code>descendants</code>：后裔，多所有的子孙节点递归循环，这样会将string也单独提取出来</li>
<li>节点下的<code>string</code>：如果节点下面存在子节点，并且子节点不是内容节点，那么返回None</li>
<li><code>strings and stripped_strings</code>：解决了上面的问题，使用这个将打印节点下的所以字符串，其中stripped_strings去除空格</li>
</ul>
</blockquote>
<h3 id="BeautifulSoup对象"><a href="#BeautifulSoup对象" class="headerlink" title="BeautifulSoup对象"></a>BeautifulSoup对象</h3><blockquote>
<p>表示文档的全部内容大部分时候可以将它当做<code>Tag</code>对象。</p>
</blockquote>
<h4 id="搜索文档树"><a href="#搜索文档树" class="headerlink" title="搜索文档树"></a>搜索文档树</h4><blockquote>
<p>很多搜索方法，这里解释：<code>find()</code>和<code>find_all()</code><br>其它操作方法类似</p>
</blockquote>
<h5 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h5><blockquote>
<ul>
<li>字符串<br>使用字符串来过滤查找，比如<code>soup.find_all(&#39;a&#39;)</code>来找到<code>a</code>标签</li>
<li>正则表达式<br>支持正则表达式，比如：<code>soup.find_all(re.compile(&quot;^b&quot;))</code></li>
<li>列表参数<br>传入列表参数：<code>[&#39;a&#39;, &#39;b&#39;]</code> 找出<code>a</code> <code>b</code>的标签</li>
<li>True<br>传入<code>True</code>值，那么会找到所有节点，但是没有字符串。</li>
<li>方法<br>如果没有合适的过滤器，那么可以传入方法，方法接收一个参数<br>```<br>def has_class_but_no_id(tag):<br>  return tag.has_attr(‘class’) and not tag.has_attr(‘id’)</li>
</ul>
</blockquote>
<p>def not_lacie(href):<br>        return href and not re.compile(“lacie”).search(href)<br>soup.find_all(href=not_lacie)</p>
<p>from bs4 import NavigableString<br>def surrounded_by_strings(tag):<br>    return (isinstance(tag.next_element, NavigableString)<br>            and isinstance(tag.previous_element, NavigableString))</p>
<pre><code>
&gt; 具体参数 find_all( name , attrs , recursive , string , **kwargs )
&gt; * name 用来查找所以tag
&gt; * attrs 传入字典
&gt; * recursive 传入False只便利直接的子节点
&gt; * string 查找内容，页面上的文本内容，可以传入文字，列表，正则表达式，True
&gt; * **kwargs 传入关键字参数 比如：id=&#39;xxx&#39;  同时可以过滤多个这样的属性
&gt; * limit 限制查找的数量
&gt; 有些tag属性在搜索不能使用,比如HTML5中的 data-* 属性:
</code></pre><p>data_soup = BeautifulSoup(‘<div data-foo="value">foo!</div>‘)<br>data_soup.find_all(data-foo=”value”)<br>SyntaxError: keyword can’t be an expression</p>
<pre><code>&gt; 但是可以通过 find_all() 方法的 attrs 参数定义一个字典参数来搜索包含特殊属性的tag:
</code></pre><p>data_soup.find_all(attrs={“data-foo”: “value”})<br>[<div data-foo="value">foo!</div>]</p>
<pre><code>&gt; 但标识CSS类名的关键字 class 在Python中是保留字,使用 class 做参数会导致语法错误.从Beautiful Soup的4.1.1版本开始,可以通过 class_ 参数搜索有指定CSS类名的tag:


### 子节点
&gt; 一个节点可能包含一个或者多个子节点
&gt; * contents and children：返回子节点的列表，后者返回迭代器。
&gt; * descendants：后裔，会将字符串也打印出来。
&gt; * srting：得到节点下的NavigableString对象
&gt; * strings and stripped_strings：得到节点下的所以NString对象，后者会去除空格和空行。

### 父节点
&gt; 每个节点或者字符串都有父节点
&gt; * parent：得到直接父节点
&gt; * parents：得到所有的父节点

### 兄弟节点
&gt; * next_sipling and previous_sibling：类似遍历兄弟节点
&gt; * next_siplings and previous_siblings：当前节点之前或者之后的所有兄弟节点迭代输出

### 回退和前进
&gt; * next_element and previous_element：返回当前节点上一个或者下一个被解析对象
&gt; * next_elements and previous_elements：对应的就是前后所有被解析的对象，就像HTML对象正在被解析一样

### 像调用 find_all() 一样调用tag
</code></pre><p>soup.find_all(“a”)<br>soup(“a”)</p>
<pre><code>&gt; 这两行是等价的

### find()
&gt; find_all是得到所有的结果，有时候我们只需要一个结果，那么直接使用find就行。
&gt; find_all 加上参数limit = 1，也可以实现，但是返回的结果是列表
&gt; find没有找到结果的时候返回`None`
&gt; find方法多次调用：
</code></pre><p>html.find(‘head’).find(‘title’)</p>
<pre><code>### find_parents() 和 find_parent()
&gt; 搜索当前节点的父节点
</code></pre><p>s = html.find(string=’Lacie’) # 找到字符串Lacie<br>s.find_parents(‘a’) # 字符串节点的父节点</p>
<pre><code>&gt; 其实方法就是使用了parent和parents属性进行迭代搜索的

### find_next_siblings() 和 find_next_sibling()
&gt; 通过next_siblings属性对当前tag之后的兄弟节点进行迭代搜索
</code></pre><blockquote>
<blockquote>
<blockquote>
<p>first_link = html.a<br>first_link<br><a class="sister" href="http://example.com/elsie" id="link1" target="_blank" rel="external">Elsie</a><br>first_link.find_next_siblings()<br>[<a class="sister" href="http://example.com/lacie" id="link2" target="_blank" rel="external">Lacie</a>, <a clas="" s="sister" href="http://example.com/tillie" id="link3" target="_blank" rel="external">Tillie</a>]<br>```</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="find-previous-siblings-和-find-previous-sibling"><a href="#find-previous-siblings-和-find-previous-sibling" class="headerlink" title="find_previous_siblings() 和 find_previous_sibling()"></a>find_previous_siblings() 和 find_previous_sibling()</h3><blockquote>
<p>和上面类似</p>
</blockquote>
<h3 id="find-all-next-和-find-next"><a href="#find-all-next-和-find-next" class="headerlink" title="find_all_next() 和 find_next()"></a>find_all_next() 和 find_next()</h3><blockquote>
<p>通过next_elements属性对当前tag进行迭代搜索</p>
<pre><code>&gt;&gt; f_link = html.a
&gt;&gt; f_link
&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;
&gt;&gt; f_link.find_all_next(&#39;a&#39;)
[&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;, &lt;a clas
s=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]
&gt;&gt; f_link.find_all_next(string=True)
[&#39;Elsie&#39;, &#39;,\n&#39;, &#39;Lacie&#39;, &#39; and\n&#39;, &#39;Tillie&#39;, &#39;;\nand they lived at the bottom o
f a well.&#39;, &#39;\n&#39;, &#39;...&#39;, &#39;\n&#39;]
</code></pre></blockquote>
<h3 id="find-all-previous-和-find-previous"><a href="#find-all-previous-和-find-previous" class="headerlink" title="find_all_previous() 和 find_previous()"></a>find_all_previous() 和 find_previous()</h3><blockquote>
<p>通过previous_element对当前tag进行迭代搜索</p>
<pre><code>&gt;&gt; f_link = html.a
&gt;&gt; f_link
&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;
&gt;&gt; f_link.find_all_previous(&#39;title&#39;)
[&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]
</code></pre></blockquote>
<h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><blockquote>
<p>bs4支持大部分的CSS选择器：<a href="https://www.w3.org/TR/CSS2/selector.html" title="CSS Selector" target="_blank" rel="external">CSS Selector</a> <a href="http://www.w3school.com.cn/cssref/css_selectors.asp" title="CSS 选择器" target="_blank" rel="external">w3school</a></p>
</blockquote>
<blockquote>
<p>在 <code>Tag</code> 或 <code>BeautifulSoup</code> 对象的 <code>.select()</code> 方法中传入字符串参数, 即可使用CSS选择器的语法找到tag:</p>
</blockquote>
<pre><code>soup.select(&quot;title&quot;)
# [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]

soup.select(&quot;p nth-of-type(3)&quot;)
# [&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;]
</code></pre><blockquote>
<p>不是很懂这个选择器，大概看起来可以根据CSS选择器文档来书写。</p>
</blockquote>
<h3 id="修改文档树"><a href="#修改文档树" class="headerlink" title="修改文档树"></a>修改文档树</h3><h4 id="修改tag的名称和属性"><a href="#修改tag的名称和属性" class="headerlink" title="修改tag的名称和属性"></a>修改tag的名称和属性</h4><blockquote>
<p><code>tag.name = &#39;blockquote&#39;</code><br><code>tag[&#39;class&#39;] = &#39;modify value&#39;</code><br><code>tag[&#39;id&#39;] = &#39;newid&#39;</code></p>
<h4 id="修改-string"><a href="#修改-string" class="headerlink" title="修改 .string"></a>修改 <code>.string</code></h4><p><code>tag.string = &#39;New link text&#39;</code></p>
<h4 id="append"><a href="#append" class="headerlink" title="append()"></a><code>append()</code></h4><p>在.string上面追加内容</p>
<h4 id="NavigableString-和-new-tag"><a href="#NavigableString-和-new-tag" class="headerlink" title="NavigableString() 和 .new_tag()"></a><code>NavigableString() 和 .new_tag()</code></h4><p><code>NavigableString()</code> 是构造一个字符串，然后将其放入需要修改的地方。<br><code>new_string = NavigableString(&#39;Hello&#39;)</code><br><code>html.b.append(new_string)</code><br><code>from bs4 import Comment</code><br><code>new_comment = html.new_string(&#39;Nice to see you&#39;, Comment)</code><br><code>html.b.append(new_comment)</code><br>创建一个Tag的最好的方法是调用工厂方法，new_tag()<br><code>new_tag = html.new_tag(&#39;a&#39;, href=&#39;test&#39;)</code><br><code>html.b.append(new_tag)</code> # 在b标签的下面追加一个tag <code>a</code></p>
<h4 id="insert"><a href="#insert" class="headerlink" title="insert()"></a><code>insert()</code></h4><p>选择插入的位置，这个和append类似，不过可以选择位置插入。</p>
<h4 id="insert-before-insert-after"><a href="#insert-before-insert-after" class="headerlink" title="insert_before, insert_after"></a>insert_before, insert_after</h4><p>看名字就知道，这是在当前tag或者string后边插入对象。<br>定位到tag或者string，然后使用方法进行插入。</p>
<h4 id="‘clear-’"><a href="#‘clear-’" class="headerlink" title="‘clear()’"></a>‘clear()’</h4><p>移除tag下的内容</p>
<h4 id="‘extract-’"><a href="#‘extract-’" class="headerlink" title="‘extract()’"></a>‘extract()’</h4><p>移除当前tag，将tag移除。<br>该方法移除tag的时候，会返回移除的tag信息</p>
</blockquote>
<pre><code>&gt;&gt;&gt; html = &#39;&lt;h1&gt;&lt;a href=&quot;www.text.com&quot;&gt;wwwww&lt;/a&gt;&lt;/h1&gt;&#39;
&gt;&gt;&gt; h = bs(html, &#39;lxml&#39;)
&gt;&gt;&gt; h
&lt;html&gt;&lt;body&gt;&lt;h1&gt;&lt;a href=&quot;www.text.com&quot;&gt;wwwww&lt;/a&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;
&gt;&gt;&gt; h.body.a
&lt;a href=&quot;www.text.com&quot;&gt;wwwww&lt;/a&gt;
&gt;&gt;&gt; tag = h.body.a.extract()
&gt;&gt;&gt; tag
&lt;a href=&quot;www.text.com&quot;&gt;wwwww&lt;/a&gt;
&gt;&gt;&gt; h
&lt;html&gt;&lt;body&gt;&lt;h1&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;
&gt;&gt;&gt;
</code></pre><h4 id="‘decompose-’"><a href="#‘decompose-’" class="headerlink" title="‘decompose()’"></a>‘decompose()’</h4><blockquote>
<p>这个更为激进，移除tag之后，不返回。</p>
<h4 id="‘replace-with-’"><a href="#‘replace-with-’" class="headerlink" title="‘replace_with()’"></a>‘replace_with()’</h4><p>移除内容并替换新的tag或者string<br>return：方法返回被替换的内容</p>
<h4 id="‘wrap-’"><a href="#‘wrap-’" class="headerlink" title="‘wrap()’"></a>‘wrap()’</h4><p>对元素进行包装，并且返回包装后的内容。</p>
<pre><code>&gt;&gt; tag = &lt;a&gt;xxx&lt;/a&gt;
&gt;&gt; wrap_tag = BeautifulSoup.new_tag(&#39;p&#39;)
&gt;&gt; tag.wrap(wrap_tag)
&gt;&gt; tag
&lt;p&gt;&lt;a&gt;xxx&lt;/a&gt;&lt;/p&gt;
</code></pre></blockquote>
<h4 id="‘unwrap-’"><a href="#‘unwrap-’" class="headerlink" title="‘unwrap()’"></a>‘unwrap()’</h4><blockquote>
<p>和wrap的方法相反<br>```<br>markup = ‘<a href="http://example.com/" target="_blank" rel="external">I linked to <i>example.com</i></a>‘<br>soup = BeautifulSoup(markup)<br>a_tag = soup.a</p>
</blockquote>
<p>a_tag.i.unwrap()<br>a_tag</p>
<h1 id="I-linked-to-example-com"><a href="#I-linked-to-example-com" class="headerlink" title="I linked to example.com"></a><a href="http://example.com/" target="_blank" rel="external">I linked to example.com</a></h1><pre><code>#### 格式化输出
&gt; prettify() : 格式化为unicode之后，每个xml、html独占一行。
</code></pre><blockquote>
<blockquote>
<blockquote>
<p>html.prettify()<br>‘<html>\n <body>\n  <a href="http://example.com/" target="_blank" rel="external">\n   I linked to\n   <i>\n<br>example.com\n   </i>\n  </a>\n </body>\n</html>‘<br>print(html.prettify())</p>
<p><html><br> <body><br>  <a href="http://example.com/" target="_blank" rel="external"><br>   I linked to<br>   <i><br>    example.com<br>   </i><br>  </a><br> </body><br></html><br>```</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="压缩输出"><a href="#压缩输出" class="headerlink" title="压缩输出"></a>压缩输出</h4><blockquote>
<p>unicode(bs)、str(bs)和encode<br>这应该属于其它操作了</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>bs会将html里边的特殊字符转换成unicode的格式</p>
<pre><code>&gt;&gt; soup = bs(&quot;&amp;ldquo;Dammit!&amp;rdquo; he said.&quot;)
unicode(soup)
# u&#39;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;\u201cDammit!\u201d he said.&lt;/body&gt;&lt;/html&gt;&#39;
</code></pre><p>python3上面没有unicode，直接使用str替换。<br>并且3上面bs4是直接将&amp;再次转义了，其它没有变化。</p>
<h4 id="‘get-text-’"><a href="#‘get-text-’" class="headerlink" title="‘get_text()’"></a>‘get_text()’</h4><p>如果想要获取tag里边的所以文本内容，可以使用这个方法。<br>‘get_text(‘|’) # 第一个参数指定分隔符号，不太明白这个分隔符具体操作，单词？？？’<br>‘get_text(‘|’, trip=True) # 这个会处理文本两端的空格’<br>还可以使用stripped_string生成器，获取文本列表分别处理。</p>
</blockquote>
<h4 id="指定解析器"><a href="#指定解析器" class="headerlink" title="指定解析器"></a>指定解析器</h4><blockquote>
<p>‘BeautifulSoup()’ 第一个参数是文本或者是文件，第二个参数是解析器，Python3应该不自动选择解析器。<br>目前支持解析：html、xml和html5<br>解析器有：lxml、html5lib和html.parser</p>
<ul>
<li>解析器之间的区别<br>使用了不同的解析器会产生不同的结果<br>具体还是去官网查看API，这里就这样了。<br>存在一些加标签和保留特定的标签的差异：<br>比如lxml会将单结束标志’<p></p>‘去掉，而html5lib会将其补齐为’<p></p>‘<br>一般不全的都会补齐基本标签，比如：’<html><body></body></html>‘<br>官方给的建议是在代码上面标注使用了什么解析器。</li>
</ul>
</blockquote>
<h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><blockquote>
<p>任何文档都有其编码方式，使用bs4之后都将其解析为unicode<br>bs使用了自动编码检测来将文档的编码转换为unicode<br>‘original_encoding’属性记录了自动识别的编码<br>bs采用了逐字节的方式来识别编码的，存在效率问题，并且还会猜错。<br>所以可以使用from_encoding参数来指定文档的编码：<br>BeautifulSoup(xxx, ‘lxml’, from_encoding=’utf-8’)<br>当编码比较接近或者是其子集的时候，可能会猜测错误，并且我们也只是知道大致编码的时候，这个时候bs提供exclude_encoding参数来排除错误的编码。<br>相当于猜测这个文档编码的一个集合，然后取其最可能的编码方式，但是如果猜测错误，那么说明猜测的这个编码是最可能的，但是是错误的，所以提供这个方法来排除，然后相当于让其猜测第二个可能的编码方式。<br>例如：’BeautifulSoup(xxx, ‘lxml’, exclude_encoding=[‘utf-8’])’<br>原文：少数情况下(通常是UTF-8编码的文档中包含了其它编码格式的文件),想获得正确的Unicode编码就不得不将文档中少数特殊编码字符替换成特殊Unicode编码,“REPLACEMENT CHARACTER” (U+FFFD, �) [9] . 如果Beautifu Soup猜测文档编码时作了特殊字符的替换,那么Beautiful Soup会把 UnicodeDammit 或 BeautifulSoup 对象的 .contains_replacement_characters 属性标记为 True .这样就可以知道当前文档进行Unicode编码后丢失了一部分特殊内容字符.如果文档中包含�而 .contains_replacement_characters 属性是 False ,则表示�就是文档中原来的字符,不是转码失败.</p>
</blockquote>
<h4 id="输出编码"><a href="#输出编码" class="headerlink" title="输出编码"></a>输出编码</h4><blockquote>
<p>bs将输入的文档都转换为utf-8输出，并且会将源数据的meta里边的编码也改成utf-8<br>在’prettify(‘utf-8’)’可以指定打印其编码<br>并且调研bs对象或者节点的方式来使用encode()方法<br>‘tag.encode(‘utf-8’)’<br>如果文档中包含当前编码不支持的字符，那么会进行转码。</p>
<pre><code>&gt;&gt; markup = u&quot;&lt;b&gt;\N{SNOWMAN}&lt;/b&gt;&quot;
&gt;&gt; snowman_soup = BeautifulSoup(markup)
&gt;&gt; tag = snowman_soup.b
&gt;&gt; print(tag.encode(&quot;utf-8&quot;))
# &lt;b&gt;☃&lt;/b&gt;

&gt;&gt; print tag.encode(&quot;latin-1&quot;)
# &lt;b&gt;&amp;#9731;&lt;/b&gt;

&gt;&gt; print tag.encode(&quot;ascii&quot;)
# &lt;b&gt;&amp;#9731;&lt;/b&gt;
</code></pre></blockquote>
<h4 id="‘UnicodeDammit’"><a href="#‘UnicodeDammit’" class="headerlink" title="‘UnicodeDammit’"></a>‘UnicodeDammit’</h4><blockquote>
<p>这个是bs的内置库，可以用来猜测文档的编码。<br>UnicodeDammit(‘xxx’).unicode_markup.original_encoding<br>就可以查看猜测的编码了。<br>UnicodeDammit.detwingle()：可以将编码进行统一，比如一些网站包含了另外的网站内容，但是编码却不一样，一个是utf-8编码，一个是另外的编码<br>这样直接使用是存在问题的。所以在处理之前最好使用这个方法进行操作一次。</p>
</blockquote>
<h4 id="判断对象是否相同"><a href="#判断对象是否相同" class="headerlink" title="判断对象是否相同"></a>判断对象是否相同</h4><blockquote>
<p>使用等于不严格的方式来判断是否相同，如下图不同位置b对象是相同的</p>
<pre><code>&gt;&gt; markup = &quot;&lt;p&gt;I want &lt;b&gt;pizza&lt;/b&gt; and more &lt;b&gt;pizza&lt;/b&gt;!&lt;/p&gt;&quot;
&gt;&gt; soup = BeautifulSoup(markup, &#39;html.parser&#39;)
&gt;&gt; first_b, second_b = soup.find_all(&#39;b&#39;)
&gt;&gt; print(first_b == second_b)
# True

&gt;&gt; print(first_b.previous_element == second_b.previous_element)
# False
</code></pre><p>使用is来严格判断是否相同</p>
<pre><code>&gt;&gt; print(first_b is second_b)
False
</code></pre><h4 id="复制Beautiful-Soup对象"><a href="#复制Beautiful-Soup对象" class="headerlink" title="复制Beautiful Soup对象"></a>复制Beautiful Soup对象</h4><blockquote>
<blockquote>
<p><code>copy.copy()</code>可以复制任意的<code>Tag</code>或<code>NavigableString</code></p>
<pre><code>import copy
p_copy = copy.copy(soup.p)
</code></pre><h4 id="解析部分文档"><a href="#解析部分文档" class="headerlink" title="解析部分文档"></a>解析部分文档</h4><p>如果仅仅需要获取页面中的<code>a</code>标签的内容，但是如果全部都去解析，就太耗费性能和内存了。最快的方法就在一开始就把<code>a</code>标签以外的都忽略掉。<br>SoupStrainer类可以定义文档的某段内容，只会解析SoupStrainer中定义的内容，创建一个SoupStrainer对象并作为parse_only参数给BeautifulSoup的构造方法就行。<br>SoupSTrainer类接受与典型搜索方法相同的参数：name、attr、recursive、string、**kw，下面源教程的列子，最后的short_strings运行错误，可能是参数导致的，显示<code>NoneType</code>无len。<br>```<br>from bs4 import SoupStrainer</p>
</blockquote>
</blockquote>
</blockquote>
<p>only_a_tags = SoupStrainer(“a”) #</p>
<p>only_tags_with_id_link2 = SoupStrainer(id=”link2”)</p>
<p>def is_short_string(string):<br>    return len(string) &lt; 10</p>
<p>only_short_strings = SoupStrainer(string=is_short_string)</p>
<p>BeautifulSoup(html_doc, “html.parser”, parse_only=only_a_tags)<br>```</p>
<h4 id="其他说明（官方教程为代码诊断）"><a href="#其他说明（官方教程为代码诊断）" class="headerlink" title="其他说明（官方教程为代码诊断）"></a>其他说明（官方教程为代码诊断）</h4><blockquote>
<blockquote>
<blockquote>
<p><code>from bs4.diagnose import diagnose</code><br>这个可以打印出解析器处理文档的过程。使用了一下，貌似是使用了不同的解析器对文档进行解析，然后分别给出结果。</p>
<h4 id="解析错误"><a href="#解析错误" class="headerlink" title="解析错误"></a>解析错误</h4><p>解析崩溃或者异常基本都不是bs4的问题，因为他并不包含解析器，官方给于的解释是换解析器<br>最常见的解析错误是<code>HTMLParser.HTMLParseError: malformed start tag</code>和<code>HTMLParser.HTMLParseError: bad end tag</code>.这都是由Python内置的解析器引起的,解决方法是 安装<code>lxml</code>或<code>html5lib</code><br>find_all()或者find返回都是空，但是文档中也存在这个Tag，还是换解析器。</p>
<h5 id="解析器错误"><a href="#解析器错误" class="headerlink" title="解析器错误"></a>解析器错误</h5><p>一般解析器解析之后都是转为小写，如果要保留大小写，那么使用<code>xml</code>解析器</p>
<h4 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h4><p>使用<code>lxml</code>解析器会较快一点<br>安装<code>cchardet</code>之后，文档编码检测速度会更快。</p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h1 id="完"><a href="#完" class="headerlink" title="完"></a>完</h1>]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习 python bs4 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Numpy基础]]></title>
      <url>/2017/11/20/python/numpy/02_quickstart_tutorial/</url>
      <content type="html"><![CDATA[<h1 id="NumPy基础"><a href="#NumPy基础" class="headerlink" title="NumPy基础"></a>NumPy基础</h1><blockquote>
<p>NumPy的主要对象是同类型的多维数组，是一张表，所有元素（通常是数字）的类型都相同。<br>维度称为axes，axes的数目为rank。如下rank为2（2维的），第一维度axes长度为2，第二维度axes长度为3.<br><code>[[ 1., 0., 0.],</code><br><code>[ 0., 1., 2.]]</code><br>NumPy的数组的类称为ndarray。Python的数组提供较少的功能，而ndarray一下重要的属性。</p>
</blockquote>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><blockquote>
<ul>
<li>ndarray.ndim：数组的axes（维度）的个数，维度的数量称为rank。</li>
<li>ndarray.shape：数组的维度。这是一个整数元组，<code>(n, m)</code>表示一个n行，m列的矩阵。</li>
<li>ndarray.size：为shape元素的乘积，其实就是矩阵元素个数。</li>
<li>ndarray.dtype：描述矩阵中元素的类型的对象。可以使用Python标准的类型，也提供其他类型，例如：numpy.int32、numpy.int16和numpy.float64。</li>
<li>ndarray.itemsize：数组中每个元素的字节大小。例如float64字节数为8。</li>
<li>ndarray.data：该缓冲区包含数组的实际元素。通常不适用这个，我们一般使用索引进行访问（前面矢量化又说不要遍历，后续看看是怎么回事）。</li>
</ul>
<p>打开中文API查看示例：<a href="http://python.usyiyi.cn/translate/NumPy_v111/user/quickstart.html" title="示例" target="_blank" rel="external">属性示例</a></p>
</blockquote>
<h2 id="数组创建"><a href="#数组创建" class="headerlink" title="数组创建"></a>数组创建</h2><blockquote>
<p>有几种方法来创建数组</p>
<ul>
<li>可以使用array函数从常规的Python列表或元组中创建数组，得到的数组类型从序列中元素的类型推到而出。<br><code>&gt;&gt;&gt; numpy.array([3, 4, 5])</code></li>
<li>array函数传入列表的列表产生2维阵列，同理3维。<br><code>&gt;&gt;&gt; numpy.array([1, 2, 3], [4, 5, 6])</code><br><code>array([[1, 2, 3]</code><br><code>[4, 5, 6]</code><br><code>])</code><blockquote>
<ul>
<li>数组的类型可以在创建的时候指定<br><code>&gt;&gt;&gt; numpy.array([1, 2, 3], dtype=complex)</code> #元素为复数形式 1. + 0.j</li>
</ul>
</blockquote>
</li>
<li>通常数组的元素是位置的，所有NumPy提供创建具体初始占位符的数组，减少数组增长的必要。<blockquote>
<ul>
<li>函数zeros创建一个由0组成的数组；</li>
<li>函数ones创建一个由1数组的数组；</li>
<li>函数empty内容是随机的并且取决于存储器的状态，元素默认类型是float64。</li>
</ul>
</blockquote>
</li>
<li>为了创建数组序列，NumPy提供了类似于range的函数，返回数组而不是列表。<blockquote>
<p><code>&gt;&gt;&gt; numpy.arange(1, 10, 2)</code> #使用如上的reshape函数可以改变形状。起始为1步长为2。</p>
</blockquote>
</li>
<li>当arange与浮点参数一起使用时，由于浮点数的精度是有限的，通常不可能预测获得的元素数量。出于这个原因，通常最好使用函数linspace，它接收我们想要的元素数量而不是步长作为参数：<br><code>&gt;&gt;&gt; numpy.linspace(1, 2, 9)</code> # 1到二之间的9个数，感觉是平均分配的样子。步长0.125<br>‘&gt;&gt;&gt; numpy.sin(numpy.linspace(0, 2*pi, 100))’ #求sin。<br>其他函数：<br>array, zeros, zeros_like, ones, ones_like, empty, empty_like, arange,<br>linspace, numpy.random.rand, numpy.random.randn, fromfunction, fromfile</li>
</ul>
</blockquote>
<h2 id="打印数组"><a href="#打印数组" class="headerlink" title="打印数组"></a>打印数组</h2><blockquote>
<p>当打印数组时，NumPy以类似于嵌套列表的方式显示它，但是使用以下布局：</p>
<ul>
<li>最后一个axes从左到右打印，</li>
<li>第二个到最后一个从上到下打印，</li>
<li>其余的也从上到下打印，每个切片与下一个用空行分开</li>
<li>如果数组太大，会跳过中间的部分，只打印边角部分。<blockquote>
<ul>
<li>如果需要强制打印整个数组，可以使用set_printoptions来更改打印选项<br><code>numpy.set_printoptions(threshold=&#39;nan&#39;)</code> #官方api说传入的是int值，nan目前不知道什么意思：后面查看可以传入numpy.nan，而非str类型</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="reshape改变数组形状"><a href="#reshape改变数组形状" class="headerlink" title="reshape改变数组形状"></a>reshape改变数组形状</h3><blockquote>
<ul>
<li><code>a.ravel()</code> #平坦化序列，比如3 * 4的矩阵，变成一维矩阵。</li>
<li><code>a.reshape(x, y)</code> #转变形状到x*y 元素需要支持转换该形状才行，如果y=-1则会自动计算维度。</li>
<li><code>a.T</code> #转置 transposed</li>
<li><code>numpy.resize</code>方法直接改变数组本身</li>
</ul>
</blockquote>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="数组上的算术运算符使用元素基本，将创建一个新数组并用结果填充，差不多就是对应到每个元素，然后返回计算结果。"><a href="#数组上的算术运算符使用元素基本，将创建一个新数组并用结果填充，差不多就是对应到每个元素，然后返回计算结果。" class="headerlink" title="数组上的算术运算符使用元素基本，将创建一个新数组并用结果填充，差不多就是对应到每个元素，然后返回计算结果。"></a>数组上的算术运算符使用元素基本，将创建一个新数组并用结果填充，差不多就是对应到每个元素，然后返回计算结果。</h2><blockquote>
<p><code>&gt;&gt;&gt; a = numpy.array([20, 30, 40, 50])</code><br><code>&gt;&gt;&gt; b = numpy.arange(4)</code></p>
<ul>
<li><code>&gt;&gt;&gt; c = a - b</code> #对应求其差值</li>
<li><code>&gt;&gt;&gt; b**2</code> #b元素都乘2</li>
<li><code>&gt;&gt;&gt; 10*np.sin(a)</code> #对a每个元素求sin，并乘10倍值。</li>
<li><code>&gt;&gt;&gt; a &lt; 35</code> #对a元素做判断，返回boolean矩阵。</li>
<li>dot函数做矩阵的乘法：a.dot(b) np.dot(a, b)</li>
<li>a * b 是对a和b对应位置的元素做乘积</li>
</ul>
</blockquote>
<h2 id="类似的操作会修改当前数组，而不是创建新的数组："><a href="#类似的操作会修改当前数组，而不是创建新的数组：" class="headerlink" title="+= *= 类似的操作会修改当前数组，而不是创建新的数组："></a>+= *= 类似的操作会修改当前数组，而不是创建新的数组：</h2><blockquote>
<ul>
<li>‘&gt;&gt;&gt; a = np.ones((2,3), dtype=int)’</li>
<li><code>&gt;&gt;&gt; b = np.random.random((2, 3))</code></li>
<li><code>&gt;&gt;&gt; a *= 3</code></li>
<li><code>&gt;&gt;&gt; b += a</code></li>
<li><code>&gt;&gt;&gt; a += b</code> #报错， float64 to int32</li>
</ul>
</blockquote>
<h2 id="不同类型的数组操作，结果数组的类型对应更精确的数组，向上转型。"><a href="#不同类型的数组操作，结果数组的类型对应更精确的数组，向上转型。" class="headerlink" title="不同类型的数组操作，结果数组的类型对应更精确的数组，向上转型。"></a>不同类型的数组操作，结果数组的类型对应更精确的数组，向上转型。</h2><blockquote>
<ul>
<li>比如int32 和 float64计算 结果类型为float64</li>
</ul>
</blockquote>
<h2 id="许多一元操作，求和sum，可以使用ndarray的方法"><a href="#许多一元操作，求和sum，可以使用ndarray的方法" class="headerlink" title="许多一元操作，求和sum，可以使用ndarray的方法"></a>许多一元操作，求和sum，可以使用ndarray的方法</h2><blockquote>
<ul>
<li><code>sum(), max(), min()</code></li>
</ul>
</blockquote>
<h2 id="默认的这些操作适用于数组，就像一个数字列表求最大值，不管其形状（shape-2-3-）"><a href="#默认的这些操作适用于数组，就像一个数字列表求最大值，不管其形状（shape-2-3-）" class="headerlink" title="默认的这些操作适用于数组，就像一个数字列表求最大值，不管其形状（shape = (2*3)）"></a>默认的这些操作适用于数组，就像一个数字列表求最大值，不管其形状（shape = (2*3)）</h2><h2 id="通过axis参数，可以指定沿数组的指定轴应用操作"><a href="#通过axis参数，可以指定沿数组的指定轴应用操作" class="headerlink" title="通过axis参数，可以指定沿数组的指定轴应用操作"></a>通过axis参数，可以指定沿数组的指定轴应用操作</h2><blockquote>
<ul>
<li><code>b.sum(axis=0)</code> # 每列求和</li>
<li><code>b.sum(axis=1)</code> # 每行求和</li>
<li><code>b.cumsum(axis=1)</code> # 沿着行累积和，相反沿着列累积和</li>
</ul>
</blockquote>
<h2 id="另见"><a href="#另见" class="headerlink" title="另见"></a>另见</h2><blockquote>
<p>all, any, apply_along_axis, argmax, argmin, argsort, average, bincount, ceil, clip, conj, corrcoef, cov, cross, cumprod, cumsum, diff, dot, floor, inner, inv, lexsort, max, maximum, mean, median, min, minimum, nonzero, outer, prod, re, round, sort, std, sum, trace, transpose, var, vdot, vectorize, where</p>
<ul>
<li>all：是判断所以元素是否都为True，可以定义axis来沿着某个轴判断。</li>
<li>any：和all相反，判断是否有一个为Ture，是返回True，否返回False，可以传入axis 例如：b.any(0)，纵轴是否有为真的。</li>
<li><p>apply_along_axis(func, axis, arr)：将arr按照axis定义，行或者列取出作用在func上，并返回一个列表。</p>
<blockquote>
<p>如果上述返回标量，则返回于源arr相同形状(shape)。比如传输sorted进行排序，返回还是列表。</p>
</blockquote>
</li>
<li><p>argmax：查找最大值，返回索引，支持axis轴选择。如果多个大值，就返回第一次遇到的。</p>
</li>
<li>argmin：和max相反。</li>
<li>argsort：排序，返回排序完的索引值。可以选择算法。选择键排序。</li>
<li>mean：平均值，可以按轴进行。axis</li>
<li>diff：计算差分，out[n] = a[n+1] - a[n]，可以按轴进行。</li>
<li>vdot：计算点积。</li>
<li>还有很多函数，先不看了。</li>
</ul>
</blockquote>
<h2 id="索引、切片和迭代"><a href="#索引、切片和迭代" class="headerlink" title="索引、切片和迭代"></a>索引、切片和迭代</h2><h3 id="一维数组支持索引，切片和迭代，非常类似于列表和其他序列。"><a href="#一维数组支持索引，切片和迭代，非常类似于列表和其他序列。" class="headerlink" title="一维数组支持索引，切片和迭代，非常类似于列表和其他序列。"></a>一维数组支持索引，切片和迭代，非常类似于列表和其他序列。</h3><blockquote>
<ul>
<li>a[1:2]，其中<code>**</code>是次方，**(1/3) 求根号3</li>
</ul>
</blockquote>
<h3 id="多维数组每个轴可以有一个索引。这些索引以逗号分隔的元组给出："><a href="#多维数组每个轴可以有一个索引。这些索引以逗号分隔的元组给出：" class="headerlink" title="多维数组每个轴可以有一个索引。这些索引以逗号分隔的元组给出："></a>多维数组每个轴可以有一个索引。这些索引以逗号分隔的元组给出：</h3><blockquote>
<p>比如b[2,3]表示3行4列的元素，b[0:3, 1]表示行数是0,1,2的第2列，如果1数字缺失，则认为是全部列。<br>如果维度大于3，比如维度（轴，rank）为5的情况，x[1,2,:,:,:]可以等效为x[1,2,…]</p>
<ul>
<li>x[1,2,…]等效于x[1,2,:,:,:]</li>
<li>x[…,3]到x[:,:,:,:,3]</li>
<li>x[4,…,5,:]到x[4,:,:,5,:]<br>例子：y[1:5:2,::3]指的是1-4行间隔为2行，列数间隔为3进行抽取。<br>避免迭代使用索引提高性能。<br>可以使用一个数组来索引数组，提高的索引必须是索引值，比如a[np.array([1,2,3])] 索引a中的索引为1,2,3的元素。<br>并且索引数组可以是多维的生成的矩阵维度和索引一致，a[np.array([[1,2], [3,4]])]，二维矩阵，1,2,3,4对应为a一维矩阵的索引。</li>
<li>Boolean型索引，比如<br><code>&gt;&gt;&gt; y = np.arange(35).reshape(5,7)</code><br><code>&gt;&gt;&gt; b = y &gt; 22</code><br><code>&gt;&gt;&gt; y[b] # 这样就将y里边的大于22的数索引出来了，但是维度只有一维，并且如果索引的布尔数组和y具有相同的形状</code><br>通常，当布尔数组具有比被索引的数组更少的维度时，这等同于y [b，…]，这意味着y被索引为b，然后是多个：如同填充y。因此，结果的形状是包含布尔数组的True元素的数目的一个维度，后面是被索引的数组的剩余维度。<br>组合索引和切片，感觉就是行和列的索引，三维的话相当于两个数组，就分别对两个进行索引</li>
<li><code>y[1:3, 2:3] #类似的就是1-2行并且列是2列</code><br>结构化索引工具<br><code>&gt;&gt;&gt; y.shape</code><br><code>(5, 7)</code><br><code>&gt;&gt;&gt; y[:,np.newaxis,:].shape # np.newaxis 对象来新建一个维度&#39;</code>(5, 1, 7)`</li>
<li>可以使用索引来改变相应位置的值<br><code>y[2:7] = 1 #将2-6位置的数更改为1</code><br><code>y[2:7] = np.arange(5) #或者直接使用数组的形式</code><br>如果高类型分配给低类型的，会转型，损失精度，或者抛出错误<br>下面的一个例子比较特殊：<br><code>&gt;&gt;&gt; x = np.arange(0, 50, 10)</code><br><code>&gt;&gt;&gt; x</code><br><code>array([ 0, 10, 20, 30, 40])</code><br><code>&gt;&gt;&gt; x[np.array([1, 1, 3, 1])] += 1</code><br><code>&gt;&gt;&gt; x</code><br><code>array([ 0, 11, 20, 31, 40])</code><br>实际上我们认为1位置的数应该增加3才对，但是最终只增加1，其实是我们每次计算都采用了临时数组的方式，导致最终只增加1.</li>
<li>Ellipsis 等同于 ‘…’</li>
<li>元组不像列表索引那样会自动处理，如下例子：<br><code>&gt;&gt;&gt; z[[1,1,1,1]] # produces a large array</code><br><code>array([[[[27, 28, 29],</code><br><code>[30, 31, 32], ...</code><br><code>&gt;&gt;&gt; z[(1,1,1,1)] # returns a single value</code><br><code>40</code></li>
</ul>
</blockquote>
<h3 id="多维数组迭代是相对于第一个轴进行的。"><a href="#多维数组迭代是相对于第一个轴进行的。" class="headerlink" title="多维数组迭代是相对于第一个轴进行的。"></a>多维数组迭代是相对于第一个轴进行的。</h3><blockquote>
<p>可以使用flat，是一个迭代器。<br>如果使用x[0][2]会降低性能。因为2索引需要在前面0索引创建的数组上面继续操作。<br>另见indexing。</p>
</blockquote>
<h2 id="形状操作"><a href="#形状操作" class="headerlink" title="形状操作"></a>形状操作</h2><blockquote>
<p>以下的命令不会修改数组，只会返回新的数组</p>
<ul>
<li>ravel 返回连续的平坦的数组，降成一维</li>
<li>reshape 修改形状</li>
<li>T 转置<br>修改数组本身</li>
<li>resize：对应的reshape是返回修改的数组<br>将不同的数组堆叠</li>
<li>vstack</li>
<li>hstack h v 分别对应水平方向和垂直方向。</li>
<li>column_stack</li>
<li>row_stack column 和 row 分别对应，并且这两个方法允许1D的数组堆叠到2D数组中<br>将数组分隔成几个小的数组</li>
<li><code>np.hsplit(a, 3) #将a划分为3个 h是水平</code></li>
<li><code>np.hsplit(a, (3, 4)) #将列为3-4但是不等于4的索引分隔开来</code> </li>
<li>同理vsplit是垂直划分</li>
<li>array_split 可以指定某个轴进行划分</li>
</ul>
</blockquote>
<h2 id="复制和视图"><a href="#复制和视图" class="headerlink" title="复制和视图"></a>复制和视图</h2><blockquote>
<p>当计算和操作数组时，它们的数据有时被复制到新的数组中，有时不复制。这通常是初学者的混乱的来源。有三种情况：</p>
<ul>
<li>完全不复制<br>简单赋值不会创建数组对象或其数据的拷贝：如果将b = a 那么b和a指向的是同一个数组，改变b，a也跟着改变。<br>可变对象传递到函数引用，函数不会复制。</li>
<li>视图或浅复制<br>不同的数组对象可以共享相同的数据。view方法创建一个新数组对象，该对象看到相同的数据。<br><code>c=a.view()</code>, 这样改变<code>c.shape = (2,6)</code>，a的形状不会改变，但是如果<code>c[0,4] = 1234</code>，a的相应位置就会赋值为1234<br><code>c.base is a = True</code><br>对数组切片返回的也是视图</li>
<li>深复制<br><code>d = a.copy()</code><br>这样d就是一个新的数组</li>
</ul>
</blockquote>
<h2 id="函数和方法概述"><a href="#函数和方法概述" class="headerlink" title="函数和方法概述"></a>函数和方法概述</h2><blockquote>
<p>这里是一些有用的NumPy函数和方法名称按类别排序的列表。有关完整列表，请参见Routines。</p>
<ul>
<li>数组创建<br><code>arange, array, copy, empty, empty_like, eye, fromfile, fromfunction, identity, linspace, logspace, mgrid, ogrid, ones, ones_like, r, zeros, zeros_like</code></li>
<li>转换<br><code>ndarray.astype，atleast_1d，atleast_2d，atleast_3d，mat</code></li>
<li>操纵<br><code>array_split, column_stack, concatenate, diagonal, dsplit, dstack, hsplit, hstack, ndarray.item, newaxis, ravel, repeat, reshape, resize, squeeze, swapaxes, take, transpose, vsplit, vstack</code></li>
<li>问题<br><code>all，any，nonzero，where</code></li>
<li>顺序<br><code>argmax, argmin, argsort, max, min, ptp, searchsorted, sort</code></li>
<li>操作<br><code>choose, compress, cumprod, cumsum, inner, ndarray.fill, imag, prod, put, putmask, real, sum</code></li>
<li>基本统计<br><code>cov，mean，std，var</code><br>基本线性代数<br><code>cross，dot，outer，linalg.svd，vdot</code></li>
</ul>
</blockquote>
<h2 id="其他基础"><a href="#其他基础" class="headerlink" title="其他基础"></a>其他基础</h2><h3 id="广播规则"><a href="#广播规则" class="headerlink" title="广播规则"></a>广播规则</h3><blockquote>
<ul>
<li>Broadcasting允许通用函数以有意义的方式处理具有不完全相同形状的输入。</li>
<li>Broadcasting的第一个规则是，如果所有输入数组不具有相同数量的维度，则“1”将被重复地添加到较小数组的形状，直到所有数组具有相同数量的维度。</li>
<li>Broadcasting的第二个规则确保沿着特定维度具有大小为1的数组表现得好像它们具有沿着该维度具有最大形状的数组的大小。假定数组元素的值沿“Broadcasting”数组的该维度相同。</li>
</ul>
</blockquote>
<h3 id="花式索引技巧"><a href="#花式索引技巧" class="headerlink" title="花式索引技巧"></a>花式索引技巧</h3><blockquote>
<p>NumPy提供了比常规Python序列更多的索引能力。除了通过整数和切片索引之外，如前所述，数组可以由整数数组和布尔数组索引。</p>
<ul>
<li>使用索引数组索引<br><code>a[j]</code> <code>j = np.array([1,1,3]) #得出索引a是1,1,3组成的数组</code><br>如果索引的数组是多维的，结果与之对应，<code>j = np.array([[1,2,3], [4, 5, 6]])</code>，结果是形状是<code>(2, 3)</code></li>
<li>可以对每个维度进行单独索引<br><code>i = np.array([[0,1], [1, 2]])</code><br><code>j = np.array([[2,1], [1, 3]])</code><br><code>a[i, j]</code><br>同样的 <code>l=[i,j]</code> <code>a[l]=a[i,j]</code></li>
</ul>
</blockquote>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><blockquote>
<p>np.ix_[a,b,c] ???雨里雾里<br>np.ufunc.reduce ???云里雾里</p>
</blockquote>
<h3 id="线性代数-基础"><a href="#线性代数-基础" class="headerlink" title="线性代数 基础"></a>线性代数 基础</h3><blockquote>
<p>简单的数组操作</p>
<ul>
<li><code>a.transpose() # 矩阵转置</code> </li>
<li><code>np.linalg.inv(a) # 逆矩阵</code></li>
<li><code>np.eye(2) # 2*2的矩阵，返回对角线是1其他都是0的矩阵</code></li>
<li><code>np.dot(i, j) # 求矩阵乘积</code></li>
<li><code>np.trace(a) # 对a矩阵的对角线值求和</code></li>
<li><code>np.linalg.solve(a, y) # 解线性方程组 a矩阵对应参数，y对应等于后边的数</code></li>
<li><code>np.linalg.eig(j) # 特征向量，线性代数当时没有学好</code></li>
</ul>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Numpy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[What is Numpy]]></title>
      <url>/2017/11/16/python/numpy/01_what_is_numpy/</url>
      <content type="html"><![CDATA[<h1 id="What-is-Numpy"><a href="#What-is-Numpy" class="headerlink" title="What is Numpy"></a>What is Numpy</h1><blockquote>
<p><code>Numpy</code>是Python科学计算的基本包，提供对于多维数组（矩阵）等各种计算，比如c = a * b，a、b均为矩阵，可以对其进行直接计算，不用使用循环遍历。<br>本机测试计算速度为for循环遍历计算的500+倍。例子如下：目前找不到源网页，直接粘上例子。</p>
</blockquote>
<pre><code>import numpy as np 
import time
#from timeit import timeit

a = np.random.rand(1000000)
b = np.random.rand(1000000)

time_s = time.time()
c = np.dot(a, b)
time_e = time.time()
print(c, 1000*(time_e - time_s))

c = 0
time_s = time.time()
for i in range(len(a)):
    c += a[i] * b[i]
time_e = time.time()
print(c, 1000*(time_e - time_s))
</code></pre><blockquote>
<p>下图所示<br><img src="/img/python/vectorization.png" alt="vectorization"></p>
</blockquote>
<h2 id="矢量化-Vectorization"><a href="#矢量化-Vectorization" class="headerlink" title="矢量化(Vectorization)"></a>矢量化(Vectorization)</h2><blockquote>
<p>上面的例子是矢量化的例子（Vectorization），包含以下优点：</p>
<ul>
<li>代码更简洁</li>
<li>更少的代码通常意味着更少的错误</li>
<li>代码运行更接近标准的数学符号，封装了具体的困难的运算，如上np.dot(a, b)直接计算两个矩阵的积。</li>
<li>矢量化导致更多的“Pythonic”(网络解释为很Python的Python代码)代码。如果没有向量化，我们的代码将会效率很低，难以读取for循环。</li>
</ul>
</blockquote>
<h2 id="广播-Broadcasting"><a href="#广播-Broadcasting" class="headerlink" title="广播(Broadcasting)"></a>广播(Broadcasting)</h2><blockquote>
<p>广播是用于描述操作的隐式逐个元素行为的术语<br>大概意思就是比如做矩阵的运算，a为一维矩阵，b为标量，如果做计算<code>a + b</code>，会自动的将a的元素都加上b（我的简单理解）</p>
</blockquote>
<h1 id="源网站"><a href="#源网站" class="headerlink" title="源网站"></a>源网站</h1><blockquote>
<p><a href="http://python.usyiyi.cn" title="Numpy 中文API" target="_blank" rel="external">Numpy 中文 API</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Learn Numpy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git删除提交的文件]]></title>
      <url>/2017/11/05/git/git_rm_use_cached/</url>
      <content type="html"><![CDATA[<h1 id="目的为了测试Markdown书写"><a href="#目的为了测试Markdown书写" class="headerlink" title="目的为了测试Markdown书写"></a>目的为了测试Markdown书写</h1><blockquote>
<p>本人在学习 git 的时候，前期将本地的日志文件提交到仓库，然后也就查找了相关的操作方法，最终使用此命令解决的，然后新增<code>.gitignore</code>文件，提交，再次使用<code>git status</code>这些文件就不会再次出现了，其他情况也可以使用这个方法：将数据库账号密码配置文件从远端仓库删除。</p>
</blockquote>
<h1 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h1><h2 id="git-rm-Filename-or-Foldername："><a href="#git-rm-Filename-or-Foldername：" class="headerlink" title="git rm Filename or Foldername："></a>git rm Filename or Foldername：</h2><blockquote>
<p>使用在当我们提交了一个不想提交的文件，可以使用其删除本地工作目录的文件，一般我们可能需要保留源文件，所以可以使用：<code>--cached</code>参数来实现只删除索引（官方：Index，跟踪的文件清单）。</p>
</blockquote>
<h2 id="git-rm-–cached-Filename-or-Foldername："><a href="#git-rm-–cached-Filename-or-Foldername：" class="headerlink" title="git rm –cached Filename or Foldername："></a>git rm –cached Filename or Foldername：</h2><blockquote>
<p>使用 <code>--cached</code> 将会保留本地文件，只删除暂存区的文件，提交这次修改，该文件就不会纳入版本管理了，远端的仓库也会同步这个修改，达到删除文件目的。</p>
</blockquote>
<h2 id="常用参数："><a href="#常用参数：" class="headerlink" title="常用参数："></a>常用参数：</h2><blockquote>
<ul>
<li><code>-n</code> or <code>--dry-run</code> 加上这个参数是不会做任何删除操作的，只是将符合<code>filename</code>删除的文件预览打印出来，准确的说加上这个参数会打印此操作产生影响（删除）的文件列表。<ul>
<li><code>git rm -n --cached txt/\\*.txt</code>  #将会列出txt目录下的符合拓展名字为.txt的文件，反斜杠<code>\</code>为转义字符。</li>
</ul>
</li>
<li><code>-f</code> 这个参数是强制执行的意思，如果我们已经将文件提交到暂存区，这个时候需要加上这个参数。</li>
<li><code>-r</code> 类似bash命令就是递归删除了，如果删除目录使用此参数。</li>
</ul>
</blockquote>
<h2 id="官网相关页面："><a href="#官网相关页面：" class="headerlink" title="官网相关页面："></a>官网相关页面：</h2><blockquote>
<p><a href="https://git-scm.com/docs/git-rm" title="get-rm" target="_blank" rel="external">git-rm</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git rm 删除 文件 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
