<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LKJ Hexo Blog</title>
  
  <subtitle>wow Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-03T04:25:06.604Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LKJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习bs4模块</title>
    <link href="http://yoursite.com/2017/11/29/python/bs4/learn_bs4/"/>
    <id>http://yoursite.com/2017/11/29/python/bs4/learn_bs4/</id>
    <published>2017-11-29T12:14:07.490Z</published>
    <updated>2017-12-03T04:25:06.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习bs4模块"><a href="#学习bs4模块" class="headerlink" title="学习bs4模块"></a>学习bs4模块</h1><blockquote><p>直接在官方网站上面学习</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>bs4是一个格式化读取xml，html文档的库<br>可以使xml、html按照标签的形式操作，具体是将HTML文档转换成一个复杂的树形结构。<br>官方推荐lxml来解析HTML<br>所有节点对象可以归纳为4种: Tag , NavigableString , BeautifulSoup , Comment .</p><p>简单使用操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from bs4 import BeautifulSoup</div><div class="line">html_doc = &apos;&apos;</div><div class="line">soup = BeautifulSoup(html_doc, &apos;html.parser&apos;)</div><div class="line">print(soup.prettify())  #美化输出，格式化缩进。</div></pre></td></tr></table></figure></p></blockquote><h2 id="一般属性"><a href="#一般属性" class="headerlink" title="一般属性"></a>一般属性</h2><blockquote><ul><li><code>soup.title</code>：获取页面的标题，包含标签</li><li><code>soup.title.name</code>：获取页面标题标签的内容</li><li><code>soup.title.string</code>：获取页面标题的内容</li><li><code>soup.title.parent.name</code>：父标签名字</li><li><code>soup.p</code>：<code>p</code>是标签名字</li><li><code>soup.p[&#39;class&#39;]</code>：第一个匹配p的标签，成员class</li><li><code>soup.a</code>：同上</li></ul></blockquote><h2 id="一般方法"><a href="#一般方法" class="headerlink" title="一般方法"></a>一般方法</h2><blockquote><ul><li><code>soup.find_all(&#39;a&#39;)</code>：找到所以的<code>a</code>标签</li></ul></blockquote><h3 id="查找所有的a标签"><a href="#查找所有的a标签" class="headerlink" title="查找所有的a标签"></a>查找所有的a标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for link in soup.find_all(&apos;a&apos;):</div><div class="line">    print(link.get(&apos;href&apos;))</div><div class="line">    # http://example.com/elsie</div><div class="line">    # http://example.com/lacie</div><div class="line">    # http://example.com/tillie</div></pre></td></tr></table></figure><blockquote><ul><li><code>soup.get_text()</code>：拿到文档中所有的文字内容，实际测试新浪的首页存在问题，使用html5lib也一致。</li></ul></blockquote><h2 id="对象的种类"><a href="#对象的种类" class="headerlink" title="对象的种类"></a>对象的种类</h2><h3 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h3><blockquote><p><code>Tag</code>对象和XML或HTML原生文档中的tag相同</p></blockquote><h4 id="Tag重要的属性"><a href="#Tag重要的属性" class="headerlink" title="Tag重要的属性"></a>Tag重要的属性</h4><blockquote><ul><li><p><code>name</code><br>每个Tag都有自己的名字，通过name属性来获取，比如<title>xxx</title>，Tag名称就是title<br>如果改变了某个tag的名称，那么将影响当前生成的hml对象文档<br><code>tag.name = &#39;xxx&#39;</code></p></li><li><p><code>Attributes</code><br>一个<code>Tag</code>可能存在属性，属性的操作和字典相同<br>可以直接使用<code>attrs</code>获取全部属性<br>tag的属性可以添加删除或者修改。操作和字典一致。</p></li></ul></blockquote><h4 id="多值属性"><a href="#多值属性" class="headerlink" title="多值属性"></a>多值属性</h4><blockquote><p>一个属性可能有多个值，这里返回其列表。<br><code>&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;</code>：将会返回body和strikeout的列表<br>如果存在多个值，但是HTML定义中并没有定义为多值属性，那么还是返回字符串<br>并且可以传入列表以修改多值属性，传入列表为多值。<br>xml中不包含多值</p></blockquote><h4 id="可以遍历的字符串"><a href="#可以遍历的字符串" class="headerlink" title="可以遍历的字符串"></a>可以遍历的字符串</h4><blockquote><p>字符串常被包含在tag内.Beautiful Soup用 <code>NavigableString</code> 类来包装tag中的字符串<br>节点下的字符串不可以编辑，但是可以替换，使用replace_with(‘xxx’)<br>字符串不支持：contents，string属性或find()方法<br>需要在此之外使用字符串，使用unicode将其转换为普通的Unicode字符串，减少内存占用。</p></blockquote><h5 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h5><blockquote><p><code>soup.body.b</code>：body节点下的b节点</p><ul><li><code>tag.contents</code>：可以将节点下的子节点以列表方式输出。</li><li><code>tag.children</code>：子节点生成器，</li><li><code>descendants</code>：后裔，多所有的子孙节点递归循环，这样会将string也单独提取出来</li><li>节点下的<code>string</code>：如果节点下面存在子节点，并且子节点不是内容节点，那么返回None</li><li><code>strings and stripped_strings</code>：解决了上面的问题，使用这个将打印节点下的所以字符串，其中stripped_strings去除空格</li></ul></blockquote><h3 id="BeautifulSoup对象"><a href="#BeautifulSoup对象" class="headerlink" title="BeautifulSoup对象"></a>BeautifulSoup对象</h3><blockquote><p>表示文档的全部内容大部分时候可以将它当做<code>Tag</code>对象。</p></blockquote><h4 id="搜索文档树"><a href="#搜索文档树" class="headerlink" title="搜索文档树"></a>搜索文档树</h4><blockquote><p>很多搜索方法，这里解释：<code>find()</code>和<code>find_all()</code><br>其它操作方法类似</p></blockquote><h5 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h5><blockquote><ul><li>字符串<br>使用字符串来过滤查找，比如<code>soup.find_all(&#39;a&#39;)</code>来找到<code>a</code>标签</li><li>正则表达式<br>支持正则表达式，比如：<code>soup.find_all(re.compile(&quot;^b&quot;))</code></li><li>列表参数<br>传入列表参数：<code>[&#39;a&#39;, &#39;b&#39;]</code> 找出<code>a</code> <code>b</code>的标签</li><li>True<br>传入<code>True</code>值，那么会找到所有节点，但是没有字符串。</li><li>方法<br>如果没有合适的过滤器，那么可以传入方法，方法接收一个参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def has_class_but_no_id(tag):</div><div class="line">    return tag.has_attr(&apos;class&apos;) and not tag.has_attr(&apos;id&apos;)</div><div class="line"></div><div class="line">def not_lacie(href):</div><div class="line">        return href and not re.compile(&quot;lacie&quot;).search(href)</div><div class="line">soup.find_all(href=not_lacie)</div><div class="line"></div><div class="line">from bs4 import NavigableString</div><div class="line">def surrounded_by_strings(tag):</div><div class="line">    return (isinstance(tag.next_element, NavigableString)</div><div class="line">            and isinstance(tag.previous_element, NavigableString))</div></pre></td></tr></table></figure></li></ul><p>具体参数 find_all( name , attrs , recursive , string , **kwargs )</p><ul><li>name 用来查找所以tag</li><li>attrs 传入字典</li><li>recursive 传入False只便利直接的子节点</li><li>string 查找内容，页面上的文本内容，可以传入文字，列表，正则表达式，True</li><li>**kwargs 传入关键字参数 比如：id=’xxx’  同时可以过滤多个这样的属性</li><li>limit 限制查找的数量<br>有些tag属性在搜索不能使用,比如HTML5中的 data-* 属性:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">data_soup = BeautifulSoup(&apos;&lt;div data-foo=&quot;value&quot;&gt;foo!&lt;/div&gt;&apos;)</div><div class="line">data_soup.find_all(data-foo=&quot;value&quot;)</div><div class="line">SyntaxError: keyword can&apos;t be an expression</div></pre></td></tr></table></figure></li></ul><p>但是可以通过 find_all() 方法的 attrs 参数定义一个字典参数来搜索包含特殊属性的tag:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data_soup.find_all(attrs=&#123;&quot;data-foo&quot;: &quot;value&quot;&#125;)</div><div class="line">[&lt;div data-foo=&quot;value&quot;&gt;foo!&lt;/div&gt;]</div></pre></td></tr></table></figure></p><p>但标识CSS类名的关键字 class 在Python中是保留字,使用 class 做参数会导致语法错误.从Beautiful Soup的4.1.1版本开始,可以通过 class_ 参数搜索有指定CSS类名的tag:</p></blockquote><h3 id="子节点-1"><a href="#子节点-1" class="headerlink" title="子节点"></a>子节点</h3><blockquote><p>一个节点可能包含一个或者多个子节点</p><ul><li>contents and children：返回子节点的列表，后者返回迭代器。</li><li>descendants：后裔，会将字符串也打印出来。</li><li>srting：得到节点下的NavigableString对象</li><li>strings and stripped_strings：得到节点下的所以NString对象，后者会去除空格和空行。</li></ul></blockquote><h3 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h3><blockquote><p>每个节点或者字符串都有父节点</p><ul><li>parent：得到直接父节点</li><li>parents：得到所有的父节点</li></ul></blockquote><h3 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h3><blockquote><ul><li>next_sipling and previous_sibling：类似遍历兄弟节点</li><li>next_siplings and previous_siblings：当前节点之前或者之后的所有兄弟节点迭代输出</li></ul></blockquote><h3 id="回退和前进"><a href="#回退和前进" class="headerlink" title="回退和前进"></a>回退和前进</h3><blockquote><ul><li>next_element and previous_element：返回当前节点上一个或者下一个被解析对象</li><li>next_elements and previous_elements：对应的就是前后所有被解析的对象，就像HTML对象正在被解析一样</li></ul></blockquote><h3 id="像调用-find-all-一样调用tag"><a href="#像调用-find-all-一样调用tag" class="headerlink" title="像调用 find_all() 一样调用tag"></a>像调用 find_all() 一样调用tag</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">soup.find_all(&quot;a&quot;)</div><div class="line">soup(&quot;a&quot;)</div></pre></td></tr></table></figure><blockquote><p>这两行是等价的</p></blockquote><h3 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h3><blockquote><p>find_all是得到所有的结果，有时候我们只需要一个结果，那么直接使用find就行。<br>find_all 加上参数limit = 1，也可以实现，但是返回的结果是列表<br>find没有找到结果的时候返回<code>None</code><br>find方法多次调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">html.find(&apos;head&apos;).find(&apos;title&apos;)</div></pre></td></tr></table></figure></p></blockquote><h3 id="find-parents-和-find-parent"><a href="#find-parents-和-find-parent" class="headerlink" title="find_parents() 和 find_parent()"></a>find_parents() 和 find_parent()</h3><blockquote><p>搜索当前节点的父节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s = html.find(string=&apos;Lacie&apos;) # 找到字符串Lacie</div><div class="line">s.find_parents(&apos;a&apos;) # 字符串节点的父节点</div></pre></td></tr></table></figure></p><p>其实方法就是使用了parent和parents属性进行迭代搜索的</p></blockquote><h3 id="find-next-siblings-和-find-next-sibling"><a href="#find-next-siblings-和-find-next-sibling" class="headerlink" title="find_next_siblings() 和 find_next_sibling()"></a>find_next_siblings() 和 find_next_sibling()</h3><blockquote><p>通过next_siblings属性对当前tag之后的兄弟节点进行迭代搜索<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; first_link = html.a</div><div class="line">&gt;&gt;&gt; first_link</div><div class="line">&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</div><div class="line">&gt;&gt;&gt; first_link.find_next_siblings()</div><div class="line">[&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;, &lt;a clas</div><div class="line">s=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</div></pre></td></tr></table></figure></p></blockquote><h3 id="find-previous-siblings-和-find-previous-sibling"><a href="#find-previous-siblings-和-find-previous-sibling" class="headerlink" title="find_previous_siblings() 和 find_previous_sibling()"></a>find_previous_siblings() 和 find_previous_sibling()</h3><blockquote><p>和上面类似</p></blockquote><h3 id="find-all-next-和-find-next"><a href="#find-all-next-和-find-next" class="headerlink" title="find_all_next() 和 find_next()"></a>find_all_next() 和 find_next()</h3><blockquote><p>通过next_elements属性对当前tag进行迭代搜索<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; f_link = html.a</div><div class="line">&gt;&gt;&gt; f_link</div><div class="line">&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</div><div class="line">&gt;&gt;&gt; f_link.find_all_next(&apos;a&apos;)</div><div class="line">[&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;, &lt;a clas</div><div class="line">s=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</div><div class="line">&gt;&gt;&gt; f_link.find_all_next(string=True)</div><div class="line">[&apos;Elsie&apos;, &apos;,\n&apos;, &apos;Lacie&apos;, &apos; and\n&apos;, &apos;Tillie&apos;, &apos;;\nand they lived at the bottom o</div><div class="line">f a well.&apos;, &apos;\n&apos;, &apos;...&apos;, &apos;\n&apos;]</div></pre></td></tr></table></figure></p></blockquote><h3 id="find-all-previous-和-find-previous"><a href="#find-all-previous-和-find-previous" class="headerlink" title="find_all_previous() 和 find_previous()"></a>find_all_previous() 和 find_previous()</h3><blockquote><p>通过previous_element对当前tag进行迭代搜索<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; f_link = html.a</div><div class="line">&gt;&gt;&gt; f_link</div><div class="line">&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</div><div class="line">&gt;&gt;&gt; f_link.find_all_previous(&apos;title&apos;)</div><div class="line">[&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;]</div></pre></td></tr></table></figure></p></blockquote><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><blockquote><p>bs4支持大部分的CSS选择器：<a href="https://www.w3.org/TR/CSS2/selector.html" title="CSS Selector" target="_blank" rel="external">CSS Selector</a> <a href="http://www.w3school.com.cn/cssref/css_selectors.asp" title="CSS 选择器" target="_blank" rel="external">w3school</a></p></blockquote><blockquote><p>在 <code>Tag</code> 或 <code>BeautifulSoup</code> 对象的 <code>.select()</code> 方法中传入字符串参数, 即可使用CSS选择器的语法找到tag:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">soup.select(&quot;title&quot;)</div><div class="line"># [&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;]</div><div class="line"></div><div class="line">soup.select(&quot;p nth-of-type(3)&quot;)</div><div class="line"># [&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;]</div></pre></td></tr></table></figure></p><p>不是很懂这个选择器</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;学习bs4模块&quot;&gt;&lt;a href=&quot;#学习bs4模块&quot; class=&quot;headerlink&quot; title=&quot;学习bs4模块&quot;&gt;&lt;/a&gt;学习bs4模块&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;直接在官方网站上面学习&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="学习 python bs4" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0-python-bs4/"/>
    
  </entry>
  
  <entry>
    <title>Numpy基础</title>
    <link href="http://yoursite.com/2017/11/20/python/numpy/02_quickstart_tutorial/"/>
    <id>http://yoursite.com/2017/11/20/python/numpy/02_quickstart_tutorial/</id>
    <published>2017-11-20T13:51:00.933Z</published>
    <updated>2017-11-28T14:31:44.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NumPy基础"><a href="#NumPy基础" class="headerlink" title="NumPy基础"></a>NumPy基础</h1><blockquote><p>NumPy的主要对象是同类型的多维数组，是一张表，所有元素（通常是数字）的类型都相同。<br>维度称为axes，axes的数目为rank。如下rank为2（2维的），第一维度axes长度为2，第二维度axes长度为3.<br><code>[[ 1., 0., 0.],</code><br><code>[ 0., 1., 2.]]</code><br>NumPy的数组的类称为ndarray。Python的数组提供较少的功能，而ndarray一下重要的属性。</p></blockquote><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><blockquote><ul><li>ndarray.ndim：数组的axes（维度）的个数，维度的数量称为rank。</li><li>ndarray.shape：数组的维度。这是一个整数元组，<code>(n, m)</code>表示一个n行，m列的矩阵。</li><li>ndarray.size：为shape元素的乘积，其实就是矩阵元素个数。</li><li>ndarray.dtype：描述矩阵中元素的类型的对象。可以使用Python标准的类型，也提供其他类型，例如：numpy.int32、numpy.int16和numpy.float64。</li><li>ndarray.itemsize：数组中每个元素的字节大小。例如float64字节数为8。</li><li>ndarray.data：该缓冲区包含数组的实际元素。通常不适用这个，我们一般使用索引进行访问（前面矢量化又说不要遍历，后续看看是怎么回事）。</li></ul><p>打开中文API查看示例：<a href="http://python.usyiyi.cn/translate/NumPy_v111/user/quickstart.html" title="示例" target="_blank" rel="external">属性示例</a></p></blockquote><h2 id="数组创建"><a href="#数组创建" class="headerlink" title="数组创建"></a>数组创建</h2><blockquote><p>有几种方法来创建数组</p><ul><li>可以使用array函数从常规的Python列表或元组中创建数组，得到的数组类型从序列中元素的类型推到而出。<br><code>&gt;&gt;&gt; numpy.array([3, 4, 5])</code></li><li>array函数传入列表的列表产生2维阵列，同理3维。<br><code>&gt;&gt;&gt; numpy.array([1, 2, 3], [4, 5, 6])</code><br><code>array([[1, 2, 3]</code><br><code>[4, 5, 6]</code><br><code>])</code><blockquote><ul><li>数组的类型可以在创建的时候指定<br><code>&gt;&gt;&gt; numpy.array([1, 2, 3], dtype=complex)</code> #元素为复数形式 1. + 0.j</li></ul></blockquote></li><li>通常数组的元素是位置的，所有NumPy提供创建具体初始占位符的数组，减少数组增长的必要。<blockquote><ul><li>函数zeros创建一个由0组成的数组；</li><li>函数ones创建一个由1数组的数组；</li><li>函数empty内容是随机的并且取决于存储器的状态，元素默认类型是float64。</li></ul></blockquote></li><li>为了创建数组序列，NumPy提供了类似于range的函数，返回数组而不是列表。<blockquote><p><code>&gt;&gt;&gt; numpy.arange(1, 10, 2)</code> #使用如上的reshape函数可以改变形状。起始为1步长为2。</p></blockquote></li><li>当arange与浮点参数一起使用时，由于浮点数的精度是有限的，通常不可能预测获得的元素数量。出于这个原因，通常最好使用函数linspace，它接收我们想要的元素数量而不是步长作为参数：<br><code>&gt;&gt;&gt; numpy.linspace(1, 2, 9)</code> # 1到二之间的9个数，感觉是平均分配的样子。步长0.125<br>‘&gt;&gt;&gt; numpy.sin(numpy.linspace(0, 2*pi, 100))’ #求sin。<br>其他函数：<br>array, zeros, zeros_like, ones, ones_like, empty, empty_like, arange,<br>linspace, numpy.random.rand, numpy.random.randn, fromfunction, fromfile</li></ul></blockquote><h2 id="打印数组"><a href="#打印数组" class="headerlink" title="打印数组"></a>打印数组</h2><blockquote><p>当打印数组时，NumPy以类似于嵌套列表的方式显示它，但是使用以下布局：</p><ul><li>最后一个axes从左到右打印，</li><li>第二个到最后一个从上到下打印，</li><li>其余的也从上到下打印，每个切片与下一个用空行分开</li><li>如果数组太大，会跳过中间的部分，只打印边角部分。<blockquote><ul><li>如果需要强制打印整个数组，可以使用set_printoptions来更改打印选项<br><code>numpy.set_printoptions(threshold=&#39;nan&#39;)</code> #官方api说传入的是int值，nan目前不知道什么意思：后面查看可以传入numpy.nan，而非str类型</li></ul></blockquote></li></ul></blockquote><h3 id="reshape改变数组形状"><a href="#reshape改变数组形状" class="headerlink" title="reshape改变数组形状"></a>reshape改变数组形状</h3><blockquote><ul><li><code>a.ravel()</code> #平坦化序列，比如3 * 4的矩阵，变成一维矩阵。</li><li><code>a.reshape(x, y)</code> #转变形状到x*y 元素需要支持转换该形状才行，如果y=-1则会自动计算维度。</li><li><code>a.T</code> #转置 transposed</li><li><code>numpy.resize</code>方法直接改变数组本身</li></ul></blockquote><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="数组上的算术运算符使用元素基本，将创建一个新数组并用结果填充，差不多就是对应到每个元素，然后返回计算结果。"><a href="#数组上的算术运算符使用元素基本，将创建一个新数组并用结果填充，差不多就是对应到每个元素，然后返回计算结果。" class="headerlink" title="数组上的算术运算符使用元素基本，将创建一个新数组并用结果填充，差不多就是对应到每个元素，然后返回计算结果。"></a>数组上的算术运算符使用元素基本，将创建一个新数组并用结果填充，差不多就是对应到每个元素，然后返回计算结果。</h2><blockquote><p><code>&gt;&gt;&gt; a = numpy.array([20, 30, 40, 50])</code><br><code>&gt;&gt;&gt; b = numpy.arange(4)</code></p><ul><li><code>&gt;&gt;&gt; c = a - b</code> #对应求其差值</li><li><code>&gt;&gt;&gt; b**2</code> #b元素都乘2</li><li><code>&gt;&gt;&gt; 10*np.sin(a)</code> #对a每个元素求sin，并乘10倍值。</li><li><code>&gt;&gt;&gt; a &lt; 35</code> #对a元素做判断，返回boolean矩阵。</li><li>dot函数做矩阵的乘法：a.dot(b) np.dot(a, b)</li><li>a * b 是对a和b对应位置的元素做乘积</li></ul></blockquote><h2 id="类似的操作会修改当前数组，而不是创建新的数组："><a href="#类似的操作会修改当前数组，而不是创建新的数组：" class="headerlink" title="+= *= 类似的操作会修改当前数组，而不是创建新的数组："></a>+= *= 类似的操作会修改当前数组，而不是创建新的数组：</h2><blockquote><ul><li>‘&gt;&gt;&gt; a = np.ones((2,3), dtype=int)’</li><li><code>&gt;&gt;&gt; b = np.random.random((2, 3))</code></li><li><code>&gt;&gt;&gt; a *= 3</code></li><li><code>&gt;&gt;&gt; b += a</code></li><li><code>&gt;&gt;&gt; a += b</code> #报错， float64 to int32</li></ul></blockquote><h2 id="不同类型的数组操作，结果数组的类型对应更精确的数组，向上转型。"><a href="#不同类型的数组操作，结果数组的类型对应更精确的数组，向上转型。" class="headerlink" title="不同类型的数组操作，结果数组的类型对应更精确的数组，向上转型。"></a>不同类型的数组操作，结果数组的类型对应更精确的数组，向上转型。</h2><blockquote><ul><li>比如int32 和 float64计算 结果类型为float64</li></ul></blockquote><h2 id="许多一元操作，求和sum，可以使用ndarray的方法"><a href="#许多一元操作，求和sum，可以使用ndarray的方法" class="headerlink" title="许多一元操作，求和sum，可以使用ndarray的方法"></a>许多一元操作，求和sum，可以使用ndarray的方法</h2><blockquote><ul><li><code>sum(), max(), min()</code></li></ul></blockquote><h2 id="默认的这些操作适用于数组，就像一个数字列表求最大值，不管其形状（shape-2-3-）"><a href="#默认的这些操作适用于数组，就像一个数字列表求最大值，不管其形状（shape-2-3-）" class="headerlink" title="默认的这些操作适用于数组，就像一个数字列表求最大值，不管其形状（shape = (2*3)）"></a>默认的这些操作适用于数组，就像一个数字列表求最大值，不管其形状（shape = (2*3)）</h2><h2 id="通过axis参数，可以指定沿数组的指定轴应用操作"><a href="#通过axis参数，可以指定沿数组的指定轴应用操作" class="headerlink" title="通过axis参数，可以指定沿数组的指定轴应用操作"></a>通过axis参数，可以指定沿数组的指定轴应用操作</h2><blockquote><ul><li><code>b.sum(axis=0)</code> # 每列求和</li><li><code>b.sum(axis=1)</code> # 每行求和</li><li><code>b.cumsum(axis=1)</code> # 沿着行累积和，相反沿着列累积和</li></ul></blockquote><h2 id="另见"><a href="#另见" class="headerlink" title="另见"></a>另见</h2><blockquote><p>all, any, apply_along_axis, argmax, argmin, argsort, average, bincount, ceil, clip, conj, corrcoef, cov, cross, cumprod, cumsum, diff, dot, floor, inner, inv, lexsort, max, maximum, mean, median, min, minimum, nonzero, outer, prod, re, round, sort, std, sum, trace, transpose, var, vdot, vectorize, where</p><ul><li>all：是判断所以元素是否都为True，可以定义axis来沿着某个轴判断。</li><li>any：和all相反，判断是否有一个为Ture，是返回True，否返回False，可以传入axis 例如：b.any(0)，纵轴是否有为真的。</li><li><p>apply_along_axis(func, axis, arr)：将arr按照axis定义，行或者列取出作用在func上，并返回一个列表。</p><blockquote><p>如果上述返回标量，则返回于源arr相同形状(shape)。比如传输sorted进行排序，返回还是列表。</p></blockquote></li><li><p>argmax：查找最大值，返回索引，支持axis轴选择。如果多个大值，就返回第一次遇到的。</p></li><li>argmin：和max相反。</li><li>argsort：排序，返回排序完的索引值。可以选择算法。选择键排序。</li><li>mean：平均值，可以按轴进行。axis</li><li>diff：计算差分，out[n] = a[n+1] - a[n]，可以按轴进行。</li><li>vdot：计算点积。</li><li>还有很多函数，先不看了。</li></ul></blockquote><h2 id="索引、切片和迭代"><a href="#索引、切片和迭代" class="headerlink" title="索引、切片和迭代"></a>索引、切片和迭代</h2><h3 id="一维数组支持索引，切片和迭代，非常类似于列表和其他序列。"><a href="#一维数组支持索引，切片和迭代，非常类似于列表和其他序列。" class="headerlink" title="一维数组支持索引，切片和迭代，非常类似于列表和其他序列。"></a>一维数组支持索引，切片和迭代，非常类似于列表和其他序列。</h3><blockquote><ul><li>a[1:2]，其中<code>**</code>是次方，**(1/3) 求根号3</li></ul></blockquote><h3 id="多维数组每个轴可以有一个索引。这些索引以逗号分隔的元组给出："><a href="#多维数组每个轴可以有一个索引。这些索引以逗号分隔的元组给出：" class="headerlink" title="多维数组每个轴可以有一个索引。这些索引以逗号分隔的元组给出："></a>多维数组每个轴可以有一个索引。这些索引以逗号分隔的元组给出：</h3><blockquote><p>比如b[2,3]表示3行4列的元素，b[0:3, 1]表示行数是0,1,2的第2列，如果1数字缺失，则认为是全部列。<br>如果维度大于3，比如维度（轴，rank）为5的情况，x[1,2,:,:,:]可以等效为x[1,2,…]</p><ul><li>x[1,2,…]等效于x[1,2,:,:,:]</li><li>x[…,3]到x[:,:,:,:,3]</li><li>x[4,…,5,:]到x[4,:,:,5,:]<br>例子：y[1:5:2,::3]指的是1-4行间隔为2行，列数间隔为3进行抽取。<br>避免迭代使用索引提高性能。<br>可以使用一个数组来索引数组，提高的索引必须是索引值，比如a[np.array([1,2,3])] 索引a中的索引为1,2,3的元素。<br>并且索引数组可以是多维的生成的矩阵维度和索引一致，a[np.array([[1,2], [3,4]])]，二维矩阵，1,2,3,4对应为a一维矩阵的索引。</li><li>Boolean型索引，比如<br><code>&gt;&gt;&gt; y = np.arange(35).reshape(5,7)</code><br><code>&gt;&gt;&gt; b = y &gt; 22</code><br><code>&gt;&gt;&gt; y[b] # 这样就将y里边的大于22的数索引出来了，但是维度只有一维，并且如果索引的布尔数组和y具有相同的形状</code><br>通常，当布尔数组具有比被索引的数组更少的维度时，这等同于y [b，…]，这意味着y被索引为b，然后是多个：如同填充y。因此，结果的形状是包含布尔数组的True元素的数目的一个维度，后面是被索引的数组的剩余维度。<br>组合索引和切片，感觉就是行和列的索引，三维的话相当于两个数组，就分别对两个进行索引</li><li><code>y[1:3, 2:3] #类似的就是1-2行并且列是2列</code><br>结构化索引工具<br><code>&gt;&gt;&gt; y.shape</code><br><code>(5, 7)</code><br><code>&gt;&gt;&gt; y[:,np.newaxis,:].shape # np.newaxis 对象来新建一个维度&#39;</code>(5, 1, 7)`</li><li>可以使用索引来改变相应位置的值<br><code>y[2:7] = 1 #将2-6位置的数更改为1</code><br><code>y[2:7] = np.arange(5) #或者直接使用数组的形式</code><br>如果高类型分配给低类型的，会转型，损失精度，或者抛出错误<br>下面的一个例子比较特殊：<br><code>&gt;&gt;&gt; x = np.arange(0, 50, 10)</code><br><code>&gt;&gt;&gt; x</code><br><code>array([ 0, 10, 20, 30, 40])</code><br><code>&gt;&gt;&gt; x[np.array([1, 1, 3, 1])] += 1</code><br><code>&gt;&gt;&gt; x</code><br><code>array([ 0, 11, 20, 31, 40])</code><br>实际上我们认为1位置的数应该增加3才对，但是最终只增加1，其实是我们每次计算都采用了临时数组的方式，导致最终只增加1.</li><li>Ellipsis 等同于 ‘…’</li><li>元组不像列表索引那样会自动处理，如下例子：<br><code>&gt;&gt;&gt; z[[1,1,1,1]] # produces a large array</code><br><code>array([[[[27, 28, 29],</code><br><code>[30, 31, 32], ...</code><br><code>&gt;&gt;&gt; z[(1,1,1,1)] # returns a single value</code><br><code>40</code></li></ul></blockquote><h3 id="多维数组迭代是相对于第一个轴进行的。"><a href="#多维数组迭代是相对于第一个轴进行的。" class="headerlink" title="多维数组迭代是相对于第一个轴进行的。"></a>多维数组迭代是相对于第一个轴进行的。</h3><blockquote><p>可以使用flat，是一个迭代器。<br>如果使用x[0][2]会降低性能。因为2索引需要在前面0索引创建的数组上面继续操作。<br>另见indexing。</p></blockquote><h2 id="形状操作"><a href="#形状操作" class="headerlink" title="形状操作"></a>形状操作</h2><blockquote><p>以下的命令不会修改数组，只会返回新的数组</p><ul><li>ravel 返回连续的平坦的数组，降成一维</li><li>reshape 修改形状</li><li>T 转置<br>修改数组本身</li><li>resize：对应的reshape是返回修改的数组<br>将不同的数组堆叠</li><li>vstack</li><li>hstack h v 分别对应水平方向和垂直方向。</li><li>column_stack</li><li>row_stack column 和 row 分别对应，并且这两个方法允许1D的数组堆叠到2D数组中<br>将数组分隔成几个小的数组</li><li><code>np.hsplit(a, 3) #将a划分为3个 h是水平</code></li><li><code>np.hsplit(a, (3, 4)) #将列为3-4但是不等于4的索引分隔开来</code> </li><li>同理vsplit是垂直划分</li><li>array_split 可以指定某个轴进行划分</li></ul></blockquote><h2 id="复制和视图"><a href="#复制和视图" class="headerlink" title="复制和视图"></a>复制和视图</h2><blockquote><p>当计算和操作数组时，它们的数据有时被复制到新的数组中，有时不复制。这通常是初学者的混乱的来源。有三种情况：</p><ul><li>完全不复制<br>简单赋值不会创建数组对象或其数据的拷贝：如果将b = a 那么b和a指向的是同一个数组，改变b，a也跟着改变。<br>可变对象传递到函数引用，函数不会复制。</li><li>视图或浅复制<br>不同的数组对象可以共享相同的数据。view方法创建一个新数组对象，该对象看到相同的数据。<br><code>c=a.view()</code>, 这样改变<code>c.shape = (2,6)</code>，a的形状不会改变，但是如果<code>c[0,4] = 1234</code>，a的相应位置就会赋值为1234<br><code>c.base is a = True</code><br>对数组切片返回的也是视图</li><li>深复制<br><code>d = a.copy()</code><br>这样d就是一个新的数组</li></ul></blockquote><h2 id="函数和方法概述"><a href="#函数和方法概述" class="headerlink" title="函数和方法概述"></a>函数和方法概述</h2><blockquote><p>这里是一些有用的NumPy函数和方法名称按类别排序的列表。有关完整列表，请参见Routines。</p><ul><li>数组创建<br><code>arange, array, copy, empty, empty_like, eye, fromfile, fromfunction, identity, linspace, logspace, mgrid, ogrid, ones, ones_like, r, zeros, zeros_like</code></li><li>转换<br><code>ndarray.astype，atleast_1d，atleast_2d，atleast_3d，mat</code></li><li>操纵<br><code>array_split, column_stack, concatenate, diagonal, dsplit, dstack, hsplit, hstack, ndarray.item, newaxis, ravel, repeat, reshape, resize, squeeze, swapaxes, take, transpose, vsplit, vstack</code></li><li>问题<br><code>all，any，nonzero，where</code></li><li>顺序<br><code>argmax, argmin, argsort, max, min, ptp, searchsorted, sort</code></li><li>操作<br><code>choose, compress, cumprod, cumsum, inner, ndarray.fill, imag, prod, put, putmask, real, sum</code></li><li>基本统计<br><code>cov，mean，std，var</code><br>基本线性代数<br><code>cross，dot，outer，linalg.svd，vdot</code></li></ul></blockquote><h2 id="其他基础"><a href="#其他基础" class="headerlink" title="其他基础"></a>其他基础</h2><h3 id="广播规则"><a href="#广播规则" class="headerlink" title="广播规则"></a>广播规则</h3><blockquote><ul><li>Broadcasting允许通用函数以有意义的方式处理具有不完全相同形状的输入。</li><li>Broadcasting的第一个规则是，如果所有输入数组不具有相同数量的维度，则“1”将被重复地添加到较小数组的形状，直到所有数组具有相同数量的维度。</li><li>Broadcasting的第二个规则确保沿着特定维度具有大小为1的数组表现得好像它们具有沿着该维度具有最大形状的数组的大小。假定数组元素的值沿“Broadcasting”数组的该维度相同。</li></ul></blockquote><h3 id="花式索引技巧"><a href="#花式索引技巧" class="headerlink" title="花式索引技巧"></a>花式索引技巧</h3><blockquote><p>NumPy提供了比常规Python序列更多的索引能力。除了通过整数和切片索引之外，如前所述，数组可以由整数数组和布尔数组索引。</p><ul><li>使用索引数组索引<br><code>a[j]</code> <code>j = np.array([1,1,3]) #得出索引a是1,1,3组成的数组</code><br>如果索引的数组是多维的，结果与之对应，<code>j = np.array([[1,2,3], [4, 5, 6]])</code>，结果是形状是<code>(2, 3)</code></li><li>可以对每个维度进行单独索引<br><code>i = np.array([[0,1], [1, 2]])</code><br><code>j = np.array([[2,1], [1, 3]])</code><br><code>a[i, j]</code><br>同样的 <code>l=[i,j]</code> <code>a[l]=a[i,j]</code></li></ul></blockquote><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><blockquote><p>np.ix_[a,b,c] ???雨里雾里<br>np.ufunc.reduce ???云里雾里</p></blockquote><h3 id="线性代数-基础"><a href="#线性代数-基础" class="headerlink" title="线性代数 基础"></a>线性代数 基础</h3><blockquote><p>简单的数组操作</p><ul><li><code>a.transpose() # 矩阵转置</code> </li><li><code>np.linalg.inv(a) # 逆矩阵</code></li><li><code>np.eye(2) # 2*2的矩阵，返回对角线是1其他都是0的矩阵</code></li><li><code>np.dot(i, j) # 求矩阵乘积</code></li><li><code>np.trace(a) # 对a矩阵的对角线值求和</code></li><li><code>np.linalg.solve(a, y) # 解线性方程组 a矩阵对应参数，y对应等于后边的数</code></li><li><code>np.linalg.eig(j) # 特征向量，线性代数当时没有学好</code></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;NumPy基础&quot;&gt;&lt;a href=&quot;#NumPy基础&quot; class=&quot;headerlink&quot; title=&quot;NumPy基础&quot;&gt;&lt;/a&gt;NumPy基础&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;NumPy的主要对象是同类型的多维数组，是一张表，所有元素（通常是数字）的
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Numpy" scheme="http://yoursite.com/tags/Numpy/"/>
    
  </entry>
  
  <entry>
    <title>What is Numpy</title>
    <link href="http://yoursite.com/2017/11/16/python/numpy/01_what_is_numpy/"/>
    <id>http://yoursite.com/2017/11/16/python/numpy/01_what_is_numpy/</id>
    <published>2017-11-16T12:00:30.500Z</published>
    <updated>2017-11-16T12:15:45.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="What-is-Numpy"><a href="#What-is-Numpy" class="headerlink" title="What is Numpy"></a>What is Numpy</h1><blockquote><p><code>Numpy</code>是Python科学计算的基本包，提供对于多维数组（矩阵）等各种计算，比如c = a * b，a、b均为矩阵，可以对其进行直接计算，不用使用循环遍历。<br>本机测试计算速度为for循环遍历计算的500+倍。例子如下：目前找不到源网页，直接粘上例子。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import numpy as np </div><div class="line">import time</div><div class="line">#from timeit import timeit</div><div class="line"></div><div class="line">a = np.random.rand(1000000)</div><div class="line">b = np.random.rand(1000000)</div><div class="line"></div><div class="line">time_s = time.time()</div><div class="line">c = np.dot(a, b)</div><div class="line">time_e = time.time()</div><div class="line">print(c, 1000*(time_e - time_s))</div><div class="line"></div><div class="line">c = 0</div><div class="line">time_s = time.time()</div><div class="line">for i in range(len(a)):</div><div class="line">c += a[i] * b[i]</div><div class="line">time_e = time.time()</div><div class="line">print(c, 1000*(time_e - time_s))</div></pre></td></tr></table></figure><blockquote><p>下图所示<br><img src="/img/python/vectorization.png" alt="vectorization"></p></blockquote><h2 id="矢量化-Vectorization"><a href="#矢量化-Vectorization" class="headerlink" title="矢量化(Vectorization)"></a>矢量化(Vectorization)</h2><blockquote><p>上面的例子是矢量化的例子（Vectorization），包含以下优点：</p><ul><li>代码更简洁</li><li>更少的代码通常意味着更少的错误</li><li>代码运行更接近标准的数学符号，封装了具体的困难的运算，如上np.dot(a, b)直接计算两个矩阵的积。</li><li>矢量化导致更多的“Pythonic”(网络解释为很Python的Python代码)代码。如果没有向量化，我们的代码将会效率很低，难以读取for循环。</li></ul></blockquote><h2 id="广播-Broadcasting"><a href="#广播-Broadcasting" class="headerlink" title="广播(Broadcasting)"></a>广播(Broadcasting)</h2><blockquote><p>广播是用于描述操作的隐式逐个元素行为的术语<br>大概意思就是比如做矩阵的运算，a为一维矩阵，b为标量，如果做计算<code>a + b</code>，会自动的将a的元素都加上b（我的简单理解）</p></blockquote><h1 id="源网站"><a href="#源网站" class="headerlink" title="源网站"></a>源网站</h1><blockquote><p><a href="http://python.usyiyi.cn" title="Numpy 中文API" target="_blank" rel="external">Numpy 中文 API</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;What-is-Numpy&quot;&gt;&lt;a href=&quot;#What-is-Numpy&quot; class=&quot;headerlink&quot; title=&quot;What is Numpy&quot;&gt;&lt;/a&gt;What is Numpy&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Numpy&lt;/
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Learn Numpy" scheme="http://yoursite.com/tags/Learn-Numpy/"/>
    
  </entry>
  
  <entry>
    <title>使用 git rm --cached filename 删除提交的文件</title>
    <link href="http://yoursite.com/2017/11/05/git/git_rm_use_cached/"/>
    <id>http://yoursite.com/2017/11/05/git/git_rm_use_cached/</id>
    <published>2017-11-05T12:26:57.178Z</published>
    <updated>2017-11-05T12:27:20.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目的为了测试Markdown书写"><a href="#目的为了测试Markdown书写" class="headerlink" title="目的为了测试Markdown书写"></a>目的为了测试Markdown书写</h1><blockquote><p>本人在学习 git 的时候，前期将本地的日志文件提交到仓库，然后也就查找了相关的操作方法，最终使用此命令解决的，然后新增<code>.gitignore</code>文件，提交，再次使用<code>git status</code>这些文件就不会再次出现了，其他情况也可以使用这个方法：将数据库账号密码配置文件从远端仓库删除。</p></blockquote><h1 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h1><h2 id="git-rm-Filename-or-Foldername："><a href="#git-rm-Filename-or-Foldername：" class="headerlink" title="git rm Filename or Foldername："></a>git rm Filename or Foldername：</h2><blockquote><p>使用在当我们提交了一个不想提交的文件，可以使用其删除本地工作目录的文件，一般我们可能需要保留源文件，所以可以使用：<code>--cached</code>参数来实现只删除索引（官方：Index，跟踪的文件清单）。</p></blockquote><h2 id="git-rm-–cached-Filename-or-Foldername："><a href="#git-rm-–cached-Filename-or-Foldername：" class="headerlink" title="git rm –cached Filename or Foldername："></a>git rm –cached Filename or Foldername：</h2><blockquote><p>使用 <code>--cached</code> 将会保留本地文件，只删除暂存区的文件，提交这次修改，该文件就不会纳入版本管理了，远端的仓库也会同步这个修改，达到删除文件目的。</p></blockquote><h2 id="常用参数："><a href="#常用参数：" class="headerlink" title="常用参数："></a>常用参数：</h2><blockquote><ul><li><code>-n</code> or <code>--dry-run</code> 加上这个参数是不会做任何删除操作的，只是将符合<code>filename</code>删除的文件预览打印出来，准确的说加上这个参数会打印此操作产生影响（删除）的文件列表。<ul><li><code>git rm -n --cached txt/\\*.txt</code>  #将会列出txt目录下的符合拓展名字为.txt的文件，反斜杠<code>\</code>为转义字符。</li></ul></li><li><code>-f</code> 这个参数是强制执行的意思，如果我们已经将文件提交到暂存区，这个时候需要加上这个参数。</li><li><code>-r</code> 类似bash命令就是递归删除了，如果删除目录使用此参数。</li></ul></blockquote><h2 id="官网相关页面："><a href="#官网相关页面：" class="headerlink" title="官网相关页面："></a>官网相关页面：</h2><blockquote><p><a href="https://git-scm.com/docs/git-rm" title="get-rm" target="_blank" rel="external">git-rm</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;目的为了测试Markdown书写&quot;&gt;&lt;a href=&quot;#目的为了测试Markdown书写&quot; class=&quot;headerlink&quot; title=&quot;目的为了测试Markdown书写&quot;&gt;&lt;/a&gt;目的为了测试Markdown书写&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本
      
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git rm 删除 文件" scheme="http://yoursite.com/tags/git-rm-%E5%88%A0%E9%99%A4-%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
</feed>
