<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LKJ Hexo Blog</title>
  
  <subtitle>wow Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://returnwow.github.io/"/>
  <updated>2018-03-31T01:39:02.698Z</updated>
  <id>https://returnwow.github.io/</id>
  
  <author>
    <name>LKJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习gRPC模块</title>
    <link href="https://returnwow.github.io/2018/03/31/python/gRPC/learn_gRPC/"/>
    <id>https://returnwow.github.io/2018/03/31/python/gRPC/learn_gRPC/</id>
    <published>2018-03-31T01:38:20.588Z</published>
    <updated>2018-03-31T01:39:02.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gRPC学习笔记"><a href="#gRPC学习笔记" class="headerlink" title="gRPC学习笔记"></a>gRPC学习笔记</h1><hr><blockquote><p>学习来源 <a href="http://doc.oschina.net/grpc?t=56831" target="_blank" rel="external">开源中国</a></p></blockquote><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><blockquote><ul><li><code>gRPC</code>是一个高性能、开源和通用的RPC框架</li><li>面向移动和<code>HTTP/2</code>设计</li><li>提供跨平台、跨语言（支持多语言）支持</li><li><code>gRPC</code>基于<code>HTTP/2</code>标准设计，带来双向流、流控、头部压缩、单TCP连接上的多复用请求（连接复用吧）等等，使其在移动设备上表现更好，更省电和节省空间占用。</li></ul></blockquote><hr><h2 id="2、概述"><a href="#2、概述" class="headerlink" title="2、概述"></a>2、概述</h2><blockquote><ul><li><code>gRPC</code>是语言中立、平台中立、开源的远程过程调用（<code>RPC</code>）系统（比如可以用<code>Java</code>创建服务器，而用<code>Python</code>创建客户端）。<h3 id="2-1、gRPC是什么"><a href="#2-1、gRPC是什么" class="headerlink" title="2.1、gRPC是什么"></a>2.1、gRPC是什么</h3></li><li>与许多 <code>RPC</code> 系统类似，<code>gRPC</code> 也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 <code>gRPC</code> 服务器来处理客户端调用。在客户端拥有一个存根能够像服务端一样的方法。</li><li>使得我们可以更容易的创建分布式应用和服务<h3 id="2-2、使用protocol-buffers"><a href="#2-2、使用protocol-buffers" class="headerlink" title="2.2、使用protocol buffers"></a>2.2、使用protocol buffers</h3></li><li>是一个Google开源的成熟的结构数据序列化机制（如同<code>JSON</code>、<code>XML</code>）。</li><li><a href="http://blog.csdn.net/shensky711/article/details/69696392" target="_blank" rel="external">protocol buffers手册</a></li></ul></blockquote><hr><h2 id="3、Hello-gRPC！"><a href="#3、Hello-gRPC！" class="headerlink" title="3、Hello gRPC！"></a>3、Hello gRPC！</h2><blockquote><ul><li>创建一个官方支持，并是自己熟悉的语言的<code>RPC</code>服务（Hello World），在官方的Github上都存在相应的例子。</li><li>准备工作：本机有<code>Git</code>，然后clone需要的版本的源码。</li></ul></blockquote><h3 id="3-1、定义服务"><a href="#3-1、定义服务" class="headerlink" title="3.1、定义服务"></a>3.1、定义服务</h3><blockquote><ul><li>创建一个例子的第一步是定义一个服务（感觉就是<code>protocol buffers</code>的配置文件）：一个RPC服务通过参数和返回类型来指定可以远程调用的方法。</li><li><code>gRPC</code>通过<code>protocol buffers</code>来实现这个功能。</li><li>下面将使用<code>protocol buffers</code>接口定义语言来定义服务，使用该协议来定义参数和返回类型。客户端和服务器均使用服务定义生成的接口代码。</li></ul></blockquote><pre><code>syntax = &quot;proto3&quot;;option java_package = &quot;io.grpc.examples&quot;;package helloworld;// The greeter service definition.service Greeter {  // Sends a greeting  rpc SayHello (HelloRequest) returns (HelloReply) {}}// The request message containing the user&#39;s name.message HelloRequest {  string name = 1;}// The response message containing the greetingsmessage HelloReply {  string message = 1;}</code></pre><h3 id="3-2、生成gRPC代码"><a href="#3-2、生成gRPC代码" class="headerlink" title="3.2、生成gRPC代码"></a>3.2、生成gRPC代码</h3><blockquote><ul><li>定义好服务之后，就可以使用<code>protocol buffers</code>编译器<code>protoc</code>来创建应用所需的特定客户端和服务器的代码。生成代码的同时包括客户端的存根和服务端要实现的抽象接口，均包含<code>Greeter</code>所定义的方法。</li><li><p>可以使用如下命令生成客户端和服务器端：<br><code>./run_codegen.sh # shell只能在支持shell的平台</code></p></li><li><p>Python编译语法如下，需要安装<code>grpcio-tools</code>，使用<code>pip install grpcio-tools</code>安装，这里边包含编译的工具。</p></li></ul></blockquote><p><code>python -m grpc_tools.protoc -I../protos --python_out=. --grpc_python_out=. ../protos/helloworld.proto</code></p><blockquote><ul><li>其中 <code>-I</code>：为自定的proto文件目录，是一个目录，那么如果我们在这个文件的目录，就选择上级目录，然后定位到protos目录</li><li><code>--python_out</code> &amp; <code>--grpc_python_out</code>：明显是根据<code>proto</code>文件生成的<code>python</code>文件，包含两个文件，暂时不知道具体用处，只知道是有一个是将<code>proto</code>文件定义的<code>rpc</code>绑定到相应的东西上，另外一个相当于做了一个抽象类，里边有<code>proto</code>定义的两个调用的抽象方法，服务器需要实现的方法。</li><li>最后的是指定需要编译的<code>proto</code>文件，和前面的<code>-I</code>为组合，试了一下去掉<code>-I</code>参数反之在proto文件上加上相对路径，结果无法编译。</li><li>编译好之后，按照官方的服务器和客户端代码，在服务器上实现更新的方法，做相应处理，然后返回，在客户端调用即可。</li><li>备注：服务器和客户端必须携带生成的两个代码，这样有点类似分布式实现的Queue了。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;gRPC学习笔记&quot;&gt;&lt;a href=&quot;#gRPC学习笔记&quot; class=&quot;headerlink&quot; title=&quot;gRPC学习笔记&quot;&gt;&lt;/a&gt;gRPC学习笔记&lt;/h1&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;学习来源 &lt;a href=&quot;http://doc.osc
      
    
    </summary>
    
      <category term="Python gRPC" scheme="https://returnwow.github.io/categories/Python-gRPC/"/>
    
    
      <category term="学习 python gRPC" scheme="https://returnwow.github.io/tags/%E5%AD%A6%E4%B9%A0-python-gRPC/"/>
    
  </entry>
  
  <entry>
    <title>学习10分钟入门Pandas模块</title>
    <link href="https://returnwow.github.io/2018/03/31/python/10_minutes_to_pandas_note/10_minutes_to_pandas_note/"/>
    <id>https://returnwow.github.io/2018/03/31/python/10_minutes_to_pandas_note/10_minutes_to_pandas_note/</id>
    <published>2018-03-31T01:33:32.981Z</published>
    <updated>2018-03-31T01:37:21.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="10分钟入门Pandas笔记"><a href="#10分钟入门Pandas笔记" class="headerlink" title="10分钟入门Pandas笔记"></a>10分钟入门Pandas笔记</h1><blockquote><ul><li>引用原文：<a href="https://www.cnblogs.com/chaosimple/p/4153083.html" target="_blank" rel="external">10分钟入门Pandas</a></li></ul></blockquote><hr><h2 id="主要引用的包"><a href="#主要引用的包" class="headerlink" title="主要引用的包"></a>主要引用的包</h2><pre><code>import pandas as pd # pandas库import numpy as np # numpy库 科学计算，矩阵。import matplotlib.pyplot as plt # 可视化 画图</code></pre><h2 id="一、创建对象"><a href="#一、创建对象" class="headerlink" title="一、创建对象"></a>一、创建对象</h2><blockquote><ul><li>可以通过<a href="http://pandas.pydata.org/pandas-docs/stable/dsintro.html#dsintro" target="_blank" rel="external">Data Structure Introduction Setion</a>了解有关本节内容的详细信息。</li></ul></blockquote><h3 id="1、可以通过传递一个list对象来创建一个Series，Pandas会默认创建整型索引："><a href="#1、可以通过传递一个list对象来创建一个Series，Pandas会默认创建整型索引：" class="headerlink" title="1、可以通过传递一个list对象来创建一个Series，Pandas会默认创建整型索引："></a>1、可以通过传递一个list对象来创建一个Series，Pandas会默认创建整型索引：</h3><pre><code>&gt;&gt;&gt; s = pd.Series([1,3,5,np.nan,6,8])&gt;&gt;&gt; s0    1.01    3.02    5.03    NaN4    6.05    8.0dtype: float64</code></pre><h3 id="2、通过传递一个numpy-array，时间索引以及列标签来创建一个DataFrame："><a href="#2、通过传递一个numpy-array，时间索引以及列标签来创建一个DataFrame：" class="headerlink" title="2、通过传递一个numpy array，时间索引以及列标签来创建一个DataFrame："></a>2、通过传递一个numpy array，时间索引以及列标签来创建一个DataFrame：</h3><pre><code>&gt;&gt;&gt; dates = pd.date_range(&#39;20180329&#39;, periods=6)&gt;&gt;&gt; datesDatetimeIndex([&#39;2018-03-29&#39;, &#39;2018-03-30&#39;, &#39;2018-03-31&#39;, &#39;2018-04-01&#39;,               &#39;2018-04-02&#39;, &#39;2018-04-03&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)&gt;&gt;&gt; df = pd.DataFrame(np.random.randn(6,4), index=dates, columns=list(&#39;ABCD&#39;))&gt;&gt;&gt; df                   A         B         C         D2018-03-29  0.916819  0.146020  0.072409 -0.5964162018-03-30  2.401470 -1.407265 -0.579490  1.6532332018-03-31  0.415780  0.065466 -1.239546 -0.8280742018-04-01 -1.917880 -0.470291 -1.102185  0.2337112018-04-02  0.504557 -2.568238 -0.411014 -0.5240402018-04-03  0.797517 -1.459728  1.254905 -0.083599</code></pre><h3 id="3、通过传递一个能够被转换成类似序列结果的字典对象来创建一个DataFrame："><a href="#3、通过传递一个能够被转换成类似序列结果的字典对象来创建一个DataFrame：" class="headerlink" title="3、通过传递一个能够被转换成类似序列结果的字典对象来创建一个DataFrame："></a>3、通过传递一个能够被转换成类似序列结果的字典对象来创建一个DataFrame：</h3><pre><code>&gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;:1,  &#39;B&#39;:pd.Timestamp(&#39;20180329&#39;), &#39;C&#39;:pd.Series(1, index=list(range(4))), &#39;D&#39;:np.array([3]*4, dtype=&#39;int32&#39;), &#39;E&#39;:pd.Categorical([&#39;test&#39;, &#39;train&#39;, &#39;test&#39;, &#39;train&#39;]), &#39;F&#39;:&#39;foo&#39;})&gt;&gt;&gt; df   A          B  C  D      E    F0  1 2018-03-29  1  3   test  foo1  1 2018-03-29  1  3  train  foo2  1 2018-03-29  1  3   test  foo3  1 2018-03-29  1  3  train  foo</code></pre><h3 id="4、查看不同列的数据类型"><a href="#4、查看不同列的数据类型" class="headerlink" title="4、查看不同列的数据类型"></a>4、查看不同列的数据类型</h3><blockquote><ul><li><code>df.dtypes</code><pre><code>&gt;&gt; df.dtypesA             int64B    datetime64[ns]C             int64D             int64E          categoryF            objectdtype: object</code></pre></li></ul></blockquote><h3 id="5、如果使用的是IPython，使用Tab自动补全功能会自动识别所有的数学以及自定义的列。"><a href="#5、如果使用的是IPython，使用Tab自动补全功能会自动识别所有的数学以及自定义的列。" class="headerlink" title="5、如果使用的是IPython，使用Tab自动补全功能会自动识别所有的数学以及自定义的列。"></a>5、如果使用的是<code>IPython</code>，使用<code>Tab</code>自动补全功能会自动识别所有的数学以及自定义的列。</h3><h2 id="二、查看数据"><a href="#二、查看数据" class="headerlink" title="二、查看数据"></a>二、查看数据</h2><blockquote><ul><li>详情请参阅：<a href="http://pandas.pydata.org/pandas-docs/stable/basics.html#basics" target="_blank" rel="external">Basics Section</a><h3 id="1、查看frame中头部和尾部的行"><a href="#1、查看frame中头部和尾部的行" class="headerlink" title="1、查看frame中头部和尾部的行"></a>1、查看frame中头部和尾部的行</h3><pre><code>&gt;&gt; df A          B  C  D      E    F0  1 2018-03-29  1  3   test  foo1  1 2018-03-29  1  3  train  foo2  1 2018-03-29  1  3   test  foo3  1 2018-03-29  1  3  train  foo&gt;&gt; df.head(2) A          B  C  D      E    F0  1 2018-03-29  1  3   test  foo1  1 2018-03-29  1  3  train  foo&gt;&gt; df.tail(2) A          B  C  D      E    F2  1 2018-03-29  1  3   test  foo3  1 2018-03-29  1  3  train  foo</code></pre><h3 id="2、查看索引、列和底层的numpy数据："><a href="#2、查看索引、列和底层的numpy数据：" class="headerlink" title="2、查看索引、列和底层的numpy数据："></a>2、查看索引、列和底层的numpy数据：</h3><pre><code>&gt;&gt; df A          B  C  D      E    F0  1 2018-03-29  1  3   test  foo1  1 2018-03-29  1  3  train  foo2  1 2018-03-29  1  3   test  foo3  1 2018-03-29  1  3  train  foo&gt;&gt; df.indexInt64Index([0, 1, 2, 3], dtype=&#39;int64&#39;)&gt;&gt; df.columnsIndex([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;], dtype=&#39;object&#39;)&gt;&gt; df.valuesarray([[1, Timestamp(&#39;2018-03-29 00:00:00&#39;), 1, 3, &#39;test&#39;, &#39;foo&#39;],     [1, Timestamp(&#39;2018-03-29 00:00:00&#39;), 1, 3, &#39;train&#39;, &#39;foo&#39;],     [1, Timestamp(&#39;2018-03-29 00:00:00&#39;), 1, 3, &#39;test&#39;, &#39;foo&#39;],     [1, Timestamp(&#39;2018-03-29 00:00:00&#39;), 1, 3, &#39;train&#39;, &#39;foo&#39;]], dtype=object)</code></pre></li></ul><h3 id="3、使用describe-对数据进行快速统计汇总："><a href="#3、使用describe-对数据进行快速统计汇总：" class="headerlink" title="3、使用describe()对数据进行快速统计汇总："></a>3、使用<code>describe()</code>对数据进行快速统计汇总：</h3><pre><code>&gt;&gt; df.describe()         A    C    Dcount  4.0  4.0  4.0mean   1.0  1.0  3.0std    0.0  0.0  0.0min    1.0  1.0  3.025%    1.0  1.0  3.050%    1.0  1.0  3.075%    1.0  1.0  3.0max    1.0  1.0  3.0&gt;&gt; df   A          B  C  D      E    F0  1 2018-03-29  1  3   test  foo1  1 2018-03-29  1  3  train  foo2  1 2018-03-29  1  3   test  foo3  1 2018-03-29  1  3  train  foo&gt;&gt;</code></pre><h3 id="4、对数据进行转置操作"><a href="#4、对数据进行转置操作" class="headerlink" title="4、对数据进行转置操作"></a>4、对数据进行转置操作</h3><p>```</p><blockquote><blockquote><p>df.T<br>                     0                    1                    2  \<br>A                    1                    1                    1<br>B  2018-03-29 00:00:00  2018-03-29 00:00:00  2018-03-29 00:00:00<br>C                    1                    1                    1<br>D                    3                    3                    3<br>E                 test                train                 test<br>F                  foo                  foo                  foo</p></blockquote></blockquote></blockquote><pre><code>                 3</code></pre><p>A                    1<br>B  2018-03-29 00:00:00<br>C                    1<br>D                    3<br>E                train<br>F                  foo</p><pre><code>&gt; ### 5、按轴进行排序：横轴纵轴是什么？？</code></pre><blockquote><blockquote><blockquote><p>df.sort_index(axis=1, ascending=False)<br>                   D         C         B         A<br>2018-03-29  0.621323  0.232728 -0.245439  1.887637<br>2018-03-30 -0.687133  0.794514  0.462420 -2.270712<br>2018-03-31 -1.453160 -0.512256  0.554050 -1.068204<br>2018-04-01 -1.947354  1.232493  0.656760  0.430766<br>2018-04-02  0.745403  0.529783  0.390616 -0.349892<br>2018-04-03 -0.332525  0.146019 -0.361226 -0.666926<br>```</p></blockquote></blockquote><h3 id="6、按值进行排序："><a href="#6、按值进行排序：" class="headerlink" title="6、按值进行排序："></a>6、按值进行排序：</h3><pre><code>&gt;&gt; df.sort_values(&#39;B&#39;)                   A         B         C         D2018-04-03 -0.666926 -0.361226  0.146019 -0.3325252018-03-29  1.887637 -0.245439  0.232728  0.6213232018-04-02 -0.349892  0.390616  0.529783  0.7454032018-03-30 -2.270712  0.462420  0.794514 -0.6871332018-03-31 -1.068204  0.554050 -0.512256 -1.4531602018-04-01  0.430766  0.656760  1.232493 -1.947354&gt;&gt; df                   A         B         C         D2018-03-29  1.887637 -0.245439  0.232728  0.6213232018-03-30 -2.270712  0.462420  0.794514 -0.6871332018-03-31 -1.068204  0.554050 -0.512256 -1.4531602018-04-01  0.430766  0.656760  1.232493 -1.9473542018-04-02 -0.349892  0.390616  0.529783  0.7454032018-04-03 -0.666926 -0.361226  0.146019 -0.332525</code></pre></blockquote><h2 id="三、选择"><a href="#三、选择" class="headerlink" title="三、选择"></a>三、选择</h2><blockquote><ul><li>虽然标准的Python/Numpy的选择和设置表达式都能够直接派上用场，但是作为工程使用的代码，我们推荐使用经过优化的pandas数据访问方式： .at, .iat, .loc, .iloc 和 .ix详情请参阅<a href="http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing" target="_blank" rel="external">Indexing and Selecing Data</a> 和 <a href="http://pandas.pydata.org/pandas-docs/stable/advanced.html#advanced" target="_blank" rel="external">MultiIndex / Advanced Indexing</a>。</li></ul><h3 id="获取："><a href="#获取：" class="headerlink" title="获取："></a>获取：</h3><ul><li><code>df[&#39;A&#39;]</code>选择一个单独的列，这将会返回一个<code>Series</code>，等同于<code>df.A</code><pre><code>&gt;&gt; df[&#39;A&#39;]2018-03-29    1.8876372018-03-30   -2.2707122018-03-31   -1.0682042018-04-01    0.4307662018-04-02   -0.3498922018-04-03   -0.666926Freq: D, Name: A, dtype: float64</code></pre></li><li>通过[]进行选择，这将会对行进行切片：<pre><code>&gt;&gt; df[&#39;20180329&#39;:&#39;20180331&#39;]                 A         B         C         D2018-03-29  1.887637 -0.245439  0.232728  0.6213232018-03-30 -2.270712  0.462420  0.794514 -0.6871332018-03-31 -1.068204  0.554050 -0.512256 -1.453160&gt;&gt; df[0:3]                 A         B         C         D2018-03-29  1.887637 -0.245439  0.232728  0.6213232018-03-30 -2.270712  0.462420  0.794514 -0.6871332018-03-31 -1.068204  0.554050 -0.512256 -1.453160</code></pre></li></ul><h3 id="通过标签选择"><a href="#通过标签选择" class="headerlink" title="通过标签选择"></a>通过标签选择</h3><ul><li>使用标签来获取一个交叉的区域：<pre><code>&gt;&gt; df.loc[dates[0]]A    1.887637B   -0.245439C    0.232728D    0.621323Name: 2018-03-29 00:00:00, dtype: float64&gt;&gt; df.loc[&#39;20180329&#39;]A    1.887637B   -0.245439C    0.232728D    0.621323Name: 2018-03-29 00:00:00, dtype: float64</code></pre></li><li>通过标签来在多个轴上进行选择：<pre><code>&gt;&gt; df.loc[:, [&#39;A&#39;,&#39;C&#39;]]                 A         C2018-03-29  1.887637  0.2327282018-03-30 -2.270712  0.7945142018-03-31 -1.068204 -0.5122562018-04-01  0.430766  1.2324932018-04-02 -0.349892  0.5297832018-04-03 -0.666926  0.146019</code></pre></li><li></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;10分钟入门Pandas笔记&quot;&gt;&lt;a href=&quot;#10分钟入门Pandas笔记&quot; class=&quot;headerlink&quot; title=&quot;10分钟入门Pandas笔记&quot;&gt;&lt;/a&gt;10分钟入门Pandas笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;引用原
      
    
    </summary>
    
      <category term="Python Pandas 10-minutes" scheme="https://returnwow.github.io/categories/Python-Pandas-10-minutes/"/>
    
    
      <category term="学习 python Pandas" scheme="https://returnwow.github.io/tags/%E5%AD%A6%E4%B9%A0-python-Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Python进制问题</title>
    <link href="https://returnwow.github.io/2018/01/27/python/common/hex&amp;octal_problem/"/>
    <id>https://returnwow.github.io/2018/01/27/python/common/hex&amp;octal_problem/</id>
    <published>2018-01-27T00:44:05.672Z</published>
    <updated>2018-01-27T02:20:31.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="16进制和8进制的问题"><a href="#16进制和8进制的问题" class="headerlink" title="16进制和8进制的问题"></a>16进制和8进制的问题</h1><blockquote><p>今天在网上看到有人在问<code>\x20</code>（16进制）和<code>\20</code>（8进制）的问题</p><pre><code>&gt;&gt; &#39;\x20&#39;&#39; &#39;&gt;&gt; &#39;\20&#39;&#39;\x10&#39;</code></pre><p>如上，因为这个存在特殊性：<code>\x20</code>对应是10进制是<code>32</code>，而<code>32</code>Ascii码对应的控制字符空格<code>Space</code>，这个一眼就看出来了是16进制，而且也知道是16进制。<br>然而<code>\20</code>就不好解释了，平时接触8进制也较少，刚开始以为是自动转换16进制，但是打印的结果显然推翻了结论，后续还想到<code>\</code>是转义字符，那么<code>\2</code>等有特殊意义。<br>于是开始从<code>\1</code>打印到<code>\10</code>，如下所示：</p><pre><code>&gt;&gt; &#39;\7&#39;&#39;\x07&#39;&gt;&gt; &#39;\8&#39;&#39;\\8&#39;&gt;&gt; &#39;\9&#39;&#39;\\9&#39;&gt;&gt; &#39;\10&#39;&#39;\x08&#39;</code></pre><p>发现<code>\8</code>打印很奇怪，<code>\10</code>打印的16进制是<code>\x08</code>，然后才想到是8进制，因为8进制表示10进制8需要进位，所以8进制的8就是<code>\10</code>。</p></blockquote><h2 id="ASCII码表"><a href="#ASCII码表" class="headerlink" title="ASCII码表"></a>ASCII码表</h2><blockquote><p><a href="https://baike.baidu.com/item/ASCII/309296?fr=aladdin&amp;fromid=19660475&amp;fromtitle=ascii%E7%A0%81%E8%A1%A8" title="百度百科Ascii码" target="_blank" rel="external">来源百度百科</a></p></blockquote><table><thead><tr><th style="text-align:left">Bin(二进制)</th><th style="text-align:center">Oct(八进制)</th><th style="text-align:center">Dec(十进制)</th><th style="text-align:center">Hex(十六进制)</th><th style="text-align:left">缩写/字符</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:left">0000 0000</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:left">NUL(null)</td><td style="text-align:center">空字符</td></tr><tr><td style="text-align:left">0000 0001</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:left">SOH(start of headline)</td><td style="text-align:center">标题开始</td></tr><tr><td style="text-align:left">0000 0010</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:left">STX (start of text)</td><td style="text-align:center">正文开始</td></tr><tr><td style="text-align:left">0000 0011</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:left">ETX (end of text)</td><td style="text-align:center">正文结束</td></tr><tr><td style="text-align:left">0000 0100</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:left">EOT (end of transmission)</td><td style="text-align:center">传输结束</td></tr><tr><td style="text-align:left">0000 0101</td><td style="text-align:center">5</td><td style="text-align:center">5</td><td style="text-align:center">5</td><td style="text-align:left">ENQ (enquiry)</td><td style="text-align:center">请求</td></tr><tr><td style="text-align:left">0000 0110</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:left">ACK (acknowledge)</td><td style="text-align:center">收到通知</td></tr><tr><td style="text-align:left">0000 0111</td><td style="text-align:center">7</td><td style="text-align:center">7</td><td style="text-align:center">7</td><td style="text-align:left">BEL (bell)</td><td style="text-align:center">响铃</td></tr><tr><td style="text-align:left">0000 1000</td><td style="text-align:center">10</td><td style="text-align:center">8</td><td style="text-align:center">8</td><td style="text-align:left">BS (backspace)</td><td style="text-align:center">退格</td></tr><tr><td style="text-align:left">0000 1001</td><td style="text-align:center">11</td><td style="text-align:center">9</td><td style="text-align:center">9</td><td style="text-align:left">HT (horizontal tab)</td><td style="text-align:center">水平制表符</td></tr><tr><td style="text-align:left">0000 1010</td><td style="text-align:center">12</td><td style="text-align:center">10</td><td style="text-align:center">0A</td><td style="text-align:left">“LF (NL line feed new line)”</td><td style="text-align:center">换行键</td></tr><tr><td style="text-align:left">0000 1011</td><td style="text-align:center">13</td><td style="text-align:center">11</td><td style="text-align:center">0B</td><td style="text-align:left">VT (vertical tab)</td><td style="text-align:center">垂直制表符</td></tr><tr><td style="text-align:left">0000 1100</td><td style="text-align:center">14</td><td style="text-align:center">12</td><td style="text-align:center">0C</td><td style="text-align:left">“FF (NP form feed new page)”</td><td style="text-align:center">换页键</td></tr><tr><td style="text-align:left">0000 1101</td><td style="text-align:center">15</td><td style="text-align:center">13</td><td style="text-align:center">0D</td><td style="text-align:left">CR (carriage return)</td><td style="text-align:center">回车键</td></tr><tr><td style="text-align:left">0000 1110</td><td style="text-align:center">16</td><td style="text-align:center">14</td><td style="text-align:center">0E</td><td style="text-align:left">SO (shift out)</td><td style="text-align:center">不用切换</td></tr><tr><td style="text-align:left">0000 1111</td><td style="text-align:center">17</td><td style="text-align:center">15</td><td style="text-align:center">0F</td><td style="text-align:left">SI (shift in)</td><td style="text-align:center">启用切换</td></tr><tr><td style="text-align:left">0001 0000</td><td style="text-align:center">20</td><td style="text-align:center">16</td><td style="text-align:center">10</td><td style="text-align:left">DLE (data link escape)</td><td style="text-align:center">数据链路转义</td></tr><tr><td style="text-align:left">0001 0001</td><td style="text-align:center">21</td><td style="text-align:center">17</td><td style="text-align:center">11</td><td style="text-align:left">DC1 (device control 1)</td><td style="text-align:center">设备控制1</td></tr><tr><td style="text-align:left">0001 0010</td><td style="text-align:center">22</td><td style="text-align:center">18</td><td style="text-align:center">12</td><td style="text-align:left">DC2 (device control 2)</td><td style="text-align:center">设备控制2</td></tr><tr><td style="text-align:left">0001 0011</td><td style="text-align:center">23</td><td style="text-align:center">19</td><td style="text-align:center">13</td><td style="text-align:left">DC3 (device control 3)</td><td style="text-align:center">设备控制3</td></tr><tr><td style="text-align:left">0001 0100</td><td style="text-align:center">24</td><td style="text-align:center">20</td><td style="text-align:center">14</td><td style="text-align:left">DC4 (device control 4)</td><td style="text-align:center">设备控制4</td></tr><tr><td style="text-align:left">0001 0101</td><td style="text-align:center">25</td><td style="text-align:center">21</td><td style="text-align:center">15</td><td style="text-align:left">NAK (negative acknowledge)</td><td style="text-align:center">拒绝接收</td></tr><tr><td style="text-align:left">0001 0110</td><td style="text-align:center">26</td><td style="text-align:center">22</td><td style="text-align:center">16</td><td style="text-align:left">SYN (synchronous idle)</td><td style="text-align:center">同步空闲</td></tr><tr><td style="text-align:left">0001 0111</td><td style="text-align:center">27</td><td style="text-align:center">23</td><td style="text-align:center">17</td><td style="text-align:left">ETB (end of trans. block)</td><td style="text-align:center">结束传输块</td></tr><tr><td style="text-align:left">0001 1000</td><td style="text-align:center">30</td><td style="text-align:center">24</td><td style="text-align:center">18</td><td style="text-align:left">CAN (cancel)</td><td style="text-align:center">取消</td></tr><tr><td style="text-align:left">0001 1001</td><td style="text-align:center">31</td><td style="text-align:center">25</td><td style="text-align:center">19</td><td style="text-align:left">EM (end of medium)</td><td style="text-align:center">媒介结束</td></tr><tr><td style="text-align:left">0001 1010</td><td style="text-align:center">32</td><td style="text-align:center">26</td><td style="text-align:center">1A</td><td style="text-align:left">SUB (substitute)</td><td style="text-align:center">代替</td></tr><tr><td style="text-align:left">0001 1011</td><td style="text-align:center">33</td><td style="text-align:center">27</td><td style="text-align:center">1B</td><td style="text-align:left">ESC (escape)</td><td style="text-align:center">换码(溢出)</td></tr><tr><td style="text-align:left">0001 1100</td><td style="text-align:center">34</td><td style="text-align:center">28</td><td style="text-align:center">1C</td><td style="text-align:left">FS (file separator)</td><td style="text-align:center">文件分隔符</td></tr><tr><td style="text-align:left">0001 1101</td><td style="text-align:center">35</td><td style="text-align:center">29</td><td style="text-align:center">1D</td><td style="text-align:left">GS (group separator)</td><td style="text-align:center">分组符</td></tr><tr><td style="text-align:left">0001 1110</td><td style="text-align:center">36</td><td style="text-align:center">30</td><td style="text-align:center">1E</td><td style="text-align:left">RS (record separator)</td><td style="text-align:center">记录分隔符</td></tr><tr><td style="text-align:left">0001 1111</td><td style="text-align:center">37</td><td style="text-align:center">31</td><td style="text-align:center">1F</td><td style="text-align:left">US (unit separator)</td><td style="text-align:center">单元分隔符</td></tr><tr><td style="text-align:left">0010 0000</td><td style="text-align:center">40</td><td style="text-align:center">32</td><td style="text-align:center">20</td><td style="text-align:left">(space)</td><td style="text-align:center">空格</td></tr><tr><td style="text-align:left">0010 0001</td><td style="text-align:center">41</td><td style="text-align:center">33</td><td style="text-align:center">21</td><td style="text-align:left">!</td><td style="text-align:center">叹号</td></tr><tr><td style="text-align:left">0010 0010</td><td style="text-align:center">42</td><td style="text-align:center">34</td><td style="text-align:center">22</td><td style="text-align:left">“”””</td><td style="text-align:center">双引号</td></tr><tr><td style="text-align:left">0010 0011</td><td style="text-align:center">43</td><td style="text-align:center">35</td><td style="text-align:center">23</td><td style="text-align:left">#</td><td style="text-align:center">井号</td></tr><tr><td style="text-align:left">0010 0100</td><td style="text-align:center">44</td><td style="text-align:center">36</td><td style="text-align:center">24</td><td style="text-align:left">$</td><td style="text-align:center">美元符</td></tr><tr><td style="text-align:left">0010 0101</td><td style="text-align:center">45</td><td style="text-align:center">37</td><td style="text-align:center">25</td><td style="text-align:left">%</td><td style="text-align:center">百分号</td></tr><tr><td style="text-align:left">0010 0110</td><td style="text-align:center">46</td><td style="text-align:center">38</td><td style="text-align:center">26</td><td style="text-align:left">&amp;</td><td style="text-align:center">和号</td></tr><tr><td style="text-align:left">0010 0111</td><td style="text-align:center">47</td><td style="text-align:center">39</td><td style="text-align:center">27</td><td style="text-align:left">‘</td><td style="text-align:center">闭单引号</td></tr><tr><td style="text-align:left">0010 1000</td><td style="text-align:center">50</td><td style="text-align:center">40</td><td style="text-align:center">28</td><td style="text-align:left">(</td><td style="text-align:center">开括号</td></tr><tr><td style="text-align:left">0010 1001</td><td style="text-align:center">51</td><td style="text-align:center">41</td><td style="text-align:center">29</td><td style="text-align:left">)</td><td style="text-align:center">闭括号</td></tr><tr><td style="text-align:left">0010 1010</td><td style="text-align:center">52</td><td style="text-align:center">42</td><td style="text-align:center">2A</td><td style="text-align:left">*</td><td style="text-align:center">星号</td></tr><tr><td style="text-align:left">0010 1011</td><td style="text-align:center">53</td><td style="text-align:center">43</td><td style="text-align:center">2B</td><td style="text-align:left">+</td><td style="text-align:center">加号</td></tr><tr><td style="text-align:left">0010 1100</td><td style="text-align:center">54</td><td style="text-align:center">44</td><td style="text-align:center">2C</td><td style="text-align:left">“,”</td><td style="text-align:center">逗号</td></tr><tr><td style="text-align:left">0010 1101</td><td style="text-align:center">55</td><td style="text-align:center">45</td><td style="text-align:center">2D</td><td style="text-align:left">-</td><td style="text-align:center">减号/破折号</td></tr><tr><td style="text-align:left">0010 1110</td><td style="text-align:center">56</td><td style="text-align:center">46</td><td style="text-align:center">2E</td><td style="text-align:left">.</td><td style="text-align:center">句号</td></tr><tr><td style="text-align:left">101111</td><td style="text-align:center">57</td><td style="text-align:center">47</td><td style="text-align:center">2F</td><td style="text-align:left">/</td><td style="text-align:center">斜杠</td></tr><tr><td style="text-align:left">110000</td><td style="text-align:center">60</td><td style="text-align:center">48</td><td style="text-align:center">30</td><td style="text-align:left">0</td><td style="text-align:center">数字0</td></tr><tr><td style="text-align:left">110001</td><td style="text-align:center">61</td><td style="text-align:center">49</td><td style="text-align:center">31</td><td style="text-align:left">1</td><td style="text-align:center">数字1</td></tr><tr><td style="text-align:left">110010</td><td style="text-align:center">62</td><td style="text-align:center">50</td><td style="text-align:center">32</td><td style="text-align:left">2</td><td style="text-align:center">数字2</td></tr><tr><td style="text-align:left">110011</td><td style="text-align:center">63</td><td style="text-align:center">51</td><td style="text-align:center">33</td><td style="text-align:left">3</td><td style="text-align:center">数字3</td></tr><tr><td style="text-align:left">110100</td><td style="text-align:center">64</td><td style="text-align:center">52</td><td style="text-align:center">34</td><td style="text-align:left">4</td><td style="text-align:center">数字4</td></tr><tr><td style="text-align:left">110101</td><td style="text-align:center">65</td><td style="text-align:center">53</td><td style="text-align:center">35</td><td style="text-align:left">5</td><td style="text-align:center">数字5</td></tr><tr><td style="text-align:left">110110</td><td style="text-align:center">66</td><td style="text-align:center">54</td><td style="text-align:center">36</td><td style="text-align:left">6</td><td style="text-align:center">数字6</td></tr><tr><td style="text-align:left">110111</td><td style="text-align:center">67</td><td style="text-align:center">55</td><td style="text-align:center">37</td><td style="text-align:left">7</td><td style="text-align:center">数字7</td></tr><tr><td style="text-align:left">111000</td><td style="text-align:center">70</td><td style="text-align:center">56</td><td style="text-align:center">38</td><td style="text-align:left">8</td><td style="text-align:center">数字8</td></tr><tr><td style="text-align:left">111001</td><td style="text-align:center">71</td><td style="text-align:center">57</td><td style="text-align:center">39</td><td style="text-align:left">9</td><td style="text-align:center">数字9</td></tr><tr><td style="text-align:left">111010</td><td style="text-align:center">72</td><td style="text-align:center">58</td><td style="text-align:center">3A</td><td style="text-align:left">:</td><td style="text-align:center">冒号</td></tr><tr><td style="text-align:left">111011</td><td style="text-align:center">73</td><td style="text-align:center">59</td><td style="text-align:center">3B</td><td style="text-align:left">;</td><td style="text-align:center">分号</td></tr><tr><td style="text-align:left">111100</td><td style="text-align:center">74</td><td style="text-align:center">60</td><td style="text-align:center">3C</td><td style="text-align:left">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="text-align:left">111101</td><td style="text-align:center">75</td><td style="text-align:center">61</td><td style="text-align:center">3D</td><td style="text-align:left">=</td><td style="text-align:center">等号</td></tr><tr><td style="text-align:left">111110</td><td style="text-align:center">76</td><td style="text-align:center">62</td><td style="text-align:center">3E</td><td style="text-align:left">&gt;</td><td style="text-align:center">大于</td></tr><tr><td style="text-align:left">111111</td><td style="text-align:center">77</td><td style="text-align:center">63</td><td style="text-align:center">3F</td><td style="text-align:left">?</td><td style="text-align:center">问号</td></tr><tr><td style="text-align:left">1000000</td><td style="text-align:center">100</td><td style="text-align:center">64</td><td style="text-align:center">40</td><td style="text-align:left">@</td><td style="text-align:center">电子邮件符号</td></tr><tr><td style="text-align:left">1000001</td><td style="text-align:center">101</td><td style="text-align:center">65</td><td style="text-align:center">41</td><td style="text-align:left">A</td><td style="text-align:center">大写字母A</td></tr><tr><td style="text-align:left">1000010</td><td style="text-align:center">102</td><td style="text-align:center">66</td><td style="text-align:center">42</td><td style="text-align:left">B</td><td style="text-align:center">大写字母B</td></tr><tr><td style="text-align:left">1000011</td><td style="text-align:center">103</td><td style="text-align:center">67</td><td style="text-align:center">43</td><td style="text-align:left">C</td><td style="text-align:center">大写字母C</td></tr><tr><td style="text-align:left">1000100</td><td style="text-align:center">104</td><td style="text-align:center">68</td><td style="text-align:center">44</td><td style="text-align:left">D</td><td style="text-align:center">大写字母D</td></tr><tr><td style="text-align:left">1000101</td><td style="text-align:center">105</td><td style="text-align:center">69</td><td style="text-align:center">45</td><td style="text-align:left">E</td><td style="text-align:center">大写字母E</td></tr><tr><td style="text-align:left">1000110</td><td style="text-align:center">106</td><td style="text-align:center">70</td><td style="text-align:center">46</td><td style="text-align:left">F</td><td style="text-align:center">大写字母F</td></tr><tr><td style="text-align:left">1000111</td><td style="text-align:center">107</td><td style="text-align:center">71</td><td style="text-align:center">47</td><td style="text-align:left">G</td><td style="text-align:center">大写字母G</td></tr><tr><td style="text-align:left">1001000</td><td style="text-align:center">110</td><td style="text-align:center">72</td><td style="text-align:center">48</td><td style="text-align:left">H</td><td style="text-align:center">大写字母H</td></tr><tr><td style="text-align:left">1001001</td><td style="text-align:center">111</td><td style="text-align:center">73</td><td style="text-align:center">49</td><td style="text-align:left">I</td><td style="text-align:center">大写字母I</td></tr><tr><td style="text-align:left">1001010</td><td style="text-align:center">112</td><td style="text-align:center">74</td><td style="text-align:center">4A</td><td style="text-align:left">J</td><td style="text-align:center">大写字母J</td></tr><tr><td style="text-align:left">1001011</td><td style="text-align:center">113</td><td style="text-align:center">75</td><td style="text-align:center">4B</td><td style="text-align:left">K</td><td style="text-align:center">大写字母K</td></tr><tr><td style="text-align:left">1001100</td><td style="text-align:center">114</td><td style="text-align:center">76</td><td style="text-align:center">4C</td><td style="text-align:left">L</td><td style="text-align:center">大写字母L</td></tr><tr><td style="text-align:left">1001101</td><td style="text-align:center">115</td><td style="text-align:center">77</td><td style="text-align:center">4D</td><td style="text-align:left">M</td><td style="text-align:center">大写字母M</td></tr><tr><td style="text-align:left">1001110</td><td style="text-align:center">116</td><td style="text-align:center">78</td><td style="text-align:center">4E</td><td style="text-align:left">N</td><td style="text-align:center">大写字母N</td></tr><tr><td style="text-align:left">1001111</td><td style="text-align:center">117</td><td style="text-align:center">79</td><td style="text-align:center">4F</td><td style="text-align:left">O</td><td style="text-align:center">大写字母O</td></tr><tr><td style="text-align:left">1010000</td><td style="text-align:center">120</td><td style="text-align:center">80</td><td style="text-align:center">50</td><td style="text-align:left">P</td><td style="text-align:center">大写字母P</td></tr><tr><td style="text-align:left">1010001</td><td style="text-align:center">121</td><td style="text-align:center">81</td><td style="text-align:center">51</td><td style="text-align:left">Q</td><td style="text-align:center">大写字母Q</td></tr><tr><td style="text-align:left">1010010</td><td style="text-align:center">122</td><td style="text-align:center">82</td><td style="text-align:center">52</td><td style="text-align:left">R</td><td style="text-align:center">大写字母R</td></tr><tr><td style="text-align:left">1010011</td><td style="text-align:center">123</td><td style="text-align:center">83</td><td style="text-align:center">53</td><td style="text-align:left">S</td><td style="text-align:center">大写字母S</td></tr><tr><td style="text-align:left">1010100</td><td style="text-align:center">124</td><td style="text-align:center">84</td><td style="text-align:center">54</td><td style="text-align:left">T</td><td style="text-align:center">大写字母T</td></tr><tr><td style="text-align:left">1010101</td><td style="text-align:center">125</td><td style="text-align:center">85</td><td style="text-align:center">55</td><td style="text-align:left">U</td><td style="text-align:center">大写字母U</td></tr><tr><td style="text-align:left">1010110</td><td style="text-align:center">126</td><td style="text-align:center">86</td><td style="text-align:center">56</td><td style="text-align:left">V</td><td style="text-align:center">大写字母V</td></tr><tr><td style="text-align:left">1010111</td><td style="text-align:center">127</td><td style="text-align:center">87</td><td style="text-align:center">57</td><td style="text-align:left">W</td><td style="text-align:center">大写字母W</td></tr><tr><td style="text-align:left">1011000</td><td style="text-align:center">130</td><td style="text-align:center">88</td><td style="text-align:center">58</td><td style="text-align:left">X</td><td style="text-align:center">大写字母X</td></tr><tr><td style="text-align:left">1011001</td><td style="text-align:center">131</td><td style="text-align:center">89</td><td style="text-align:center">59</td><td style="text-align:left">Y</td><td style="text-align:center">大写字母Y</td></tr><tr><td style="text-align:left">1011010</td><td style="text-align:center">132</td><td style="text-align:center">90</td><td style="text-align:center">5A</td><td style="text-align:left">Z</td><td style="text-align:center">大写字母Z</td></tr><tr><td style="text-align:left">1011011</td><td style="text-align:center">133</td><td style="text-align:center">91</td><td style="text-align:center">5B</td><td style="text-align:left">[</td><td style="text-align:center">开方括号</td></tr><tr><td style="text-align:left">1011100</td><td style="text-align:center">134</td><td style="text-align:center">92</td><td style="text-align:center">5C</td><td style="text-align:left">\</td><td style="text-align:center">反斜杠</td></tr><tr><td style="text-align:left">1011101</td><td style="text-align:center">135</td><td style="text-align:center">93</td><td style="text-align:center">5D</td><td style="text-align:left">]</td><td style="text-align:center">闭方括号</td></tr><tr><td style="text-align:left">1011110</td><td style="text-align:center">136</td><td style="text-align:center">94</td><td style="text-align:center">5E</td><td style="text-align:left">^</td><td style="text-align:center">脱字符</td></tr><tr><td style="text-align:left">1011111</td><td style="text-align:center">137</td><td style="text-align:center">95</td><td style="text-align:center">5F</td><td style="text-align:left">_</td><td style="text-align:center">下划线</td></tr><tr><td style="text-align:left">1100000</td><td style="text-align:center">140</td><td style="text-align:center">96</td><td style="text-align:center">60</td><td style="text-align:left">`</td><td style="text-align:center">开单引号</td></tr><tr><td style="text-align:left">1100001</td><td style="text-align:center">141</td><td style="text-align:center">97</td><td style="text-align:center">61</td><td style="text-align:left">a</td><td style="text-align:center">小写字母a</td></tr><tr><td style="text-align:left">1100010</td><td style="text-align:center">142</td><td style="text-align:center">98</td><td style="text-align:center">62</td><td style="text-align:left">b</td><td style="text-align:center">小写字母b</td></tr><tr><td style="text-align:left">1100011</td><td style="text-align:center">143</td><td style="text-align:center">99</td><td style="text-align:center">63</td><td style="text-align:left">c</td><td style="text-align:center">小写字母c</td></tr><tr><td style="text-align:left">1100100</td><td style="text-align:center">144</td><td style="text-align:center">100</td><td style="text-align:center">64</td><td style="text-align:left">d</td><td style="text-align:center">小写字母d</td></tr><tr><td style="text-align:left">1100101</td><td style="text-align:center">145</td><td style="text-align:center">101</td><td style="text-align:center">65</td><td style="text-align:left">e</td><td style="text-align:center">小写字母e</td></tr><tr><td style="text-align:left">1100110</td><td style="text-align:center">146</td><td style="text-align:center">102</td><td style="text-align:center">66</td><td style="text-align:left">f</td><td style="text-align:center">小写字母f</td></tr><tr><td style="text-align:left">1100111</td><td style="text-align:center">147</td><td style="text-align:center">103</td><td style="text-align:center">67</td><td style="text-align:left">g</td><td style="text-align:center">小写字母g</td></tr><tr><td style="text-align:left">1101000</td><td style="text-align:center">150</td><td style="text-align:center">104</td><td style="text-align:center">68</td><td style="text-align:left">h</td><td style="text-align:center">小写字母h</td></tr><tr><td style="text-align:left">1101001</td><td style="text-align:center">151</td><td style="text-align:center">105</td><td style="text-align:center">69</td><td style="text-align:left">i</td><td style="text-align:center">小写字母i</td></tr><tr><td style="text-align:left">1101010</td><td style="text-align:center">152</td><td style="text-align:center">106</td><td style="text-align:center">6A</td><td style="text-align:left">j</td><td style="text-align:center">小写字母j</td></tr><tr><td style="text-align:left">1101011</td><td style="text-align:center">153</td><td style="text-align:center">107</td><td style="text-align:center">6B</td><td style="text-align:left">k</td><td style="text-align:center">小写字母k</td></tr><tr><td style="text-align:left">1101100</td><td style="text-align:center">154</td><td style="text-align:center">108</td><td style="text-align:center">6C</td><td style="text-align:left">l</td><td style="text-align:center">小写字母l</td></tr><tr><td style="text-align:left">1101101</td><td style="text-align:center">155</td><td style="text-align:center">109</td><td style="text-align:center">6D</td><td style="text-align:left">m</td><td style="text-align:center">小写字母m</td></tr><tr><td style="text-align:left">1101110</td><td style="text-align:center">156</td><td style="text-align:center">110</td><td style="text-align:center">6E</td><td style="text-align:left">n</td><td style="text-align:center">小写字母n</td></tr><tr><td style="text-align:left">1101111</td><td style="text-align:center">157</td><td style="text-align:center">111</td><td style="text-align:center">6F</td><td style="text-align:left">o</td><td style="text-align:center">小写字母o</td></tr><tr><td style="text-align:left">1110000</td><td style="text-align:center">160</td><td style="text-align:center">112</td><td style="text-align:center">70</td><td style="text-align:left">p</td><td style="text-align:center">小写字母p</td></tr><tr><td style="text-align:left">1110001</td><td style="text-align:center">161</td><td style="text-align:center">113</td><td style="text-align:center">71</td><td style="text-align:left">q</td><td style="text-align:center">小写字母q</td></tr><tr><td style="text-align:left">1110010</td><td style="text-align:center">162</td><td style="text-align:center">114</td><td style="text-align:center">72</td><td style="text-align:left">r</td><td style="text-align:center">小写字母r</td></tr><tr><td style="text-align:left">1110011</td><td style="text-align:center">163</td><td style="text-align:center">115</td><td style="text-align:center">73</td><td style="text-align:left">s</td><td style="text-align:center">小写字母s</td></tr><tr><td style="text-align:left">1110100</td><td style="text-align:center">164</td><td style="text-align:center">116</td><td style="text-align:center">74</td><td style="text-align:left">t</td><td style="text-align:center">小写字母t</td></tr><tr><td style="text-align:left">1110101</td><td style="text-align:center">165</td><td style="text-align:center">117</td><td style="text-align:center">75</td><td style="text-align:left">u</td><td style="text-align:center">小写字母u</td></tr><tr><td style="text-align:left">1110110</td><td style="text-align:center">166</td><td style="text-align:center">118</td><td style="text-align:center">76</td><td style="text-align:left">v</td><td style="text-align:center">小写字母v</td></tr><tr><td style="text-align:left">1110111</td><td style="text-align:center">167</td><td style="text-align:center">119</td><td style="text-align:center">77</td><td style="text-align:left">w</td><td style="text-align:center">小写字母w</td></tr><tr><td style="text-align:left">1111000</td><td style="text-align:center">170</td><td style="text-align:center">120</td><td style="text-align:center">78</td><td style="text-align:left">x</td><td style="text-align:center">小写字母x</td></tr><tr><td style="text-align:left">1111001</td><td style="text-align:center">171</td><td style="text-align:center">121</td><td style="text-align:center">79</td><td style="text-align:left">y</td><td style="text-align:center">小写字母y</td></tr><tr><td style="text-align:left">1111010</td><td style="text-align:center">172</td><td style="text-align:center">122</td><td style="text-align:center">7A</td><td style="text-align:left">z</td><td style="text-align:center">小写字母z</td></tr><tr><td style="text-align:left">1111011</td><td style="text-align:center">173</td><td style="text-align:center">123</td><td style="text-align:center">7B</td><td style="text-align:left">{</td><td style="text-align:center">开花括号</td></tr><tr><td style="text-align:left">1111100</td><td style="text-align:center">174</td><td style="text-align:center">124</td><td style="text-align:center">7C</td><td style="text-align:left">&#124;</td><td style="text-align:center">垂线</td></tr><tr><td style="text-align:left">1111101</td><td style="text-align:center">175</td><td style="text-align:center">125</td><td style="text-align:center">7D</td><td style="text-align:left">}</td><td style="text-align:center">闭花括号</td></tr><tr><td style="text-align:left">1111110</td><td style="text-align:center">176</td><td style="text-align:center">126</td><td style="text-align:center">7E</td><td style="text-align:left">~</td><td style="text-align:center">波浪号</td></tr><tr><td style="text-align:left">1111111</td><td style="text-align:center">177</td><td style="text-align:center">127</td><td style="text-align:center">7F</td><td style="text-align:left">DEL (delete)</td><td style="text-align:center">删除</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;16进制和8进制的问题&quot;&gt;&lt;a href=&quot;#16进制和8进制的问题&quot; class=&quot;headerlink&quot; title=&quot;16进制和8进制的问题&quot;&gt;&lt;/a&gt;16进制和8进制的问题&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;今天在网上看到有人在问&lt;code&gt;\x20
      
    
    </summary>
    
      <category term="Python" scheme="https://returnwow.github.io/categories/Python/"/>
    
    
      <category term="学习 Python Hex Octal" scheme="https://returnwow.github.io/tags/%E5%AD%A6%E4%B9%A0-Python-Hex-Octal/"/>
    
  </entry>
  
  <entry>
    <title>学习bs4模块</title>
    <link href="https://returnwow.github.io/2017/11/29/python/bs4/learn_bs4/"/>
    <id>https://returnwow.github.io/2017/11/29/python/bs4/learn_bs4/</id>
    <published>2017-11-29T12:14:07.490Z</published>
    <updated>2018-03-31T01:36:17.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习bs4模块"><a href="#学习bs4模块" class="headerlink" title="学习bs4模块"></a>学习bs4模块</h1><blockquote><p>直接在官方网站上面学习</p></blockquote><hr><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>bs4是一个格式化读取xml，html文档的库<br>可以使xml、html按照标签的形式操作，具体是将HTML文档转换成一个复杂的树形结构。<br>官方推荐lxml来解析HTML<br>所有节点对象可以归纳为4种: Tag , NavigableString , BeautifulSoup , Comment .</p><p>简单使用操作</p><pre><code>from bs4 import BeautifulSouphtml_doc = &#39;&#39;soup = BeautifulSoup(html_doc, &#39;html.parser&#39;)print(soup.prettify())  #美化输出，格式化缩进。</code></pre><h2 id="一般属性"><a href="#一般属性" class="headerlink" title="一般属性"></a>一般属性</h2><ul><li><code>soup.title</code>：获取页面的标题，包含标签</li><li><code>soup.title.name</code>：获取页面标题标签的内容</li><li><code>soup.title.string</code>：获取页面标题的内容</li><li><code>soup.title.parent.name</code>：父标签名字</li><li><code>soup.p</code>：<code>p</code>是标签名字</li><li><code>soup.p[&#39;class&#39;]</code>：第一个匹配p的标签，成员class</li><li><code>soup.a</code>：同上</li></ul></blockquote><h2 id="一般方法"><a href="#一般方法" class="headerlink" title="一般方法"></a>一般方法</h2><blockquote><ul><li><code>soup.find_all(&#39;a&#39;)</code>：找到所以的<code>a</code>标签</li></ul></blockquote><h3 id="查找所有的a标签"><a href="#查找所有的a标签" class="headerlink" title="查找所有的a标签"></a>查找所有的a标签</h3><pre><code>for link in soup.find_all(&#39;a&#39;):    print(link.get(&#39;href&#39;))    # http://example.com/elsie    # http://example.com/lacie    # http://example.com/tillie</code></pre><blockquote><ul><li><code>soup.get_text()</code>：拿到文档中所有的文字内容，实际测试新浪的首页存在问题，使用html5lib也一致。</li></ul></blockquote><h2 id="对象的种类"><a href="#对象的种类" class="headerlink" title="对象的种类"></a>对象的种类</h2><h3 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h3><blockquote><p><code>Tag</code>对象和XML或HTML原生文档中的tag相同</p></blockquote><h4 id="Tag重要的属性"><a href="#Tag重要的属性" class="headerlink" title="Tag重要的属性"></a>Tag重要的属性</h4><blockquote><ul><li><p><code>name</code><br>每个Tag都有自己的名字，通过name属性来获取，比如<title>xxx</title>，Tag名称就是title<br>如果改变了某个tag的名称，那么将影响当前生成的hml对象文档<br><code>tag.name = &#39;xxx&#39;</code></p></li><li><p><code>Attributes</code><br>一个<code>Tag</code>可能存在属性，属性的操作和字典相同<br>可以直接使用<code>attrs</code>获取全部属性<br>tag的属性可以添加删除或者修改。操作和字典一致。</p></li></ul></blockquote><h4 id="多值属性"><a href="#多值属性" class="headerlink" title="多值属性"></a>多值属性</h4><blockquote><p>一个属性可能有多个值，这里返回其列表。<br><code>&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;</code>：将会返回body和strikeout的列表<br>如果存在多个值，但是HTML定义中并没有定义为多值属性，那么还是返回字符串<br>并且可以传入列表以修改多值属性，传入列表为多值。<br>xml中不包含多值</p></blockquote><h4 id="可以遍历的字符串"><a href="#可以遍历的字符串" class="headerlink" title="可以遍历的字符串"></a>可以遍历的字符串</h4><blockquote><p>字符串常被包含在tag内.Beautiful Soup用 <code>NavigableString</code> 类来包装tag中的字符串<br>节点下的字符串不可以编辑，但是可以替换，使用replace_with(‘xxx’)<br>字符串不支持：contents，string属性或find()方法<br>需要在此之外使用字符串，使用unicode将其转换为普通的Unicode字符串，减少内存占用。</p></blockquote><h5 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h5><blockquote><p><code>soup.body.b</code>：body节点下的b节点</p><ul><li><code>tag.contents</code>：可以将节点下的子节点以列表方式输出。</li><li><code>tag.children</code>：子节点生成器，</li><li><code>descendants</code>：后裔，多所有的子孙节点递归循环，这样会将string也单独提取出来</li><li>节点下的<code>string</code>：如果节点下面存在子节点，并且子节点不是内容节点，那么返回None</li><li><code>strings and stripped_strings</code>：解决了上面的问题，使用这个将打印节点下的所以字符串，其中stripped_strings去除空格</li></ul></blockquote><h3 id="BeautifulSoup对象"><a href="#BeautifulSoup对象" class="headerlink" title="BeautifulSoup对象"></a>BeautifulSoup对象</h3><blockquote><p>表示文档的全部内容大部分时候可以将它当做<code>Tag</code>对象。</p></blockquote><h4 id="搜索文档树"><a href="#搜索文档树" class="headerlink" title="搜索文档树"></a>搜索文档树</h4><blockquote><p>很多搜索方法，这里解释：<code>find()</code>和<code>find_all()</code><br>其它操作方法类似</p></blockquote><h5 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h5><blockquote><ul><li>字符串<br>使用字符串来过滤查找，比如<code>soup.find_all(&#39;a&#39;)</code>来找到<code>a</code>标签</li><li>正则表达式<br>支持正则表达式，比如：<code>soup.find_all(re.compile(&quot;^b&quot;))</code></li><li>列表参数<br>传入列表参数：<code>[&#39;a&#39;, &#39;b&#39;]</code> 找出<code>a</code> <code>b</code>的标签</li><li>True<br>传入<code>True</code>值，那么会找到所有节点，但是没有字符串。</li><li>方法<br>如果没有合适的过滤器，那么可以传入方法，方法接收一个参数<br>```<br>def has_class_but_no_id(tag):<br>  return tag.has_attr(‘class’) and not tag.has_attr(‘id’)</li></ul></blockquote><p>def not_lacie(href):<br>        return href and not re.compile(“lacie”).search(href)<br>soup.find_all(href=not_lacie)</p><p>from bs4 import NavigableString<br>def surrounded_by_strings(tag):<br>    return (isinstance(tag.next_element, NavigableString)<br>            and isinstance(tag.previous_element, NavigableString))</p><pre><code>&gt; 具体参数 find_all( name , attrs , recursive , string , **kwargs )&gt; * name 用来查找所以tag&gt; * attrs 传入字典&gt; * recursive 传入False只便利直接的子节点&gt; * string 查找内容，页面上的文本内容，可以传入文字，列表，正则表达式，True&gt; * **kwargs 传入关键字参数 比如：id=&#39;xxx&#39;  同时可以过滤多个这样的属性&gt; * limit 限制查找的数量&gt; 有些tag属性在搜索不能使用,比如HTML5中的 data-* 属性:</code></pre><p>data_soup = BeautifulSoup(‘<div data-foo="value">foo!</div>‘)<br>data_soup.find_all(data-foo=”value”)<br>SyntaxError: keyword can’t be an expression</p><pre><code>&gt; 但是可以通过 find_all() 方法的 attrs 参数定义一个字典参数来搜索包含特殊属性的tag:</code></pre><p>data_soup.find_all(attrs={“data-foo”: “value”})<br>[<div data-foo="value">foo!</div>]</p><pre><code>&gt; 但标识CSS类名的关键字 class 在Python中是保留字,使用 class 做参数会导致语法错误.从Beautiful Soup的4.1.1版本开始,可以通过 class_ 参数搜索有指定CSS类名的tag:### 子节点&gt; 一个节点可能包含一个或者多个子节点&gt; * contents and children：返回子节点的列表，后者返回迭代器。&gt; * descendants：后裔，会将字符串也打印出来。&gt; * srting：得到节点下的NavigableString对象&gt; * strings and stripped_strings：得到节点下的所以NString对象，后者会去除空格和空行。### 父节点&gt; 每个节点或者字符串都有父节点&gt; * parent：得到直接父节点&gt; * parents：得到所有的父节点### 兄弟节点&gt; * next_sipling and previous_sibling：类似遍历兄弟节点&gt; * next_siplings and previous_siblings：当前节点之前或者之后的所有兄弟节点迭代输出### 回退和前进&gt; * next_element and previous_element：返回当前节点上一个或者下一个被解析对象&gt; * next_elements and previous_elements：对应的就是前后所有被解析的对象，就像HTML对象正在被解析一样### 像调用 find_all() 一样调用tag</code></pre><p>soup.find_all(“a”)<br>soup(“a”)</p><pre><code>&gt; 这两行是等价的### find()&gt; find_all是得到所有的结果，有时候我们只需要一个结果，那么直接使用find就行。&gt; find_all 加上参数limit = 1，也可以实现，但是返回的结果是列表&gt; find没有找到结果的时候返回`None`&gt; find方法多次调用：</code></pre><p>html.find(‘head’).find(‘title’)</p><pre><code>### find_parents() 和 find_parent()&gt; 搜索当前节点的父节点</code></pre><p>s = html.find(string=’Lacie’) # 找到字符串Lacie<br>s.find_parents(‘a’) # 字符串节点的父节点</p><pre><code>&gt; 其实方法就是使用了parent和parents属性进行迭代搜索的### find_next_siblings() 和 find_next_sibling()&gt; 通过next_siblings属性对当前tag之后的兄弟节点进行迭代搜索</code></pre><blockquote><blockquote><blockquote><p>first_link = html.a<br>first_link<br><a class="sister" href="http://example.com/elsie" id="link1" target="_blank" rel="external">Elsie</a><br>first_link.find_next_siblings()<br>[<a class="sister" href="http://example.com/lacie" id="link2" target="_blank" rel="external">Lacie</a>, <a clas="" s="sister" href="http://example.com/tillie" id="link3" target="_blank" rel="external">Tillie</a>]<br>```</p></blockquote></blockquote></blockquote><h3 id="find-previous-siblings-和-find-previous-sibling"><a href="#find-previous-siblings-和-find-previous-sibling" class="headerlink" title="find_previous_siblings() 和 find_previous_sibling()"></a>find_previous_siblings() 和 find_previous_sibling()</h3><blockquote><p>和上面类似</p></blockquote><h3 id="find-all-next-和-find-next"><a href="#find-all-next-和-find-next" class="headerlink" title="find_all_next() 和 find_next()"></a>find_all_next() 和 find_next()</h3><blockquote><p>通过next_elements属性对当前tag进行迭代搜索</p><pre><code>&gt;&gt; f_link = html.a&gt;&gt; f_link&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;&gt;&gt; f_link.find_all_next(&#39;a&#39;)[&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]&gt;&gt; f_link.find_all_next(string=True)[&#39;Elsie&#39;, &#39;,\n&#39;, &#39;Lacie&#39;, &#39; and\n&#39;, &#39;Tillie&#39;, &#39;;\nand they lived at the bottom of a well.&#39;, &#39;\n&#39;, &#39;...&#39;, &#39;\n&#39;]</code></pre></blockquote><h3 id="find-all-previous-和-find-previous"><a href="#find-all-previous-和-find-previous" class="headerlink" title="find_all_previous() 和 find_previous()"></a>find_all_previous() 和 find_previous()</h3><blockquote><p>通过previous_element对当前tag进行迭代搜索</p><pre><code>&gt;&gt; f_link = html.a&gt;&gt; f_link&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;&gt;&gt; f_link.find_all_previous(&#39;title&#39;)[&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</code></pre></blockquote><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><blockquote><p>bs4支持大部分的CSS选择器：<a href="https://www.w3.org/TR/CSS2/selector.html" title="CSS Selector" target="_blank" rel="external">CSS Selector</a> <a href="http://www.w3school.com.cn/cssref/css_selectors.asp" title="CSS 选择器" target="_blank" rel="external">w3school</a></p></blockquote><blockquote><p>在 <code>Tag</code> 或 <code>BeautifulSoup</code> 对象的 <code>.select()</code> 方法中传入字符串参数, 即可使用CSS选择器的语法找到tag:</p></blockquote><pre><code>soup.select(&quot;title&quot;)# [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]soup.select(&quot;p nth-of-type(3)&quot;)# [&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;]</code></pre><blockquote><p>不是很懂这个选择器，大概看起来可以根据CSS选择器文档来书写。</p></blockquote><h3 id="修改文档树"><a href="#修改文档树" class="headerlink" title="修改文档树"></a>修改文档树</h3><h4 id="修改tag的名称和属性"><a href="#修改tag的名称和属性" class="headerlink" title="修改tag的名称和属性"></a>修改tag的名称和属性</h4><blockquote><p><code>tag.name = &#39;blockquote&#39;</code><br><code>tag[&#39;class&#39;] = &#39;modify value&#39;</code><br><code>tag[&#39;id&#39;] = &#39;newid&#39;</code></p><h4 id="修改-string"><a href="#修改-string" class="headerlink" title="修改 .string"></a>修改 <code>.string</code></h4><p><code>tag.string = &#39;New link text&#39;</code></p><h4 id="append"><a href="#append" class="headerlink" title="append()"></a><code>append()</code></h4><p>在.string上面追加内容</p><h4 id="NavigableString-和-new-tag"><a href="#NavigableString-和-new-tag" class="headerlink" title="NavigableString() 和 .new_tag()"></a><code>NavigableString() 和 .new_tag()</code></h4><p><code>NavigableString()</code> 是构造一个字符串，然后将其放入需要修改的地方。<br><code>new_string = NavigableString(&#39;Hello&#39;)</code><br><code>html.b.append(new_string)</code><br><code>from bs4 import Comment</code><br><code>new_comment = html.new_string(&#39;Nice to see you&#39;, Comment)</code><br><code>html.b.append(new_comment)</code><br>创建一个Tag的最好的方法是调用工厂方法，new_tag()<br><code>new_tag = html.new_tag(&#39;a&#39;, href=&#39;test&#39;)</code><br><code>html.b.append(new_tag)</code> # 在b标签的下面追加一个tag <code>a</code></p><h4 id="insert"><a href="#insert" class="headerlink" title="insert()"></a><code>insert()</code></h4><p>选择插入的位置，这个和append类似，不过可以选择位置插入。</p><h4 id="insert-before-insert-after"><a href="#insert-before-insert-after" class="headerlink" title="insert_before, insert_after"></a>insert_before, insert_after</h4><p>看名字就知道，这是在当前tag或者string后边插入对象。<br>定位到tag或者string，然后使用方法进行插入。</p><h4 id="‘clear-’"><a href="#‘clear-’" class="headerlink" title="‘clear()’"></a>‘clear()’</h4><p>移除tag下的内容</p><h4 id="‘extract-’"><a href="#‘extract-’" class="headerlink" title="‘extract()’"></a>‘extract()’</h4><p>移除当前tag，将tag移除。<br>该方法移除tag的时候，会返回移除的tag信息</p></blockquote><pre><code>&gt;&gt;&gt; html = &#39;&lt;h1&gt;&lt;a href=&quot;www.text.com&quot;&gt;wwwww&lt;/a&gt;&lt;/h1&gt;&#39;&gt;&gt;&gt; h = bs(html, &#39;lxml&#39;)&gt;&gt;&gt; h&lt;html&gt;&lt;body&gt;&lt;h1&gt;&lt;a href=&quot;www.text.com&quot;&gt;wwwww&lt;/a&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&gt;&gt;&gt; h.body.a&lt;a href=&quot;www.text.com&quot;&gt;wwwww&lt;/a&gt;&gt;&gt;&gt; tag = h.body.a.extract()&gt;&gt;&gt; tag&lt;a href=&quot;www.text.com&quot;&gt;wwwww&lt;/a&gt;&gt;&gt;&gt; h&lt;html&gt;&lt;body&gt;&lt;h1&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&gt;&gt;&gt;</code></pre><h4 id="‘decompose-’"><a href="#‘decompose-’" class="headerlink" title="‘decompose()’"></a>‘decompose()’</h4><blockquote><p>这个更为激进，移除tag之后，不返回。</p><h4 id="‘replace-with-’"><a href="#‘replace-with-’" class="headerlink" title="‘replace_with()’"></a>‘replace_with()’</h4><p>移除内容并替换新的tag或者string<br>return：方法返回被替换的内容</p><h4 id="‘wrap-’"><a href="#‘wrap-’" class="headerlink" title="‘wrap()’"></a>‘wrap()’</h4><p>对元素进行包装，并且返回包装后的内容。</p><pre><code>&gt;&gt; tag = &lt;a&gt;xxx&lt;/a&gt;&gt;&gt; wrap_tag = BeautifulSoup.new_tag(&#39;p&#39;)&gt;&gt; tag.wrap(wrap_tag)&gt;&gt; tag&lt;p&gt;&lt;a&gt;xxx&lt;/a&gt;&lt;/p&gt;</code></pre></blockquote><h4 id="‘unwrap-’"><a href="#‘unwrap-’" class="headerlink" title="‘unwrap()’"></a>‘unwrap()’</h4><blockquote><p>和wrap的方法相反<br>```<br>markup = ‘<a href="http://example.com/" target="_blank" rel="external">I linked to <i>example.com</i></a>‘<br>soup = BeautifulSoup(markup)<br>a_tag = soup.a</p></blockquote><p>a_tag.i.unwrap()<br>a_tag</p><h1 id="I-linked-to-example-com"><a href="#I-linked-to-example-com" class="headerlink" title="I linked to example.com"></a><a href="http://example.com/" target="_blank" rel="external">I linked to example.com</a></h1><pre><code>#### 格式化输出&gt; prettify() : 格式化为unicode之后，每个xml、html独占一行。</code></pre><blockquote><blockquote><blockquote><p>html.prettify()<br>‘<html>\n <body>\n  <a href="http://example.com/" target="_blank" rel="external">\n   I linked to\n   <i>\n<br>example.com\n   </i>\n  </a>\n </body>\n</html>‘<br>print(html.prettify())</p><p><html><br> <body><br>  <a href="http://example.com/" target="_blank" rel="external"><br>   I linked to<br>   <i><br>    example.com<br>   </i><br>  </a><br> </body><br></html><br>```</p></blockquote></blockquote></blockquote><h4 id="压缩输出"><a href="#压缩输出" class="headerlink" title="压缩输出"></a>压缩输出</h4><blockquote><p>unicode(bs)、str(bs)和encode<br>这应该属于其它操作了</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>bs会将html里边的特殊字符转换成unicode的格式</p><pre><code>&gt;&gt; soup = bs(&quot;&amp;ldquo;Dammit!&amp;rdquo; he said.&quot;)unicode(soup)# u&#39;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;\u201cDammit!\u201d he said.&lt;/body&gt;&lt;/html&gt;&#39;</code></pre><p>python3上面没有unicode，直接使用str替换。<br>并且3上面bs4是直接将&amp;再次转义了，其它没有变化。</p><h4 id="‘get-text-’"><a href="#‘get-text-’" class="headerlink" title="‘get_text()’"></a>‘get_text()’</h4><p>如果想要获取tag里边的所以文本内容，可以使用这个方法。<br>‘get_text(‘|’) # 第一个参数指定分隔符号，不太明白这个分隔符具体操作，单词？？？’<br>‘get_text(‘|’, trip=True) # 这个会处理文本两端的空格’<br>还可以使用stripped_string生成器，获取文本列表分别处理。</p></blockquote><h4 id="指定解析器"><a href="#指定解析器" class="headerlink" title="指定解析器"></a>指定解析器</h4><blockquote><p>‘BeautifulSoup()’ 第一个参数是文本或者是文件，第二个参数是解析器，Python3应该不自动选择解析器。<br>目前支持解析：html、xml和html5<br>解析器有：lxml、html5lib和html.parser</p><ul><li>解析器之间的区别<br>使用了不同的解析器会产生不同的结果<br>具体还是去官网查看API，这里就这样了。<br>存在一些加标签和保留特定的标签的差异：<br>比如lxml会将单结束标志’<p></p>‘去掉，而html5lib会将其补齐为’<p></p>‘<br>一般不全的都会补齐基本标签，比如：’<html><body></body></html>‘<br>官方给的建议是在代码上面标注使用了什么解析器。</li></ul></blockquote><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><blockquote><p>任何文档都有其编码方式，使用bs4之后都将其解析为unicode<br>bs使用了自动编码检测来将文档的编码转换为unicode<br>‘original_encoding’属性记录了自动识别的编码<br>bs采用了逐字节的方式来识别编码的，存在效率问题，并且还会猜错。<br>所以可以使用from_encoding参数来指定文档的编码：<br>BeautifulSoup(xxx, ‘lxml’, from_encoding=’utf-8’)<br>当编码比较接近或者是其子集的时候，可能会猜测错误，并且我们也只是知道大致编码的时候，这个时候bs提供exclude_encoding参数来排除错误的编码。<br>相当于猜测这个文档编码的一个集合，然后取其最可能的编码方式，但是如果猜测错误，那么说明猜测的这个编码是最可能的，但是是错误的，所以提供这个方法来排除，然后相当于让其猜测第二个可能的编码方式。<br>例如：’BeautifulSoup(xxx, ‘lxml’, exclude_encoding=[‘utf-8’])’<br>原文：少数情况下(通常是UTF-8编码的文档中包含了其它编码格式的文件),想获得正确的Unicode编码就不得不将文档中少数特殊编码字符替换成特殊Unicode编码,“REPLACEMENT CHARACTER” (U+FFFD, �) [9] . 如果Beautifu Soup猜测文档编码时作了特殊字符的替换,那么Beautiful Soup会把 UnicodeDammit 或 BeautifulSoup 对象的 .contains_replacement_characters 属性标记为 True .这样就可以知道当前文档进行Unicode编码后丢失了一部分特殊内容字符.如果文档中包含�而 .contains_replacement_characters 属性是 False ,则表示�就是文档中原来的字符,不是转码失败.</p></blockquote><h4 id="输出编码"><a href="#输出编码" class="headerlink" title="输出编码"></a>输出编码</h4><blockquote><p>bs将输入的文档都转换为utf-8输出，并且会将源数据的meta里边的编码也改成utf-8<br>在’prettify(‘utf-8’)’可以指定打印其编码<br>并且调研bs对象或者节点的方式来使用encode()方法<br>‘tag.encode(‘utf-8’)’<br>如果文档中包含当前编码不支持的字符，那么会进行转码。</p><pre><code>&gt;&gt; markup = u&quot;&lt;b&gt;\N{SNOWMAN}&lt;/b&gt;&quot;&gt;&gt; snowman_soup = BeautifulSoup(markup)&gt;&gt; tag = snowman_soup.b&gt;&gt; print(tag.encode(&quot;utf-8&quot;))# &lt;b&gt;☃&lt;/b&gt;&gt;&gt; print tag.encode(&quot;latin-1&quot;)# &lt;b&gt;&amp;#9731;&lt;/b&gt;&gt;&gt; print tag.encode(&quot;ascii&quot;)# &lt;b&gt;&amp;#9731;&lt;/b&gt;</code></pre></blockquote><h4 id="‘UnicodeDammit’"><a href="#‘UnicodeDammit’" class="headerlink" title="‘UnicodeDammit’"></a>‘UnicodeDammit’</h4><blockquote><p>这个是bs的内置库，可以用来猜测文档的编码。<br>UnicodeDammit(‘xxx’).unicode_markup.original_encoding<br>就可以查看猜测的编码了。<br>UnicodeDammit.detwingle()：可以将编码进行统一，比如一些网站包含了另外的网站内容，但是编码却不一样，一个是utf-8编码，一个是另外的编码<br>这样直接使用是存在问题的。所以在处理之前最好使用这个方法进行操作一次。</p></blockquote><h4 id="判断对象是否相同"><a href="#判断对象是否相同" class="headerlink" title="判断对象是否相同"></a>判断对象是否相同</h4><blockquote><p>使用等于不严格的方式来判断是否相同，如下图不同位置b对象是相同的</p><pre><code>&gt;&gt; markup = &quot;&lt;p&gt;I want &lt;b&gt;pizza&lt;/b&gt; and more &lt;b&gt;pizza&lt;/b&gt;!&lt;/p&gt;&quot;&gt;&gt; soup = BeautifulSoup(markup, &#39;html.parser&#39;)&gt;&gt; first_b, second_b = soup.find_all(&#39;b&#39;)&gt;&gt; print(first_b == second_b)# True&gt;&gt; print(first_b.previous_element == second_b.previous_element)# False</code></pre><p>使用is来严格判断是否相同</p><pre><code>&gt;&gt; print(first_b is second_b)False</code></pre><h4 id="复制Beautiful-Soup对象"><a href="#复制Beautiful-Soup对象" class="headerlink" title="复制Beautiful Soup对象"></a>复制Beautiful Soup对象</h4><blockquote><blockquote><p><code>copy.copy()</code>可以复制任意的<code>Tag</code>或<code>NavigableString</code></p><pre><code>import copyp_copy = copy.copy(soup.p)</code></pre><h4 id="解析部分文档"><a href="#解析部分文档" class="headerlink" title="解析部分文档"></a>解析部分文档</h4><p>如果仅仅需要获取页面中的<code>a</code>标签的内容，但是如果全部都去解析，就太耗费性能和内存了。最快的方法就在一开始就把<code>a</code>标签以外的都忽略掉。<br>SoupStrainer类可以定义文档的某段内容，只会解析SoupStrainer中定义的内容，创建一个SoupStrainer对象并作为parse_only参数给BeautifulSoup的构造方法就行。<br>SoupSTrainer类接受与典型搜索方法相同的参数：name、attr、recursive、string、**kw，下面源教程的列子，最后的short_strings运行错误，可能是参数导致的，显示<code>NoneType</code>无len。<br>```<br>from bs4 import SoupStrainer</p></blockquote></blockquote></blockquote><p>only_a_tags = SoupStrainer(“a”) #</p><p>only_tags_with_id_link2 = SoupStrainer(id=”link2”)</p><p>def is_short_string(string):<br>    return len(string) &lt; 10</p><p>only_short_strings = SoupStrainer(string=is_short_string)</p><p>BeautifulSoup(html_doc, “html.parser”, parse_only=only_a_tags)<br>```</p><h4 id="其他说明（官方教程为代码诊断）"><a href="#其他说明（官方教程为代码诊断）" class="headerlink" title="其他说明（官方教程为代码诊断）"></a>其他说明（官方教程为代码诊断）</h4><blockquote><blockquote><blockquote><p><code>from bs4.diagnose import diagnose</code><br>这个可以打印出解析器处理文档的过程。使用了一下，貌似是使用了不同的解析器对文档进行解析，然后分别给出结果。</p><h4 id="解析错误"><a href="#解析错误" class="headerlink" title="解析错误"></a>解析错误</h4><p>解析崩溃或者异常基本都不是bs4的问题，因为他并不包含解析器，官方给于的解释是换解析器<br>最常见的解析错误是<code>HTMLParser.HTMLParseError: malformed start tag</code>和<code>HTMLParser.HTMLParseError: bad end tag</code>.这都是由Python内置的解析器引起的,解决方法是 安装<code>lxml</code>或<code>html5lib</code><br>find_all()或者find返回都是空，但是文档中也存在这个Tag，还是换解析器。</p><h5 id="解析器错误"><a href="#解析器错误" class="headerlink" title="解析器错误"></a>解析器错误</h5><p>一般解析器解析之后都是转为小写，如果要保留大小写，那么使用<code>xml</code>解析器</p><h4 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h4><p>使用<code>lxml</code>解析器会较快一点<br>安装<code>cchardet</code>之后，文档编码检测速度会更快。</p></blockquote></blockquote></blockquote><hr><h1 id="完"><a href="#完" class="headerlink" title="完"></a>完</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;学习bs4模块&quot;&gt;&lt;a href=&quot;#学习bs4模块&quot; class=&quot;headerlink&quot; title=&quot;学习bs4模块&quot;&gt;&lt;/a&gt;学习bs4模块&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;直接在官方网站上面学习&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h
      
    
    </summary>
    
      <category term="Python" scheme="https://returnwow.github.io/categories/Python/"/>
    
    
      <category term="学习 python bs4" scheme="https://returnwow.github.io/tags/%E5%AD%A6%E4%B9%A0-python-bs4/"/>
    
  </entry>
  
  <entry>
    <title>Numpy基础</title>
    <link href="https://returnwow.github.io/2017/11/20/python/numpy/02_quickstart_tutorial/"/>
    <id>https://returnwow.github.io/2017/11/20/python/numpy/02_quickstart_tutorial/</id>
    <published>2017-11-20T13:51:00.934Z</published>
    <updated>2017-11-28T14:31:44.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NumPy基础"><a href="#NumPy基础" class="headerlink" title="NumPy基础"></a>NumPy基础</h1><blockquote><p>NumPy的主要对象是同类型的多维数组，是一张表，所有元素（通常是数字）的类型都相同。<br>维度称为axes，axes的数目为rank。如下rank为2（2维的），第一维度axes长度为2，第二维度axes长度为3.<br><code>[[ 1., 0., 0.],</code><br><code>[ 0., 1., 2.]]</code><br>NumPy的数组的类称为ndarray。Python的数组提供较少的功能，而ndarray一下重要的属性。</p></blockquote><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><blockquote><ul><li>ndarray.ndim：数组的axes（维度）的个数，维度的数量称为rank。</li><li>ndarray.shape：数组的维度。这是一个整数元组，<code>(n, m)</code>表示一个n行，m列的矩阵。</li><li>ndarray.size：为shape元素的乘积，其实就是矩阵元素个数。</li><li>ndarray.dtype：描述矩阵中元素的类型的对象。可以使用Python标准的类型，也提供其他类型，例如：numpy.int32、numpy.int16和numpy.float64。</li><li>ndarray.itemsize：数组中每个元素的字节大小。例如float64字节数为8。</li><li>ndarray.data：该缓冲区包含数组的实际元素。通常不适用这个，我们一般使用索引进行访问（前面矢量化又说不要遍历，后续看看是怎么回事）。</li></ul><p>打开中文API查看示例：<a href="http://python.usyiyi.cn/translate/NumPy_v111/user/quickstart.html" title="示例" target="_blank" rel="external">属性示例</a></p></blockquote><h2 id="数组创建"><a href="#数组创建" class="headerlink" title="数组创建"></a>数组创建</h2><blockquote><p>有几种方法来创建数组</p><ul><li>可以使用array函数从常规的Python列表或元组中创建数组，得到的数组类型从序列中元素的类型推到而出。<br><code>&gt;&gt;&gt; numpy.array([3, 4, 5])</code></li><li>array函数传入列表的列表产生2维阵列，同理3维。<br><code>&gt;&gt;&gt; numpy.array([1, 2, 3], [4, 5, 6])</code><br><code>array([[1, 2, 3]</code><br><code>[4, 5, 6]</code><br><code>])</code><blockquote><ul><li>数组的类型可以在创建的时候指定<br><code>&gt;&gt;&gt; numpy.array([1, 2, 3], dtype=complex)</code> #元素为复数形式 1. + 0.j</li></ul></blockquote></li><li>通常数组的元素是位置的，所有NumPy提供创建具体初始占位符的数组，减少数组增长的必要。<blockquote><ul><li>函数zeros创建一个由0组成的数组；</li><li>函数ones创建一个由1数组的数组；</li><li>函数empty内容是随机的并且取决于存储器的状态，元素默认类型是float64。</li></ul></blockquote></li><li>为了创建数组序列，NumPy提供了类似于range的函数，返回数组而不是列表。<blockquote><p><code>&gt;&gt;&gt; numpy.arange(1, 10, 2)</code> #使用如上的reshape函数可以改变形状。起始为1步长为2。</p></blockquote></li><li>当arange与浮点参数一起使用时，由于浮点数的精度是有限的，通常不可能预测获得的元素数量。出于这个原因，通常最好使用函数linspace，它接收我们想要的元素数量而不是步长作为参数：<br><code>&gt;&gt;&gt; numpy.linspace(1, 2, 9)</code> # 1到二之间的9个数，感觉是平均分配的样子。步长0.125<br>‘&gt;&gt;&gt; numpy.sin(numpy.linspace(0, 2*pi, 100))’ #求sin。<br>其他函数：<br>array, zeros, zeros_like, ones, ones_like, empty, empty_like, arange,<br>linspace, numpy.random.rand, numpy.random.randn, fromfunction, fromfile</li></ul></blockquote><h2 id="打印数组"><a href="#打印数组" class="headerlink" title="打印数组"></a>打印数组</h2><blockquote><p>当打印数组时，NumPy以类似于嵌套列表的方式显示它，但是使用以下布局：</p><ul><li>最后一个axes从左到右打印，</li><li>第二个到最后一个从上到下打印，</li><li>其余的也从上到下打印，每个切片与下一个用空行分开</li><li>如果数组太大，会跳过中间的部分，只打印边角部分。<blockquote><ul><li>如果需要强制打印整个数组，可以使用set_printoptions来更改打印选项<br><code>numpy.set_printoptions(threshold=&#39;nan&#39;)</code> #官方api说传入的是int值，nan目前不知道什么意思：后面查看可以传入numpy.nan，而非str类型</li></ul></blockquote></li></ul></blockquote><h3 id="reshape改变数组形状"><a href="#reshape改变数组形状" class="headerlink" title="reshape改变数组形状"></a>reshape改变数组形状</h3><blockquote><ul><li><code>a.ravel()</code> #平坦化序列，比如3 * 4的矩阵，变成一维矩阵。</li><li><code>a.reshape(x, y)</code> #转变形状到x*y 元素需要支持转换该形状才行，如果y=-1则会自动计算维度。</li><li><code>a.T</code> #转置 transposed</li><li><code>numpy.resize</code>方法直接改变数组本身</li></ul></blockquote><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="数组上的算术运算符使用元素基本，将创建一个新数组并用结果填充，差不多就是对应到每个元素，然后返回计算结果。"><a href="#数组上的算术运算符使用元素基本，将创建一个新数组并用结果填充，差不多就是对应到每个元素，然后返回计算结果。" class="headerlink" title="数组上的算术运算符使用元素基本，将创建一个新数组并用结果填充，差不多就是对应到每个元素，然后返回计算结果。"></a>数组上的算术运算符使用元素基本，将创建一个新数组并用结果填充，差不多就是对应到每个元素，然后返回计算结果。</h2><blockquote><p><code>&gt;&gt;&gt; a = numpy.array([20, 30, 40, 50])</code><br><code>&gt;&gt;&gt; b = numpy.arange(4)</code></p><ul><li><code>&gt;&gt;&gt; c = a - b</code> #对应求其差值</li><li><code>&gt;&gt;&gt; b**2</code> #b元素都乘2</li><li><code>&gt;&gt;&gt; 10*np.sin(a)</code> #对a每个元素求sin，并乘10倍值。</li><li><code>&gt;&gt;&gt; a &lt; 35</code> #对a元素做判断，返回boolean矩阵。</li><li>dot函数做矩阵的乘法：a.dot(b) np.dot(a, b)</li><li>a * b 是对a和b对应位置的元素做乘积</li></ul></blockquote><h2 id="类似的操作会修改当前数组，而不是创建新的数组："><a href="#类似的操作会修改当前数组，而不是创建新的数组：" class="headerlink" title="+= *= 类似的操作会修改当前数组，而不是创建新的数组："></a>+= *= 类似的操作会修改当前数组，而不是创建新的数组：</h2><blockquote><ul><li>‘&gt;&gt;&gt; a = np.ones((2,3), dtype=int)’</li><li><code>&gt;&gt;&gt; b = np.random.random((2, 3))</code></li><li><code>&gt;&gt;&gt; a *= 3</code></li><li><code>&gt;&gt;&gt; b += a</code></li><li><code>&gt;&gt;&gt; a += b</code> #报错， float64 to int32</li></ul></blockquote><h2 id="不同类型的数组操作，结果数组的类型对应更精确的数组，向上转型。"><a href="#不同类型的数组操作，结果数组的类型对应更精确的数组，向上转型。" class="headerlink" title="不同类型的数组操作，结果数组的类型对应更精确的数组，向上转型。"></a>不同类型的数组操作，结果数组的类型对应更精确的数组，向上转型。</h2><blockquote><ul><li>比如int32 和 float64计算 结果类型为float64</li></ul></blockquote><h2 id="许多一元操作，求和sum，可以使用ndarray的方法"><a href="#许多一元操作，求和sum，可以使用ndarray的方法" class="headerlink" title="许多一元操作，求和sum，可以使用ndarray的方法"></a>许多一元操作，求和sum，可以使用ndarray的方法</h2><blockquote><ul><li><code>sum(), max(), min()</code></li></ul></blockquote><h2 id="默认的这些操作适用于数组，就像一个数字列表求最大值，不管其形状（shape-2-3-）"><a href="#默认的这些操作适用于数组，就像一个数字列表求最大值，不管其形状（shape-2-3-）" class="headerlink" title="默认的这些操作适用于数组，就像一个数字列表求最大值，不管其形状（shape = (2*3)）"></a>默认的这些操作适用于数组，就像一个数字列表求最大值，不管其形状（shape = (2*3)）</h2><h2 id="通过axis参数，可以指定沿数组的指定轴应用操作"><a href="#通过axis参数，可以指定沿数组的指定轴应用操作" class="headerlink" title="通过axis参数，可以指定沿数组的指定轴应用操作"></a>通过axis参数，可以指定沿数组的指定轴应用操作</h2><blockquote><ul><li><code>b.sum(axis=0)</code> # 每列求和</li><li><code>b.sum(axis=1)</code> # 每行求和</li><li><code>b.cumsum(axis=1)</code> # 沿着行累积和，相反沿着列累积和</li></ul></blockquote><h2 id="另见"><a href="#另见" class="headerlink" title="另见"></a>另见</h2><blockquote><p>all, any, apply_along_axis, argmax, argmin, argsort, average, bincount, ceil, clip, conj, corrcoef, cov, cross, cumprod, cumsum, diff, dot, floor, inner, inv, lexsort, max, maximum, mean, median, min, minimum, nonzero, outer, prod, re, round, sort, std, sum, trace, transpose, var, vdot, vectorize, where</p><ul><li>all：是判断所以元素是否都为True，可以定义axis来沿着某个轴判断。</li><li>any：和all相反，判断是否有一个为Ture，是返回True，否返回False，可以传入axis 例如：b.any(0)，纵轴是否有为真的。</li><li><p>apply_along_axis(func, axis, arr)：将arr按照axis定义，行或者列取出作用在func上，并返回一个列表。</p><blockquote><p>如果上述返回标量，则返回于源arr相同形状(shape)。比如传输sorted进行排序，返回还是列表。</p></blockquote></li><li><p>argmax：查找最大值，返回索引，支持axis轴选择。如果多个大值，就返回第一次遇到的。</p></li><li>argmin：和max相反。</li><li>argsort：排序，返回排序完的索引值。可以选择算法。选择键排序。</li><li>mean：平均值，可以按轴进行。axis</li><li>diff：计算差分，out[n] = a[n+1] - a[n]，可以按轴进行。</li><li>vdot：计算点积。</li><li>还有很多函数，先不看了。</li></ul></blockquote><h2 id="索引、切片和迭代"><a href="#索引、切片和迭代" class="headerlink" title="索引、切片和迭代"></a>索引、切片和迭代</h2><h3 id="一维数组支持索引，切片和迭代，非常类似于列表和其他序列。"><a href="#一维数组支持索引，切片和迭代，非常类似于列表和其他序列。" class="headerlink" title="一维数组支持索引，切片和迭代，非常类似于列表和其他序列。"></a>一维数组支持索引，切片和迭代，非常类似于列表和其他序列。</h3><blockquote><ul><li>a[1:2]，其中<code>**</code>是次方，**(1/3) 求根号3</li></ul></blockquote><h3 id="多维数组每个轴可以有一个索引。这些索引以逗号分隔的元组给出："><a href="#多维数组每个轴可以有一个索引。这些索引以逗号分隔的元组给出：" class="headerlink" title="多维数组每个轴可以有一个索引。这些索引以逗号分隔的元组给出："></a>多维数组每个轴可以有一个索引。这些索引以逗号分隔的元组给出：</h3><blockquote><p>比如b[2,3]表示3行4列的元素，b[0:3, 1]表示行数是0,1,2的第2列，如果1数字缺失，则认为是全部列。<br>如果维度大于3，比如维度（轴，rank）为5的情况，x[1,2,:,:,:]可以等效为x[1,2,…]</p><ul><li>x[1,2,…]等效于x[1,2,:,:,:]</li><li>x[…,3]到x[:,:,:,:,3]</li><li>x[4,…,5,:]到x[4,:,:,5,:]<br>例子：y[1:5:2,::3]指的是1-4行间隔为2行，列数间隔为3进行抽取。<br>避免迭代使用索引提高性能。<br>可以使用一个数组来索引数组，提高的索引必须是索引值，比如a[np.array([1,2,3])] 索引a中的索引为1,2,3的元素。<br>并且索引数组可以是多维的生成的矩阵维度和索引一致，a[np.array([[1,2], [3,4]])]，二维矩阵，1,2,3,4对应为a一维矩阵的索引。</li><li>Boolean型索引，比如<br><code>&gt;&gt;&gt; y = np.arange(35).reshape(5,7)</code><br><code>&gt;&gt;&gt; b = y &gt; 22</code><br><code>&gt;&gt;&gt; y[b] # 这样就将y里边的大于22的数索引出来了，但是维度只有一维，并且如果索引的布尔数组和y具有相同的形状</code><br>通常，当布尔数组具有比被索引的数组更少的维度时，这等同于y [b，…]，这意味着y被索引为b，然后是多个：如同填充y。因此，结果的形状是包含布尔数组的True元素的数目的一个维度，后面是被索引的数组的剩余维度。<br>组合索引和切片，感觉就是行和列的索引，三维的话相当于两个数组，就分别对两个进行索引</li><li><code>y[1:3, 2:3] #类似的就是1-2行并且列是2列</code><br>结构化索引工具<br><code>&gt;&gt;&gt; y.shape</code><br><code>(5, 7)</code><br><code>&gt;&gt;&gt; y[:,np.newaxis,:].shape # np.newaxis 对象来新建一个维度&#39;</code>(5, 1, 7)`</li><li>可以使用索引来改变相应位置的值<br><code>y[2:7] = 1 #将2-6位置的数更改为1</code><br><code>y[2:7] = np.arange(5) #或者直接使用数组的形式</code><br>如果高类型分配给低类型的，会转型，损失精度，或者抛出错误<br>下面的一个例子比较特殊：<br><code>&gt;&gt;&gt; x = np.arange(0, 50, 10)</code><br><code>&gt;&gt;&gt; x</code><br><code>array([ 0, 10, 20, 30, 40])</code><br><code>&gt;&gt;&gt; x[np.array([1, 1, 3, 1])] += 1</code><br><code>&gt;&gt;&gt; x</code><br><code>array([ 0, 11, 20, 31, 40])</code><br>实际上我们认为1位置的数应该增加3才对，但是最终只增加1，其实是我们每次计算都采用了临时数组的方式，导致最终只增加1.</li><li>Ellipsis 等同于 ‘…’</li><li>元组不像列表索引那样会自动处理，如下例子：<br><code>&gt;&gt;&gt; z[[1,1,1,1]] # produces a large array</code><br><code>array([[[[27, 28, 29],</code><br><code>[30, 31, 32], ...</code><br><code>&gt;&gt;&gt; z[(1,1,1,1)] # returns a single value</code><br><code>40</code></li></ul></blockquote><h3 id="多维数组迭代是相对于第一个轴进行的。"><a href="#多维数组迭代是相对于第一个轴进行的。" class="headerlink" title="多维数组迭代是相对于第一个轴进行的。"></a>多维数组迭代是相对于第一个轴进行的。</h3><blockquote><p>可以使用flat，是一个迭代器。<br>如果使用x[0][2]会降低性能。因为2索引需要在前面0索引创建的数组上面继续操作。<br>另见indexing。</p></blockquote><h2 id="形状操作"><a href="#形状操作" class="headerlink" title="形状操作"></a>形状操作</h2><blockquote><p>以下的命令不会修改数组，只会返回新的数组</p><ul><li>ravel 返回连续的平坦的数组，降成一维</li><li>reshape 修改形状</li><li>T 转置<br>修改数组本身</li><li>resize：对应的reshape是返回修改的数组<br>将不同的数组堆叠</li><li>vstack</li><li>hstack h v 分别对应水平方向和垂直方向。</li><li>column_stack</li><li>row_stack column 和 row 分别对应，并且这两个方法允许1D的数组堆叠到2D数组中<br>将数组分隔成几个小的数组</li><li><code>np.hsplit(a, 3) #将a划分为3个 h是水平</code></li><li><code>np.hsplit(a, (3, 4)) #将列为3-4但是不等于4的索引分隔开来</code> </li><li>同理vsplit是垂直划分</li><li>array_split 可以指定某个轴进行划分</li></ul></blockquote><h2 id="复制和视图"><a href="#复制和视图" class="headerlink" title="复制和视图"></a>复制和视图</h2><blockquote><p>当计算和操作数组时，它们的数据有时被复制到新的数组中，有时不复制。这通常是初学者的混乱的来源。有三种情况：</p><ul><li>完全不复制<br>简单赋值不会创建数组对象或其数据的拷贝：如果将b = a 那么b和a指向的是同一个数组，改变b，a也跟着改变。<br>可变对象传递到函数引用，函数不会复制。</li><li>视图或浅复制<br>不同的数组对象可以共享相同的数据。view方法创建一个新数组对象，该对象看到相同的数据。<br><code>c=a.view()</code>, 这样改变<code>c.shape = (2,6)</code>，a的形状不会改变，但是如果<code>c[0,4] = 1234</code>，a的相应位置就会赋值为1234<br><code>c.base is a = True</code><br>对数组切片返回的也是视图</li><li>深复制<br><code>d = a.copy()</code><br>这样d就是一个新的数组</li></ul></blockquote><h2 id="函数和方法概述"><a href="#函数和方法概述" class="headerlink" title="函数和方法概述"></a>函数和方法概述</h2><blockquote><p>这里是一些有用的NumPy函数和方法名称按类别排序的列表。有关完整列表，请参见Routines。</p><ul><li>数组创建<br><code>arange, array, copy, empty, empty_like, eye, fromfile, fromfunction, identity, linspace, logspace, mgrid, ogrid, ones, ones_like, r, zeros, zeros_like</code></li><li>转换<br><code>ndarray.astype，atleast_1d，atleast_2d，atleast_3d，mat</code></li><li>操纵<br><code>array_split, column_stack, concatenate, diagonal, dsplit, dstack, hsplit, hstack, ndarray.item, newaxis, ravel, repeat, reshape, resize, squeeze, swapaxes, take, transpose, vsplit, vstack</code></li><li>问题<br><code>all，any，nonzero，where</code></li><li>顺序<br><code>argmax, argmin, argsort, max, min, ptp, searchsorted, sort</code></li><li>操作<br><code>choose, compress, cumprod, cumsum, inner, ndarray.fill, imag, prod, put, putmask, real, sum</code></li><li>基本统计<br><code>cov，mean，std，var</code><br>基本线性代数<br><code>cross，dot，outer，linalg.svd，vdot</code></li></ul></blockquote><h2 id="其他基础"><a href="#其他基础" class="headerlink" title="其他基础"></a>其他基础</h2><h3 id="广播规则"><a href="#广播规则" class="headerlink" title="广播规则"></a>广播规则</h3><blockquote><ul><li>Broadcasting允许通用函数以有意义的方式处理具有不完全相同形状的输入。</li><li>Broadcasting的第一个规则是，如果所有输入数组不具有相同数量的维度，则“1”将被重复地添加到较小数组的形状，直到所有数组具有相同数量的维度。</li><li>Broadcasting的第二个规则确保沿着特定维度具有大小为1的数组表现得好像它们具有沿着该维度具有最大形状的数组的大小。假定数组元素的值沿“Broadcasting”数组的该维度相同。</li></ul></blockquote><h3 id="花式索引技巧"><a href="#花式索引技巧" class="headerlink" title="花式索引技巧"></a>花式索引技巧</h3><blockquote><p>NumPy提供了比常规Python序列更多的索引能力。除了通过整数和切片索引之外，如前所述，数组可以由整数数组和布尔数组索引。</p><ul><li>使用索引数组索引<br><code>a[j]</code> <code>j = np.array([1,1,3]) #得出索引a是1,1,3组成的数组</code><br>如果索引的数组是多维的，结果与之对应，<code>j = np.array([[1,2,3], [4, 5, 6]])</code>，结果是形状是<code>(2, 3)</code></li><li>可以对每个维度进行单独索引<br><code>i = np.array([[0,1], [1, 2]])</code><br><code>j = np.array([[2,1], [1, 3]])</code><br><code>a[i, j]</code><br>同样的 <code>l=[i,j]</code> <code>a[l]=a[i,j]</code></li></ul></blockquote><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><blockquote><p>np.ix_[a,b,c] ???雨里雾里<br>np.ufunc.reduce ???云里雾里</p></blockquote><h3 id="线性代数-基础"><a href="#线性代数-基础" class="headerlink" title="线性代数 基础"></a>线性代数 基础</h3><blockquote><p>简单的数组操作</p><ul><li><code>a.transpose() # 矩阵转置</code> </li><li><code>np.linalg.inv(a) # 逆矩阵</code></li><li><code>np.eye(2) # 2*2的矩阵，返回对角线是1其他都是0的矩阵</code></li><li><code>np.dot(i, j) # 求矩阵乘积</code></li><li><code>np.trace(a) # 对a矩阵的对角线值求和</code></li><li><code>np.linalg.solve(a, y) # 解线性方程组 a矩阵对应参数，y对应等于后边的数</code></li><li><code>np.linalg.eig(j) # 特征向量，线性代数当时没有学好</code></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;NumPy基础&quot;&gt;&lt;a href=&quot;#NumPy基础&quot; class=&quot;headerlink&quot; title=&quot;NumPy基础&quot;&gt;&lt;/a&gt;NumPy基础&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;NumPy的主要对象是同类型的多维数组，是一张表，所有元素（通常是数字）的
      
    
    </summary>
    
      <category term="Python" scheme="https://returnwow.github.io/categories/Python/"/>
    
    
      <category term="Numpy" scheme="https://returnwow.github.io/tags/Numpy/"/>
    
  </entry>
  
  <entry>
    <title>What is Numpy</title>
    <link href="https://returnwow.github.io/2017/11/16/python/numpy/01_what_is_numpy/"/>
    <id>https://returnwow.github.io/2017/11/16/python/numpy/01_what_is_numpy/</id>
    <published>2017-11-16T12:00:30.500Z</published>
    <updated>2018-01-27T01:55:36.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="What-is-Numpy"><a href="#What-is-Numpy" class="headerlink" title="What is Numpy"></a>What is Numpy</h1><blockquote><p><code>Numpy</code>是Python科学计算的基本包，提供对于多维数组（矩阵）等各种计算，比如c = a * b，a、b均为矩阵，可以对其进行直接计算，不用使用循环遍历。<br>本机测试计算速度为for循环遍历计算的500+倍。例子如下：目前找不到源网页，直接粘上例子。</p></blockquote><pre><code>import numpy as np import time#from timeit import timeita = np.random.rand(1000000)b = np.random.rand(1000000)time_s = time.time()c = np.dot(a, b)time_e = time.time()print(c, 1000*(time_e - time_s))c = 0time_s = time.time()for i in range(len(a)):    c += a[i] * b[i]time_e = time.time()print(c, 1000*(time_e - time_s))</code></pre><blockquote><p>下图所示<br><img src="/img/python/vectorization.png" alt="vectorization"></p></blockquote><h2 id="矢量化-Vectorization"><a href="#矢量化-Vectorization" class="headerlink" title="矢量化(Vectorization)"></a>矢量化(Vectorization)</h2><blockquote><p>上面的例子是矢量化的例子（Vectorization），包含以下优点：</p><ul><li>代码更简洁</li><li>更少的代码通常意味着更少的错误</li><li>代码运行更接近标准的数学符号，封装了具体的困难的运算，如上np.dot(a, b)直接计算两个矩阵的积。</li><li>矢量化导致更多的“Pythonic”(网络解释为很Python的Python代码)代码。如果没有向量化，我们的代码将会效率很低，难以读取for循环。</li></ul></blockquote><h2 id="广播-Broadcasting"><a href="#广播-Broadcasting" class="headerlink" title="广播(Broadcasting)"></a>广播(Broadcasting)</h2><blockquote><p>广播是用于描述操作的隐式逐个元素行为的术语<br>大概意思就是比如做矩阵的运算，a为一维矩阵，b为标量，如果做计算<code>a + b</code>，会自动的将a的元素都加上b（我的简单理解）</p></blockquote><h1 id="源网站"><a href="#源网站" class="headerlink" title="源网站"></a>源网站</h1><blockquote><p><a href="http://python.usyiyi.cn" title="Numpy 中文API" target="_blank" rel="external">Numpy 中文 API</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;What-is-Numpy&quot;&gt;&lt;a href=&quot;#What-is-Numpy&quot; class=&quot;headerlink&quot; title=&quot;What is Numpy&quot;&gt;&lt;/a&gt;What is Numpy&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Numpy&lt;/
      
    
    </summary>
    
      <category term="Python" scheme="https://returnwow.github.io/categories/Python/"/>
    
    
      <category term="Learn Numpy" scheme="https://returnwow.github.io/tags/Learn-Numpy/"/>
    
  </entry>
  
  <entry>
    <title>Git删除提交的文件</title>
    <link href="https://returnwow.github.io/2017/11/05/git/git_rm_use_cached/"/>
    <id>https://returnwow.github.io/2017/11/05/git/git_rm_use_cached/</id>
    <published>2017-11-05T12:26:57.179Z</published>
    <updated>2018-01-27T06:06:24.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目的为了测试Markdown书写"><a href="#目的为了测试Markdown书写" class="headerlink" title="目的为了测试Markdown书写"></a>目的为了测试Markdown书写</h1><blockquote><p>本人在学习 git 的时候，前期将本地的日志文件提交到仓库，然后也就查找了相关的操作方法，最终使用此命令解决的，然后新增<code>.gitignore</code>文件，提交，再次使用<code>git status</code>这些文件就不会再次出现了，其他情况也可以使用这个方法：将数据库账号密码配置文件从远端仓库删除。</p></blockquote><h1 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h1><h2 id="git-rm-Filename-or-Foldername："><a href="#git-rm-Filename-or-Foldername：" class="headerlink" title="git rm Filename or Foldername："></a>git rm Filename or Foldername：</h2><blockquote><p>使用在当我们提交了一个不想提交的文件，可以使用其删除本地工作目录的文件，一般我们可能需要保留源文件，所以可以使用：<code>--cached</code>参数来实现只删除索引（官方：Index，跟踪的文件清单）。</p></blockquote><h2 id="git-rm-–cached-Filename-or-Foldername："><a href="#git-rm-–cached-Filename-or-Foldername：" class="headerlink" title="git rm –cached Filename or Foldername："></a>git rm –cached Filename or Foldername：</h2><blockquote><p>使用 <code>--cached</code> 将会保留本地文件，只删除暂存区的文件，提交这次修改，该文件就不会纳入版本管理了，远端的仓库也会同步这个修改，达到删除文件目的。</p></blockquote><h2 id="常用参数："><a href="#常用参数：" class="headerlink" title="常用参数："></a>常用参数：</h2><blockquote><ul><li><code>-n</code> or <code>--dry-run</code> 加上这个参数是不会做任何删除操作的，只是将符合<code>filename</code>删除的文件预览打印出来，准确的说加上这个参数会打印此操作产生影响（删除）的文件列表。<ul><li><code>git rm -n --cached txt/\\*.txt</code>  #将会列出txt目录下的符合拓展名字为.txt的文件，反斜杠<code>\</code>为转义字符。</li></ul></li><li><code>-f</code> 这个参数是强制执行的意思，如果我们已经将文件提交到暂存区，这个时候需要加上这个参数。</li><li><code>-r</code> 类似bash命令就是递归删除了，如果删除目录使用此参数。</li></ul></blockquote><h2 id="官网相关页面："><a href="#官网相关页面：" class="headerlink" title="官网相关页面："></a>官网相关页面：</h2><blockquote><p><a href="https://git-scm.com/docs/git-rm" title="get-rm" target="_blank" rel="external">git-rm</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;目的为了测试Markdown书写&quot;&gt;&lt;a href=&quot;#目的为了测试Markdown书写&quot; class=&quot;headerlink&quot; title=&quot;目的为了测试Markdown书写&quot;&gt;&lt;/a&gt;目的为了测试Markdown书写&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本
      
    
    </summary>
    
      <category term="git" scheme="https://returnwow.github.io/categories/git/"/>
    
    
      <category term="git rm 删除 文件" scheme="https://returnwow.github.io/tags/git-rm-%E5%88%A0%E9%99%A4-%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
</feed>
